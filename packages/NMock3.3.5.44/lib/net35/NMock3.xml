<?xml version="1.0"?>
<doc>
  <assembly>
    <name>NMock3</name>
  </assembly>
  <members>
    <member name="T:NMock.Signal">
      <summary>
            Defines that an <see cref="M:NMock.Signal.EventWaitHandle(System.Threading.EventWaitHandle)" /> should be signaled.
            </summary>
    </member>
    <member name="M:NMock.Signal.EventWaitHandle(System.Threading.EventWaitHandle)">
      <summary>
            Signals an <see cref="M:NMock.Signal.EventWaitHandle(System.Threading.EventWaitHandle)" /> to synchronizes threads.
            </summary>
      <param name="signal">The signal to set.</param>
      <returns>Action that signals an <see cref="M:NMock.Signal.EventWaitHandle(System.Threading.EventWaitHandle)" />.</returns>
    </member>
    <member name="T:NMock.ISelfDescribing">
      <summary>
            This interface is used to get a description of the implementator.
            </summary>
    </member>
    <member name="M:NMock.ISelfDescribing.DescribeTo(System.IO.TextWriter)">
      <summary>
            Describes this object.
            </summary>
      <param name="writer">The text writer the description is added to.</param>
    </member>
    <member name="T:NMock.Monitoring.Invocation">
      <summary>
            Represents the invocation of a method on an object (receiver).
            </summary>
    </member>
    <member name="F:NMock.Monitoring.Invocation.exception">
      <summary>
            Holds the exception to be thrown. When this field has been set, <see cref="P:NMock.Monitoring.Invocation.IsThrowing" /> will become true.
            </summary>
    </member>
    <member name="F:NMock.Monitoring.Invocation.result">
      <summary>
            Holds the result of the invocation.
            </summary>
    </member>
    <member name="M:NMock.Monitoring.Invocation.#ctor(System.Object,System.Reflection.MethodBase,System.Object[])">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Monitoring.Invocation" /> class.
            </summary>
      <param name="receiver">The receiver providing the method.</param>
      <param name="method">The method.</param>
      <param name="arguments">The parameters passed to the method..</param>
    </member>
    <member name="M:NMock.Monitoring.Invocation.InvokeOn(System.Object)">
      <summary>
            Invokes this invocation on the specified receiver and stores the result and exception
            returns/thrown by the invocation.
            </summary>
      <param name="receiver">The receiver.</param>
    </member>
    <member name="M:NMock.Monitoring.Invocation.ValidateReturnType(System.Object)">
      <summary>
            Checks the returnType of the initialized method if it is valid to be mocked.
            </summary>
      <param name="value">The return value to be checked.</param>
    </member>
    <member name="M:NMock.Monitoring.Invocation.IsProperty">
      <summary>
            Determines whether the initialized method is a property.
            </summary>
      <returns>
            Returns true if initialized method is a property; false otherwise.
            </returns>
    </member>
    <member name="M:NMock.Monitoring.Invocation.IsIndexerGetter">
      <summary>
            Determines whether the initialized method is an index getter.
            </summary>
      <returns>
            Returns true if initialized method is an index getter; false otherwise.
            </returns>
    </member>
    <member name="M:NMock.Monitoring.Invocation.IsIndexerSetter">
      <summary>
            Determines whether the initialized method is an index setter.
            </summary>
      <returns>
            Returns true if initialized method is an index setter; false otherwise.
            </returns>
    </member>
    <member name="M:NMock.Monitoring.Invocation.DescribeAsProperty(System.IO.TextWriter)">
      <summary>
            Describes the property with parameters to the specified <paramref name="writer" />.
            </summary>
      <param name="writer">The writer where the description is written to.</param>
    </member>
    <member name="M:NMock.Monitoring.Invocation.DescribeAsIndexerGetter(System.IO.TextWriter)">
      <summary>
            Describes the index setter with parameters to the specified <paramref name="writer" />.
            </summary>
      <param name="writer">The writer where the description is written to.</param>
    </member>
    <member name="M:NMock.Monitoring.Invocation.DescribeAsIndexerSetter(System.IO.TextWriter)">
      <summary>
            Describes the index setter with parameters to the specified <paramref name="writer" />.
            </summary>
      <param name="writer">The writer where the description is written to.</param>
    </member>
    <member name="M:NMock.Monitoring.Invocation.DescribeNormalMethod(System.IO.TextWriter)">
      <summary>
            Describes the method with parameters to the specified <paramref name="writer" />.
            </summary>
      <param name="writer">The writer where the description is written to.</param>
    </member>
    <member name="M:NMock.Monitoring.Invocation.WriteTypeParams(System.IO.TextWriter)">
      <summary>
            Writes the generic parameters of the method to the specified <paramref name="writer" />.
            </summary>
      <param name="writer">The writer where the description is written to.</param>
    </member>
    <member name="M:NMock.Monitoring.Invocation.WriteParameterList(System.IO.TextWriter,System.Int32)">
      <summary>
            Writes the parameter list to the specified <paramref name="writer" />.
            </summary>
      <param name="writer">The writer where the description is written to.</param>
      <param name="count">The count of parameters to describe.</param>
    </member>
    <member name="M:NMock.Monitoring.Invocation.DescribeAsEventAdder(System.IO.TextWriter)">
      <summary>
            Describes the event adder to the specified <paramref name="writer" />.
            </summary>
      <param name="writer">The writer where the description is written to.</param>
    </member>
    <member name="M:NMock.Monitoring.Invocation.DescribeAsEventRemover(System.IO.TextWriter)">
      <summary>
            Describes the event remover to the specified <paramref name="writer" />.
            </summary>
      <param name="writer">The writer where the description is written to.</param>
    </member>
    <member name="P:NMock.Monitoring.Invocation.Receiver">
      <summary>
            Holds the receiver providing the method.
            </summary>
    </member>
    <member name="P:NMock.Monitoring.Invocation.MockObject">
      <summary>
            Returns the Receiver as an <see cref="T:NMock.IMockObject" /></summary>
    </member>
    <member name="P:NMock.Monitoring.Invocation.MethodBase">
      <summary>
            Gets the <see cref="P:NMock.Monitoring.Invocation.MethodBase" /> that was passed into the constructor of this <see cref="T:NMock.Monitoring.Invocation" /></summary>
    </member>
    <member name="P:NMock.Monitoring.Invocation.Method">
      <summary>
            Holds the method that is being invoked.
            </summary>
    </member>
    <member name="P:NMock.Monitoring.Invocation.MethodName">
      <summary>
            Gets the name of method or property specified by the <see cref="T:NMock.Monitoring.Invocation" /></summary>
    </member>
    <member name="P:NMock.Monitoring.Invocation.MethodSignature">
      <summary>
            Gets a string that represents the signature of the <see cref="P:NMock.Monitoring.Invocation.Method" /></summary>
    </member>
    <member name="P:NMock.Monitoring.Invocation.MethodSignatureForSetter">
      <summary>
            Gets a string that represents the signature of the property setter
            </summary>
    </member>
    <member name="P:NMock.Monitoring.Invocation.MethodReturnType">
      <summary>
            Gets the return type of the method specified by the <see cref="T:NMock.Monitoring.Invocation" /></summary>
    </member>
    <member name="P:NMock.Monitoring.Invocation.MethodParameters">
      <summary>
            Gets the parameters of the method specified by the <see cref="T:NMock.Monitoring.Invocation" /></summary>
    </member>
    <member name="P:NMock.Monitoring.Invocation.Arguments">
      <summary>
            Gets the arguments passed into the constructor of this <see cref="T:NMock.Monitoring.Invocation" /></summary>
    </member>
    <member name="P:NMock.Monitoring.Invocation.Parameters">
      <summary>
            Holds the parameterlist of the invocation.
            </summary>
    </member>
    <member name="P:NMock.Monitoring.Invocation.Result">
      <summary>
            Gets or sets the result of the invocation.
            </summary>
      <value>The result.</value>
    </member>
    <member name="P:NMock.Monitoring.Invocation.SetterResult">
      <summary>
            Stores the value being assigned in a setter.
            </summary>
      <remarks>
            Used internally to store a setter value to return in an automatic getter.
            </remarks>
    </member>
    <member name="P:NMock.Monitoring.Invocation.Exception">
      <summary>
            Gets or sets the exception that is thrown on the invocation.
            </summary>
      <value>The exception.</value>
    </member>
    <member name="P:NMock.Monitoring.Invocation.IsThrowing">
      <summary>
            Gets a value indicating whether an exception is thrown an this invocation.
            </summary>
      <value>
        <c>true</c> if this invocation is throwing an exception; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:NMock.Monitoring.Invocation.IsEventAdder">
      <summary>
            Determines whether the initialized method is an event adder.
            </summary>
      <returns>
            Returns true if initialized method is an event adder; false otherwise.
            </returns>
    </member>
    <member name="P:NMock.Monitoring.Invocation.IsEventRemover">
      <summary>
            Determines whether the initialized method is an event remover.
            </summary>
      <returns>
            Returns true if initialized method is an event remover; false otherwise.
            </returns>
    </member>
    <member name="P:NMock.Monitoring.Invocation.IsEventAccessor">
      <summary>
            Gets a value indicating if this <see cref="T:NMock.Monitoring.Invocation" /> is an event
            </summary>
    </member>
    <member name="P:NMock.Monitoring.Invocation.IsPropertyAccessor">
      <summary>
            Gets a value indicating if this <see cref="T:NMock.Monitoring.Invocation" /> is a property
            </summary>
    </member>
    <member name="P:NMock.Monitoring.Invocation.IsPropertySetAccessor">
      <summary>
            Gets a value indicating if this <see cref="T:NMock.Monitoring.Invocation" /> is a property setter
            </summary>
    </member>
    <member name="P:NMock.Monitoring.Invocation.IsPropertyGetAccessor">
      <summary>
            Gets a value indicating if this <see cref="T:NMock.Monitoring.Invocation" /> is a property getter
            </summary>
    </member>
    <member name="P:NMock.Monitoring.Invocation.IsMethod">
      <summary>
            Gets a value indicating if this <see cref="T:NMock.Monitoring.Invocation" /> is a method.
            </summary>
    </member>
    <member name="T:NMock.Matcher">
      <summary>
            A matcher is used to match objects against it.
            </summary>
    </member>
    <member name="M:NMock.Matcher.#ctor">
      <summary>
            Initializes an instance of the <see cref="T:NMock.Matcher" /> class with an empty <see cref="P:NMock.Matcher.Description" /></summary>
    </member>
    <member name="M:NMock.Matcher.#ctor(System.String)">
      <summary>
            Initialized an instance of the <see cref="T:NMock.Matcher" /> class with the description argument.
            </summary>
      <param name="description">The value used when calling the <see cref="M:NMock.Matcher.DescribeTo(System.IO.TextWriter)" /> method.</param>
    </member>
    <member name="M:NMock.Matcher.DescribeTo(System.IO.TextWriter)">
      <summary>
            Describes this matcher.
            </summary>
      <param name="writer">The text writer the description is added to.</param>
    </member>
    <member name="M:NMock.Matcher.op_BitwiseAnd(NMock.Matcher,NMock.Matcher)">
      <summary>
            Logical and of to matchers.
            </summary>
      <param name="m1">First matcher.</param>
      <param name="m2">Second matcher.</param>
      <returns>Matcher combining the two operands.</returns>
    </member>
    <member name="M:NMock.Matcher.op_BitwiseOr(NMock.Matcher,NMock.Matcher)">
      <summary>
            Logical or of to matchers.
            </summary>
      <param name="m1">First matcher.</param>
      <param name="m2">Second matcher.</param>
      <returns>Matcher combining the two operands.</returns>
    </member>
    <member name="M:NMock.Matcher.op_LogicalNot(NMock.Matcher)">
      <summary>
            Negation of a matcher.
            </summary>
      <param name="m">Matcher to negate.</param>
      <returns>Negation of the specified matcher.</returns>
    </member>
    <member name="M:NMock.Matcher.Matches(System.Object)">
      <summary>
            Matches the specified object to this matcher and returns whether it matches.
            </summary>
      <param name="o">The object to match.</param>
      <returns>Whether the object matches.</returns>
    </member>
    <member name="M:NMock.Matcher.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </summary>
      <returns>
            A <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </returns>
    </member>
    <member name="P:NMock.Matcher.Description">
      <summary>
            A default description used when calling <see cref="M:NMock.Matcher.DescribeTo(System.IO.TextWriter)" /></summary>
    </member>
    <member name="T:NMock.Matchers.NotMatcher">
      <summary>
            Matcher that negates another matcher.
            </summary>
    </member>
    <member name="F:NMock.Matchers.NotMatcher.negated">
      <summary>
            Holds the matcher to negate.
            </summary>
    </member>
    <member name="M:NMock.Matchers.NotMatcher.#ctor(NMock.Matcher)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Matchers.NotMatcher" /> class.
            </summary>
      <param name="negated">The matcher to negate.</param>
    </member>
    <member name="M:NMock.Matchers.NotMatcher.Matches(System.Object)">
      <summary>
            Matches the specified object to this matcher and returns whether it matches.
            </summary>
      <param name="o">The object to match.</param>
      <returns>Whether the object does not matche the wrapped matcher.</returns>
    </member>
    <member name="M:NMock.Matchers.NotMatcher.DescribeTo(System.IO.TextWriter)">
      <summary>
            Describes this matcher.
            </summary>
      <param name="writer">The text writer to which the description is added.</param>
    </member>
    <member name="T:NMock.IMockDefinition">
      <summary>
            The definition of a mock object.
            </summary>
      <remarks>
            Implementations of this interface encapsulate the details of
            how a mock object is defined, and provide the ability to be able to
            instantiate an instance of it.
            </remarks>
    </member>
    <member name="M:NMock.IMockDefinition.Create(System.Type,NMock.MockFactory,NMock.Proxy.IMockObjectFactory)">
      <summary>
            This method supports NMock infrastructure and is not intended to be called directly from your code.
            </summary>
      <param name="primaryType">The primary type that is being mocked.</param>
      <param name="mockFactory">The current <see cref="T:NMock.MockFactory" /> instance.</param>
      <param name="mockObjectFactory">An <see cref="T:NMock.Proxy.IMockObjectFactory" /> to use when creating the mock.</param>
      <returns>A new mock instance.</returns>
    </member>
    <member name="T:NMock.Syntax.IMockDefinitionSyntax">
      <summary>
            Syntax describing the initial characteristics of a new mock object.
            </summary>
    </member>
    <member name="M:NMock.Syntax.IMockDefinitionSyntax.Implementing``1">
      <summary>
            Specifies a type that this mock should implement. This may be a class or interface,
            but there can only be a maximum of one class implemented by a mock.
            </summary>
      <typeparam name="T">The type to implement.</typeparam>
      <returns>The mock object definition.</returns>
    </member>
    <member name="M:NMock.Syntax.IMockDefinitionSyntax.Implementing(System.Type[])">
      <summary>
            Specifies the types that this mock should implement. These may be a class or interface,
            but there can only be a maximum of one class implemented by a mock.
            </summary>
      <param name="additionalTypesToMock">The types to implement.</param>
      <returns>The mock object definition.</returns>
    </member>
    <member name="M:NMock.Syntax.IMockDefinitionSyntax.OfStyle(NMock.MockStyle)">
      <summary>
            Specifies how the mock object should behave when first created.
            It is invalid to set the MockStyle of a mock more than once.
            </summary>
      <param name="style">A MockStyle value.</param>
      <returns>The mock object definition.</returns>
    </member>
    <member name="M:NMock.Syntax.IMockDefinitionSyntax.WithArgs(System.Object[])">
      <summary>
            Specifies the arguments for the constructor of the class to be mocked.
            Only applicable when mocking a class with a non-default constructor.
            It is invalid to specify the constructor arguments of a mock more than once.
            </summary>
      <param name="args">The arguments for the class constructor.</param>
      <returns>The mock object definition.</returns>
    </member>
    <member name="M:NMock.Syntax.IMockDefinitionSyntax.Named(System.String)">
      <summary>
            Specifies a name for the mock. This will be used in error messages,
            and as the return value of ToString() if not mocking a class.
            It is invalid to specify the name of a mock more than once.
            </summary>
      <param name="name">The name for the mock.</param>
      <returns>The mock object definition.</returns>
    </member>
    <member name="T:NMock.Internal.MockBuilder">
      <summary>
            Allows a mock object to be incrementally defined, and then finally created.
            </summary>
    </member>
    <member name="F:NMock.Internal.MockBuilder.EmptyArgsArray">
      <summary>
            A single empty array instance that is used as a default value
            for constructor arguments.
            </summary>
    </member>
    <member name="F:NMock.Internal.MockBuilder._types">
      <summary>
            The types that the mock object needs to implement.
            </summary>
    </member>
    <member name="F:NMock.Internal.MockBuilder._constructorArgs">
      <summary>
            Constructor arguments for any class type that this mock might subclass.
            If not subclassing, or if using a default constructor, then this should
            be an empty array.
            </summary>
    </member>
    <member name="F:NMock.Internal.MockBuilder._mockStyle">
      <summary>
            The MockStyle for the mock. If not specified, this will ultimately be
            assumed to be MockStyle.Default.
            </summary>
    </member>
    <member name="F:NMock.Internal.MockBuilder._name">
      <summary>
            The name of the mock object. Null is a valid value.
            </summary>
    </member>
    <member name="M:NMock.Internal.MockBuilder.Implementing``1">
      <summary>
            Specifies a type that this mock should implement. This may be a class or interface,
            but there can only be a maximum of one class implemented by a mock.
            </summary>
      <typeparam name="T">The type to implement.</typeparam>
      <returns>The mock object definition.</returns>
    </member>
    <member name="M:NMock.Internal.MockBuilder.Implementing(System.Type[])">
      <summary>
            Specifies the types that this mock should implement. These may be a class or interface,
            but there can only be a maximum of one class implemented by a mock.
            </summary>
      <param name="additionalTypesToMock">The types to implement.</param>
      <returns>The mock object definition.</returns>
    </member>
    <member name="M:NMock.Internal.MockBuilder.OfStyle(NMock.MockStyle)">
      <summary>
            Specifies how the mock object should behave when first created.
            It is invalid to set the MockStyle of a mock more than once.
            </summary>
      <param name="mockStyle">A MockStyle value.</param>
      <returns>The mock object definition.</returns>
    </member>
    <member name="M:NMock.Internal.MockBuilder.WithArgs(System.Object[])">
      <summary>
            Specifies the arguments for the constructor of the class to be mocked.
            Only applicable when mocking a class with a non-default constructor.
            It is invalid to specify the constructor arguments of a mock more than once.
            </summary>
      <param name="args">The arguments for the class constructor.</param>
      <returns>The mock object definition.</returns>
    </member>
    <member name="M:NMock.Internal.MockBuilder.Named(System.String)">
      <summary>
            Specifies a name for the mock. This will be used in error messages,
            and as the return value of ToString() if not mocking a class.
            It is invalid to specify the name of a mock more than once.
            </summary>
      <param name="name">The name for the mock.</param>
      <returns>The mock object definition.</returns>
    </member>
    <member name="M:NMock.Internal.MockBuilder.Create(System.Type,NMock.MockFactory,NMock.Proxy.IMockObjectFactory)">
      <summary>
            This method supports NMock infrastructure and is not intended to be called directly from your code.
            </summary>
      <param name="primaryType">The primary type that is being mocked.</param>
      <param name="mockFactory">The current <see cref="T:NMock.MockFactory" /> instance.</param>
      <param name="mockObjectFactory">An <see cref="T:NMock.Proxy.IMockObjectFactory" /> to use when creating the mock.</param>
      <returns>A new mock instance.</returns>
    </member>
    <member name="M:NMock.Internal.MockBuilder.CheckInterfacesDoNotContainToStringMethodDeclaration(NMock.Proxy.CompositeType)">
      <summary>
            Checks that interfaces do not contain ToString method declarations.
            </summary>
      <param name="mockedTypes">The types that are to be mocked.</param>
    </member>
    <member name="T:NMock.Syntax.IValueSyntax">
      <summary>
            Syntax defining a value.
            </summary>
    </member>
    <member name="M:NMock.Syntax.IValueSyntax.To(NMock.Matcher)">
      <summary>
            Defines a value.
            </summary>
      <param name="valueMatcher">The value matcher.</param>
      <returns>Match syntax defining the behavior of the value.</returns>
    </member>
    <member name="T:NMock.Syntax.ICommentSyntax">
      <summary>
            Syntax for adding an explanation for the expectation.
            </summary>
    </member>
    <member name="M:NMock.Syntax.ICommentSyntax.Comment(System.String)">
      <summary>
            Adds a comment for the expectation that is added to the error message if the expectation is not met.
            </summary>
      <param name="comment">The comment that is shown in the error message if this expectation is not met.
            You can describe here why this expectation has to be met.</param>
    </member>
    <member name="T:NMock.EventInvokerBase">
      <summary>
            Base class for Invoker classes that raise events.
            </summary>
    </member>
    <member name="M:NMock.EventInvokerBase.MockEventHookup.#ctor(NMock.EventInvokerBase,System.Boolean)">
      <summary>
            Constructor
            </summary>
      <param name="invoker">
      </param>
      <param name="isDelegate">
      </param>
    </member>
    <member name="F:NMock.EventInvokerBase.Handler">
      <summary>
            Holds a reference to the delegate that will be invoked.
            </summary>
    </member>
    <member name="M:NMock.EventInvokerBase.Comment(System.String)">
      <summary>
            Adds a comment for the expectation that is added to the error message if the expectation is not met.
            </summary>
      <param name="comment">The comment that is shown in the error message if this expectation is not met.
            You can describe here why this expectation has to be met.</param>
    </member>
    <member name="M:NMock.EventInvokerBase.Hookup(System.Boolean)">
      <summary>
            Hooks up with the action that will be taken once a handler is added to the event.
            </summary>
      <returns>The action to hook the incoming handler to the event.</returns>
    </member>
    <member name="M:NMock.EventInvokerBase.RaiseEvent(System.Object[])">
      <summary>
            Raises the event that created the expectations.
            </summary>
      <param name="args">Arguments for the event.</param>
    </member>
    <member name="T:NMock.IAction">
      <summary>
            An action defines something that has to be done.
            For example the action to return a result value.
            </summary>
    </member>
    <member name="M:NMock.IAction.Invoke(NMock.Monitoring.Invocation)">
      <summary>
            Invokes this object.
            </summary>
      <param name="invocation">The invocation.</param>
    </member>
    <member name="T:NMock.EventInvoker`1">
      <summary>
            Can mock invoke any event it is feed with.
            </summary>
      <remarks>
            Code by Magnus Mårtensson
            http://blog.noop.se/archive/2007/08/17.aspx
            </remarks>
    </member>
    <member name="M:NMock.EventInvoker`1.Invoke(`0)">
      <summary>
      </summary>
      <param name="e">
      </param>
    </member>
    <member name="M:NMock.EventInvoker`1.Invoke(System.Object,`0)">
      <summary>
            Invoke the event and send in parameter.
            </summary>
      <param name="sender">The sender of the event.</param>
      <param name="e">The arguments of the call.</param>
    </member>
    <member name="T:NMock.EventInvoker">
      <summary>
            EventInvoker is used to invoke events that definded by the <see cref="T:System.EventHandler" />.
            </summary>
      <remarks>
            An EventInvoker is created as a result of a call to the <see cref="M:NMock.Syntax.IStubSyntax`1.EventBinding(System.Action{`0})" /> method.
            </remarks>
    </member>
    <member name="M:NMock.EventInvoker.Invoke">
      <summary>
            Invokes the referenced event
            </summary>
    </member>
    <member name="T:NMock.Actions.GetArgumentsAction">
      <summary>
            Action that executes the delegate passed to the constructor to get argments of executed method.
            </summary>
    </member>
    <member name="M:NMock.Actions.GetArgumentsAction.#ctor(System.Action{NMock.Monitoring.ParameterList})">
      <summary>
            constustor of GetArgumentsAction
            </summary>
      <param name="handler">delegate used to get argments of executed method</param>
    </member>
    <member name="T:NMock.Actions.CollectAction">
      <summary>
            Action that returns the n-th element of the arguments to an invocation.
            </summary>
    </member>
    <member name="F:NMock.Actions.CollectAction.argumentIndex">
      <summary>
            Stores the index of the argument.
            </summary>
    </member>
    <member name="F:NMock.Actions.CollectAction.collectedArgumentValue">
      <summary>
            Stores the parameter when this action gets invoked.
            </summary>
    </member>
    <member name="M:NMock.Actions.CollectAction.#ctor(System.Int32)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Actions.CollectAction" /> class.
            </summary>
      <param name="argumentIndex">Index of the argument to collect.</param>
    </member>
    <member name="P:NMock.Actions.CollectAction.Parameter">
      <summary>
            Gets the collected parameter.
            </summary>
      <value>The collected parameter (n-th parameter of parameter list of the method's call.</value>
    </member>
    <member name="T:NMock.Matchers.PropertyMatcher">
      <summary>
            Matcher that checks whether the actual object has a property with the specified name 
            and its value matches the specified matcher.
            </summary>
    </member>
    <member name="M:NMock.Matchers.PropertyMatcher.#ctor(System.String,NMock.Matcher)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Matchers.PropertyMatcher" /> class.
            </summary>
      <param name="propertyName">Name of the property.</param>
      <param name="valueMatcher">The value matcher.</param>
    </member>
    <member name="M:NMock.Matchers.PropertyMatcher.Matches(System.Object)">
      <summary>
            Matches the specified object to this matcher and returns whether it matches.
            </summary>
      <param name="o">The object to match.</param>
      <returns>Whether the object has a property with the expected name and expected value.</returns>
    </member>
    <member name="M:NMock.Matchers.PropertyMatcher.DescribeTo(System.IO.TextWriter)">
      <summary>
            Describes this matcher.
            </summary>
      <param name="writer">The text writer to which the description is added.</param>
    </member>
    <member name="T:NMock.Matchers.ElementMatcher">
      <summary>
            Matcher that checks whether a single object is in a collection of elements.
            </summary>
    </member>
    <member name="M:NMock.Matchers.ElementMatcher.#ctor(System.Collections.ICollection)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Matchers.ElementMatcher" /> class.
            </summary>
      <param name="collection">The collection to match against.</param>
    </member>
    <member name="M:NMock.Matchers.ElementMatcher.Matches(System.Object)">
      <summary>
            Matches the specified object to this matcher and returns whether it matches.
            </summary>
      <param name="actual">The object to match.</param>
      <returns>Whether to object matches.</returns>
    </member>
    <member name="M:NMock.Matchers.ElementMatcher.DescribeTo(System.IO.TextWriter)">
      <summary>
            Describes this matcher.
            </summary>
      <param name="writer">The text writer to which the description is added.</param>
    </member>
    <member name="T:NMock.IExpectation">
      <summary>
            Represents an expectation.
            </summary>
    </member>
    <member name="M:NMock.IExpectation.Matches(NMock.Monitoring.Invocation)">
      <summary>
            Checks whether stored expectations matches the specified invocation.
            </summary>
      <param name="invocation">The invocation to check.</param>
      <returns>Returns whether one of the stored expectations has met the specified invocation.</returns>
    </member>
    <member name="M:NMock.IExpectation.MatchesIgnoringIsActive(NMock.Monitoring.Invocation)">
      <summary>
            Matcheses the ignoring is active.
            </summary>
      <param name="invocation">The invocation.</param>
      <returns>
      </returns>
    </member>
    <member name="M:NMock.IExpectation.Perform(NMock.Monitoring.Invocation)">
      <summary>
            Performs the specified invocation.
            </summary>
      <param name="invocation">The invocation.</param>
      <returns>A value indicating if the <paramref name="invocation" /> was successfully performed.</returns>
    </member>
    <member name="M:NMock.IExpectation.DescribeActiveExpectationsTo(System.IO.TextWriter)">
      <summary>
            Describes the active expectations to.
            </summary>
      <param name="writer">The writer.</param>
    </member>
    <member name="M:NMock.IExpectation.DescribeUnmetExpectationsTo(System.IO.TextWriter)">
      <summary>
            Describes the unmet expectations to.
            </summary>
      <param name="writer">The writer.</param>
    </member>
    <member name="M:NMock.IExpectation.QueryExpectationsBelongingTo(NMock.IMockObject,System.Collections.Generic.IList{NMock.IExpectation})">
      <summary>
            Adds all expectations to <paramref name="result" /> that are associated to <paramref name="mock" />.
            </summary>
      <param name="mock">The mock for which expectations are queried.</param>
      <param name="result">The result to add matching expectations to.</param>
    </member>
    <member name="M:NMock.IExpectation.ValidationErrors">
      <summary>
            Returns a list of expectation validation errors
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:NMock.IExpectation.IsActive">
      <summary>
            Gets a value indicating whether this instance is active.
            </summary>
      <value>
        <c>true</c> if this instance is active; otherwise, <c>false</c>.</value>
    </member>
    <member name="P:NMock.IExpectation.HasBeenMet">
      <summary>
            Gets a value indicating whether this instance has been met.
            </summary>
      <value>
        <c>true</c> if this instance has been met; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:NMock.IExpectation.IsValid">
      <summary>
            Gets a value indicating that the expectation is valid.
            </summary>
    </member>
    <member name="P:NMock.IExpectation.Parent">
      <summary>
            Gets or sets the <see cref="T:NMock.IExpectationList" /> that contains this <see cref="T:NMock.IExpectationList" /></summary>
    </member>
    <member name="T:NMock.IExpectationList">
      <summary>
            Represents an ExpectationList
            </summary>
    </member>
    <member name="M:NMock.IExpectationList.AddExpectation(NMock.IExpectation)">
      <summary>
            Adds an expectation.
            </summary>
      <param name="expectation">The expectation to add.</param>
    </member>
    <member name="M:NMock.IExpectationList.RemoveExpectation(NMock.IExpectation)">
      <summary>
            Removes the specified expectation.
            </summary>
      <param name="expectation">The expectation to remove.</param>
    </member>
    <member name="M:NMock.IExpectationList.ContainsOrderedExpectationFor(NMock.Monitoring.Invocation)">
      <summary>
            Determines if the <see cref="T:NMock.Monitoring.Invocation" /> is in an ordered list.
            </summary>
      <param name="invocation">The <see cref="T:NMock.Monitoring.Invocation" /> to look for.</param>
      <returns>
      </returns>
    </member>
    <member name="P:NMock.IExpectationList.Root">
      <summary>
            Gets the root <see cref="T:NMock.IExpectationList" /> for the <see cref="T:NMock.MockFactory" /></summary>
    </member>
    <member name="P:NMock.IExpectationList.Depth">
      <summary>
            The nesting level of this <see cref="T:NMock.IExpectationList" /></summary>
    </member>
    <member name="F:NMock.Internal.ExpectationListBase.depth">
      <summary>
            Stores the calling depth for the document writer output.
            </summary>
    </member>
    <member name="M:NMock.Internal.ExpectationListBase.QueryExpectationsBelongingTo(NMock.IMockObject,System.Collections.Generic.IList{NMock.IExpectation})">
      <summary>
            Adds all expectations to <paramref name="result" /> that are associated to <paramref name="mock" />.
            </summary>
      <param name="mock">The mock for which expectations are queried.</param>
      <param name="result">The result to add matching expectations to.</param>
    </member>
    <member name="P:NMock.Internal.ExpectationListBase.Parent">
      <summary>
            Gets or sets the expectation list that contains this ordering
            </summary>
    </member>
    <member name="P:NMock.Internal.ExpectationListBase.Root">
      <summary>
            Gets the root <see cref="T:NMock.IExpectationList" /> for the <see cref="T:NMock.MockFactory" /></summary>
    </member>
    <member name="P:NMock.Internal.ExpectationListBase.HasBeenMet">
      <summary>
            Gets a value indicating whether this instance has been met.
            </summary>
      <value>
        <c>true</c> if this instance has been met; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="M:NMock.Internal.OrderedExpectationList.#ctor(NMock.IExpectationList)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Internal.OrderedExpectationList" /> class.
            </summary>
      <param name="parent">The parent <see cref="T:NMock.IExpectationList" /> of this <see cref="T:NMock.Internal.OrderedExpectationList" /></param>
    </member>
    <member name="M:NMock.Internal.OrderedExpectationList.Matches(NMock.Monitoring.Invocation)">
      <summary>
            Checks whether stored expectations matches the specified invocation.
            </summary>
      <param name="invocation">The invocation to check.</param>
      <returns>Returns whether one of the stored expectations has met the specified invocation.</returns>
    </member>
    <member name="P:NMock.Internal.OrderedExpectationList.CurrentExpectation">
      <summary>
            Gets the current expectation.
            </summary>
      <value>The current expectation.</value>
    </member>
    <member name="P:NMock.Internal.OrderedExpectationList.HasNextExpectation">
      <summary>
            Gets a value indicating whether this instance has next expectation.
            </summary>
      <value>
        <c>true</c> if this instance has next expectation; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:NMock.Internal.OrderedExpectationList.NextExpectation">
      <summary>
            Gets the next expectation.
            </summary>
      <value>The next expectation.</value>
    </member>
    <member name="P:NMock.Internal.OrderedExpectationList.IsActive">
      <summary>
            Gets a value indicating whether this instance is active.
            </summary>
      <value>
        <c>true</c> if this instance is active; otherwise, <c>false</c>.</value>
    </member>
    <member name="F:NMock.Internal.IndexGetterBuilder.builder">
      <summary>
            Holds the instance to the <see cref="T:NMock.Internal.ExpectationBuilder" />.
            </summary>
    </member>
    <member name="M:NMock.Internal.IndexGetterBuilder.#ctor(NMock.Internal.BuildableExpectation,NMock.Internal.ExpectationBuilder)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Internal.IndexGetterBuilder" /> class.
            </summary>
      <param name="expectation">The expectation.</param>
      <param name="builder">The builder.</param>
    </member>
    <member name="T:NMock.Matchers.CallbackListMatcher`1">
      <summary>
            A matcher that stores a list of delegates to call back to later.
            </summary>
      <typeparam name="T">Typically a <see cref="T:System.Action" />, <see cref="T:System.Predicate`1" />, <see cref="T:System.Func`1" />, or their equivalents.</typeparam>
    </member>
    <member name="M:NMock.Matchers.CallbackListMatcher`1.Matches(System.Object)">
      <summary>
            Determines if the parameter is the same type as <typeparamref name="T" />.
            </summary>
      <param name="o">The value the matcher will evaluate.</param>
      <returns>A value indicating if the parameter matches or not.</returns>
    </member>
    <member name="M:NMock.Matchers.CallbackListMatcher`1.DescribeTo(System.IO.TextWriter)">
      <summary>
            Describes this matcher.
            </summary>
      <param name="writer">The text writer to which the description is added.</param>
    </member>
    <member name="P:NMock.Matchers.CallbackListMatcher`1.Callbacks">
      <summary>
            Gets a list of references to the callbacks assigned during the matching operation of the expectation.
            </summary>
    </member>
    <member name="T:NMock.Matchers.ObjectMatcher">
      <summary>
            Matches 2 objects using IComparable
            </summary>
    </member>
    <member name="M:NMock.Matchers.ObjectMatcher.#ctor(System.Object)">
      <summary>
      </summary>
      <param name="o">
      </param>
    </member>
    <member name="M:NMock.Matchers.ObjectMatcher.Matches(System.Object)">
      <summary>
            Compares 2 objects using IComparable
            </summary>
      <param name="o">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NMock.Matchers.ObjectMatcher.DescribeTo(System.IO.TextWriter)">
      <summary>
            Describes this matcher.
            </summary>
      <param name="writer">The text writer to which the description is added.</param>
    </member>
    <member name="T:NMock.Matchers.ArgumentsMatcher">
      <summary>
            Matcher that checks whether parameters of a method match with the specified list of matchers.
            </summary>
    </member>
    <member name="T:NMock.Matchers.ArgumentsMatcher.OutMatcher">
      <summary>
            Matcher that matches method out parameters. 
            </summary>
    </member>
    <member name="M:NMock.Matchers.ArgumentsMatcher.OutMatcher.Matches(System.Object)">
      <summary>
            Matches the specified object to this matcher and returns whether it matches.
            </summary>
      <param name="o">The object to match.</param>
      <returns>Whether the object mached is an out parameter.</returns>
    </member>
    <member name="M:NMock.Matchers.ArgumentsMatcher.OutMatcher.DescribeTo(System.IO.TextWriter)">
      <summary>
            Describes this object.
            </summary>
      <param name="writer">The text writer the description is added to.</param>
    </member>
    <member name="F:NMock.Matchers.ArgumentsMatcher.OutParameter">
      <summary>
            Stores the out parameter.
            </summary>
    </member>
    <member name="F:NMock.Matchers.ArgumentsMatcher.valueMatchers">
      <summary>
            Stores the valuematchers given at initialization.
            </summary>
    </member>
    <member name="M:NMock.Matchers.ArgumentsMatcher.#ctor">
      <summary>
            Creates an instance of the <see cref="T:NMock.Matchers.ArgumentsMatcher" /> class.
            </summary>
    </member>
    <member name="M:NMock.Matchers.ArgumentsMatcher.#ctor(NMock.Matcher[])">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Matchers.ArgumentsMatcher" /> class.
            </summary>
      <param name="valueMatchers">The value matchers. This is an ordered list of matchers, each matching a single method argument.</param>
    </member>
    <member name="M:NMock.Matchers.ArgumentsMatcher.AddMatcher(NMock.Matcher)">
      <summary>
            Adds a matcher to the arguments matcher
            </summary>
      <param name="matcher">
      </param>
    </member>
    <member name="M:NMock.Matchers.ArgumentsMatcher.Matches(System.Object)">
      <summary>
            Matches the specified object to this matcher and returns whether it matches.
            </summary>
      <param name="o">The object to match.</param>
      <returns>Whether the object is an <see cref="T:NMock.Monitoring.Invocation" /> and all method arguments match their corresponding matcher.</returns>
    </member>
    <member name="M:NMock.Matchers.ArgumentsMatcher.DescribeTo(System.IO.TextWriter)">
      <summary>
            Describes this matcher.
            </summary>
      <param name="writer">The text writer to which the description is added.</param>
    </member>
    <member name="M:NMock.Matchers.ArgumentsMatcher.LastMatcher">
      <summary>
            Returns the last argument matcher.
            </summary>
      <returns>Argument matcher</returns>
    </member>
    <member name="M:NMock.Matchers.ArgumentsMatcher.WriteListOfMatchers(System.Int32,System.IO.TextWriter)">
      <summary>
            Writes the list of matchers to a <see cref="T:System.IO.TextWriter" />.
            </summary>
      <param name="listLength">Length of the list.</param>
      <param name="writer">The writer.</param>
    </member>
    <member name="P:NMock.Matchers.ArgumentsMatcher.Count">
      <summary>
            The number of value matchers
            </summary>
    </member>
    <member name="P:NMock.Matchers.ArgumentsMatcher.Item(System.Int32)">
      <summary>
            Gets a value matcher by index
            </summary>
      <param name="index">The index of the item to return</param>
      <returns>A value matcher</returns>
    </member>
    <member name="T:NMock.Syntax.IActionSyntax">
      <summary>
            Syntax for defining actions.
            </summary>
    </member>
    <member name="M:NMock.Syntax.IActionSyntax.Will(NMock.IAction[])">
      <summary>
            Creates the expectation of what to do when this member is called.
            </summary>
      <param name="actions">Common <see cref="T:NMock.IAction" />s can be found in the <see cref="T:NMock.Return" /> and <see cref="T:NMock.Throw" /> classes.</param>
      <returns>Returns the comment syntax defined after will.</returns>
      <remarks>
            For void methods this action does not need to be used.
            For non-void methods this action is typically set to use the <see cref="T:NMock.Return" /> class.
            For all methods this action can be used to throw an exception using the <see cref="T:NMock.Throw" /> class.
            </remarks>
    </member>
    <member name="T:NMock.Syntax.IAutoActionSyntax`1">
      <summary>
            Extends the <see cref="T:NMock.Syntax.IArgumentSyntax" /> interface to include the <see cref="M:NMock.Syntax.IAutoActionSyntax`1.WillReturn(`0)" /> method.
            </summary>
    </member>
    <member name="M:NMock.Syntax.IAutoActionSyntax`1.WillReturn(`0)">
      <summary>
            This is the strongly-typed version of the <see cref="M:NMock.Syntax.IActionSyntax.Will(NMock.IAction[])" /> method.  Use this method when
            the value to return <b>is</b> this value (and not a matcher).
            </summary>
      <param name="actualValue">
      </param>
      <returns>
      </returns>
      <remarks>
            This version of the "Will" methods is used in place of <c>.Will(Return.Value(obj))</c> when <c>obj</c> is known
            and should be checked at compile time.  The benefit is that the method takes a strongly-typed argument.  The 
            drawback is that you can't specify a matcher.
            </remarks>
    </member>
    <member name="T:NMock.Syntax.IAutoArgumentSyntax`1">
      <summary>
            This interface provides the syntax used for "Method" methods on the <see cref="T:NMock.Syntax.IMethodSyntax`1" />
            interface that don't return void and don't use argument values explicitly.
            </summary>
      <typeparam name="TResult">The return type of the method.</typeparam>
      <remarks>
            This interface provides the syntax needed to specify method arguments or match
            method arguments.
            </remarks>
    </member>
    <member name="M:NMock.Syntax.IAutoArgumentSyntax`1.With(System.Object[])">
      <summary>
            Defines the arguments that are expected on the method call.
            </summary>
      <param name="expectedArguments">The expected arguments.</param>
      <returns>Matcher syntax.</returns>
    </member>
    <member name="M:NMock.Syntax.IAutoArgumentSyntax`1.WithNoArguments">
      <summary>
            Defines that no arguments are expected on the method call.
            </summary>
      <returns>Matcher syntax.</returns>
    </member>
    <member name="M:NMock.Syntax.IAutoArgumentSyntax`1.WithAnyArguments">
      <summary>
            Defines that all arguments are allowed on the method call.
            </summary>
      <returns>Matcher syntax.</returns>
    </member>
    <member name="M:NMock.Syntax.IAutoArgumentSyntax`1.WithArguments(NMock.Matcher[])">
      <summary>
            Defines matching criteria for arguments.
            </summary>
      <param name="argumentMatchers">A list of matchers to match the arguments of a method.</param>
      <returns>Action syntax defining the action to take.</returns>
      <remarks>
            The matchers will be automatically wrapped in an ArgumentsMatcher.
            </remarks>
    </member>
    <member name="T:NMock.Monitoring.IInvokable">
      <summary>
            IInvokable objects can be invoked.
            </summary>
    </member>
    <member name="M:NMock.Monitoring.IInvokable.Invoke(NMock.Monitoring.Invocation)">
      <summary>
            Invokes this object.
            </summary>
      <param name="invocation">The invocation.</param>
    </member>
    <member name="T:NMock.IMockObject">
      <summary>
            Interface for mocks.
            </summary>
    </member>
    <member name="M:NMock.IMockObject.GetMethodsMatching(NMock.Matcher)">
      <summary>
            Retrieves all matching methods on this mock. 
            </summary>
      <param name="methodMatcher">A Matcher to use in identifying the methods.</param>
      <returns>A list of zero or more matching MethodInfo instances.</returns>
    </member>
    <member name="M:NMock.IMockObject.AddExpectation(NMock.IExpectation)">
      <summary>
            Adds an expectation to this mock.
            </summary>
      <param name="expectation">The expectation to add.</param>
    </member>
    <member name="M:NMock.IMockObject.RaiseEvent(System.String,System.Object[])">
      <summary>
            Raises an event on this mock.
            </summary>
      <param name="eventName">Name of the event to fire.</param>
      <param name="args">The arguments passed to the event.</param>
    </member>
    <member name="M:NMock.IMockObject.ProcessEventHandlers(NMock.Monitoring.Invocation)">
      <summary>
      </summary>
      <param name="invocation">
      </param>
    </member>
    <member name="P:NMock.IMockObject.MockName">
      <summary>
            Gets the name of the mock instance. This is often used in error messages
            to identify a specific mock instance.
            </summary>
    </member>
    <member name="P:NMock.IMockObject.MockedTypes">
      <summary>
            Gets a <see cref="T:NMock.Proxy.CompositeType" /> that represents all types to be mocked.
            </summary>
    </member>
    <member name="P:NMock.IMockObject.IgnoreUnexpectedInvocations">
      <summary>
            Gets or sets a value indicating if this <see cref="T:NMock.Mock`1" /> should ignore unexpected invocations to properties, methods, or events.
            </summary>
      <remarks>
            Use the property to have a Mock ignore calls with no expectations.  By default, this works fine for property setters, void methods,
            and events.  Property getters and non-void methods will need to indicate how they will be implemented as they <i>need</i> to return
            a value.
            </remarks>
    </member>
    <member name="P:NMock.IMockObject.InterceptedValues">
      <summary>
            A <see cref="T:System.Collections.Generic.Dictionary`2" /> that stores property values from internal operations.
            </summary>
    </member>
    <member name="T:NMock.Internal.MockObject">
      <summary>
      </summary>
    </member>
    <member name="F:NMock.Internal.MockObject.assignedPropertyResults">
      <summary>
            Results that have been explicitly assigned via a call to a property setter.
            These will be returned for all subsequent calls to the matching property getter.
            </summary>
    </member>
    <member name="F:NMock.Internal.MockObject.eventHandlers">
      <summary>
            Stores the event handlers that could be added to the mock object.
            </summary>
    </member>
    <member name="F:NMock.Internal.MockObject.rememberedMethodResults">
      <summary>
            Results that have been generated for methods or property getters.
            These will be returned for all subsequent calls to the same member.
            </summary>
    </member>
    <member name="M:NMock.Internal.MockObject.#ctor(NMock.MockFactory,NMock.Proxy.CompositeType,System.String,NMock.MockStyle)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Internal.MockObject" /> class.
            </summary>
      <param name="mockFactory">The mockFactory.</param>
      <param name="mockedType">Type of the mocked.</param>
      <param name="name">The name.</param>
      <param name="mockStyle">The mock style.</param>
    </member>
    <member name="M:NMock.Internal.MockObject.GetStubResult(NMock.Monitoring.Invocation)">
      <summary>
            Gets the default result for an invocation.
            </summary>
      <param name="invocation">The invocation.</param>
      <returns>The default value to return as result of the invocation. 
            <see cref="F:System.Reflection.Missing.Value" /> if no default value was provided.</returns>
    </member>
    <member name="M:NMock.Internal.MockObject.GetMemberName(NMock.ISelfDescribing)">
      <summary>
            Gets the name of the member to be used as the name for a mock returned an a call to a stub.
            </summary>
      <param name="invocation">The invocation.</param>
      <returns>Name of the mock created as a result value on a call to a stub.</returns>
    </member>
    <member name="P:NMock.Internal.MockObject.MockStyle">
      <summary>
            Gets the mock style of this mock.
            </summary>
    </member>
    <member name="T:NMock.Syntax.IMatchSyntax">
      <summary>
            Syntax defining matching criterias.
            </summary>
    </member>
    <member name="M:NMock.Syntax.IMatchSyntax.Matching(NMock.Matcher)">
      <summary>
            Defines a matching criteria.
            </summary>
      <param name="matcher">The matcher.</param>
      <returns>Action syntax defining the action to take.</returns>
    </member>
    <member name="T:NMock.Proxy.IMockObjectFactory">
      <summary>
            Implementations of this interface are responsible for generating runtime
            proxies of classes and interfaces for use as mock objects.
            </summary>
      <remarks>
            Returned instances are expected to implement IMockObject and take care of
            intercepting calls to their public members. Intercepted calls should be
            forwarded on to the supplied MockFactory for processing against expectations.
            </remarks>
    </member>
    <member name="M:NMock.Proxy.IMockObjectFactory.CreateMock(NMock.MockFactory,NMock.Proxy.CompositeType,System.String,NMock.MockStyle,System.Object[])">
      <summary>
            Creates a mock of the specified type(s).
            </summary>
      <param name="mockFactory">The mockFactory used to create this mock instance.</param>
      <param name="typesToMock">The type(s) to include in the mock.</param>
      <param name="name">The name to use for the mock instance.</param>
      <param name="mockStyle">The behaviour of the mock instance when first created.</param>
      <param name="constructorArgs">Constructor arguments for the class to be mocked. Only valid if mocking a class type.</param>
      <returns>A mock instance of the specified type(s).</returns>
    </member>
    <member name="T:NMock.Proxy.MockObjectFactoryBase">
      <summary>
            A base implementation of the <see cref="T:NMock.Proxy.IMockObjectFactory" /> interface
            </summary>
    </member>
    <member name="M:NMock.Proxy.MockObjectFactoryBase.BuildAdditionalTypeArrayForProxyType(NMock.Proxy.CompositeType)">
      <summary>
            Combines the specified types with the <see cref="T:NMock.IMockObject" /> into an array.
            </summary>
      <returns>An array of the specified types and <see cref="T:NMock.IMockObject" />,</returns>
    </member>
    <member name="M:NMock.Proxy.MockObjectFactoryBase.CreateMock(NMock.MockFactory,NMock.Proxy.CompositeType,System.String,NMock.MockStyle,System.Object[])">
      <summary>
            Creates a mock of the specified type(s).
            </summary>
      <param name="mockFactory">The mockFactory used to create this mock instance.</param>
      <param name="typesToMock">The type(s) to include in the mock.</param>
      <param name="name">The name to use for the mock instance.</param>
      <param name="mockStyle">The behaviour of the mock instance when first created.</param>
      <param name="constructorArgs">Constructor arguments for the class to be mocked. Only valid if mocking a class type.</param>
      <returns>A mock instance of the specified type(s).</returns>
    </member>
    <member name="T:NMock.Proxy.LinFu.LinFuMockObjectFactory">
      <summary>
            A factory based on LinFu that creates proxy objects
            </summary>
    </member>
    <member name="M:NMock.Proxy.LinFu.LinFuMockObjectFactory.CreateMock(NMock.MockFactory,NMock.Proxy.CompositeType,System.String,NMock.MockStyle,System.Object[])">
      <summary>
            Creates a mock of the specified type(s).
            </summary>
      <param name="mockFactory">The mockFactory used to create this mock instance.</param>
      <param name="typesToMock">The type(s) to include in the mock.</param>
      <param name="name">The name to use for the mock instance.</param>
      <param name="mockStyle">The behaviour of the mock instance when first created.</param>
      <param name="constructorArgs">Constructor arguments for the class to be mocked. Only valid if mocking a class type.</param>
      <returns>A mock instance of the specified type(s).</returns>
    </member>
    <member name="T:NMock.DelegateInvoker">
      <summary>
      </summary>
    </member>
    <member name="M:NMock.DelegateInvoker.Invoke(System.Object[])">
      <summary>
            Invokes the delegate with the specified parameters.
            </summary>
      <exception cref="T:System.InvalidOperationException" />
    </member>
    <member name="T:NMock.Actions.SetNamedParameterAction">
      <summary>
            Action that sets the parameter of the invocation with the specified name to the specified value.
            </summary>
    </member>
    <member name="F:NMock.Actions.SetNamedParameterAction.name">
      <summary>
            Stores the name of the parameter when the class gets initialized.
            </summary>
    </member>
    <member name="F:NMock.Actions.SetNamedParameterAction.value">
      <summary>
            Stores the value of the parameter when the class gets initialized.
            </summary>
    </member>
    <member name="M:NMock.Actions.SetNamedParameterAction.#ctor(System.String,System.Object)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Actions.SetNamedParameterAction" /> class.
            </summary>
      <param name="name">The name of the parameter to set.</param>
      <param name="value">The value.</param>
    </member>
    <member name="T:NMock.Actions.SetIndexedParameterAction">
      <summary>
            Action that sets a parameter (method argument) of the invocation to the specified value.
            </summary>
    </member>
    <member name="F:NMock.Actions.SetIndexedParameterAction.index">
      <summary>
            Stores the index of the paremter to set.
            </summary>
    </member>
    <member name="F:NMock.Actions.SetIndexedParameterAction.value">
      <summary>
            Stores the value of the parameter to set.
            </summary>
    </member>
    <member name="M:NMock.Actions.SetIndexedParameterAction.#ctor(System.Int32,System.Object)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Actions.SetIndexedParameterAction" /> class.
            </summary>
      <param name="index">The index of the parameter to set.</param>
      <param name="value">The value.</param>
    </member>
    <member name="T:NMock.Actions.IReturnAction">
      <summary>
            Represents an <see cref="T:NMock.IAction" /> that returns a result.
            </summary>
    </member>
    <member name="P:NMock.Actions.IReturnAction.ReturnType">
      <summary>
            The return type of this <see cref="T:NMock.IAction" /></summary>
    </member>
    <member name="T:NMock.Actions.ReturnCloneAction">
      <summary>
            Action that set the result value of an invocation to a clone of the specified prototype.
            </summary>
    </member>
    <member name="F:NMock.Actions.ReturnCloneAction.prototype">
      <summary>
            Stores the prototype that will be cloned.
            </summary>
    </member>
    <member name="M:NMock.Actions.ReturnCloneAction.#ctor(System.ICloneable)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Actions.ReturnCloneAction" /> class.
            </summary>
      <param name="prototype">The prototype.</param>
    </member>
    <member name="T:NMock.Actions.LazyReturnAction">
      <summary>
            Action that sets the result value on an invocation. The value is aquired by calling the delegate specified in the constructor.
            </summary>
    </member>
    <member name="T:NMock.Actions.LazyReturnAction.Evaluate">
      <summary>
            Delegate that is used to get the return value.
            </summary>
      <returns>
            Returns an object...
            </returns>
    </member>
    <member name="F:NMock.Actions.LazyReturnAction.evaluate">
      <summary>
            Stores the evaluate delegate for this action.
            </summary>
    </member>
    <member name="M:NMock.Actions.LazyReturnAction.#ctor(NMock.Actions.LazyReturnAction.Evaluate)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Actions.LazyReturnAction" /> class.
            </summary>
      <param name="evaluate">The delegate used to aquire the return value.</param>
    </member>
    <member name="T:NMock.Stub`1">
      <summary>
            This class represents a stub.
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="P:NMock.Stub`1.Out">
      <summary>
            A syntax property used to stub out data for this instance.
            </summary>
    </member>
    <member name="T:NMock.Matchers.StringContainsMatcher">
      <summary>
            Matcher that checks whether the actual value contains the expected substring.
            </summary>
    </member>
    <member name="M:NMock.Matchers.StringContainsMatcher.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Matchers.StringContainsMatcher" /> class.
            </summary>
      <param name="substring">The substring that is expected.</param>
    </member>
    <member name="M:NMock.Matchers.StringContainsMatcher.Matches(System.Object)">
      <summary>
            Matches the specified object to this matcher and returns whether it matches.
            </summary>
      <param name="o">The object to match.</param>
      <returns>Whether the object is a string and contains the expected substring.</returns>
    </member>
    <member name="M:NMock.Matchers.StringContainsMatcher.DescribeTo(System.IO.TextWriter)">
      <summary>
            Describes this matcher.
            </summary>
      <param name="writer">The text writer to which the description is added.</param>
    </member>
    <member name="T:NMock.Matchers.EqualMatcher">
      <summary>
            Matcher that checks whether the expected and actual value are equal.
            </summary>
    </member>
    <member name="M:NMock.Matchers.EqualMatcher.#ctor(System.Object)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Matchers.EqualMatcher" /> class.
            </summary>
      <param name="expected">The expected value.</param>
    </member>
    <member name="M:NMock.Matchers.EqualMatcher.Matches(System.Object)">
      <summary>
            Matcheses the specified actual.
            </summary>
      <param name="actual">The actual value.</param>
      <returns>Whether the expected value is equal to the actual value.</returns>
    </member>
    <member name="M:NMock.Matchers.EqualMatcher.DescribeTo(System.IO.TextWriter)">
      <summary>
            Describes this matcher.
            </summary>
      <param name="writer">The text writer to which the description is added.</param>
    </member>
    <member name="T:NMock.Syntax.IMethodSyntax">
      <summary>
            Syntax defining a method, property or event (de)registration.
            </summary>
    </member>
    <member name="M:NMock.Syntax.IMethodSyntax.ProtectedMethod(System.String)">
      <summary>
            Sets up an expectation that a protected method will be called.
            </summary>
      <param name="name">The name of the method.</param>
      <returns>
            Argument syntax defining the arguments of the method.
            </returns>
    </member>
    <member name="T:NMock.Matchers.CountMatcher`1">
      <summary>
      </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="M:NMock.Matchers.CountMatcher`1.#ctor(System.Int32)">
      <summary>
      </summary>
      <param name="expectedCount">
      </param>
    </member>
    <member name="T:NMock.Actions.QueueAction`1">
      <summary>
            Action that returns an item from the queue 
            </summary>
    </member>
    <member name="M:NMock.Actions.QueueAction`1.#ctor(System.Collections.Generic.Queue{`0})">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Actions.QueueAction`1" /> class with the queue of values.
            </summary>
      <param name="queue">
      </param>
    </member>
    <member name="T:NMock.Actions.DelegateReturnAction`1">
      <summary>
            Represents an <see cref="T:NMock.Actions.IReturnAction" /> that can call a delegate to provide the return value.
            </summary>
      <typeparam name="T">The type to return.</typeparam>
    </member>
    <member name="M:NMock.Actions.DelegateReturnAction`1.#ctor(System.Func{`0})">
      <summary>
            Creates an instance of this class with a <see cref="T:System.Func`1" /> to call during invocation.
            </summary>
      <param name="func">The <see cref="T:System.Func`1" /> to invoke.</param>
    </member>
    <member name="M:NMock.Actions.DelegateReturnAction`1.#ctor(System.Func{NMock.Monitoring.Invocation,`0})">
      <summary>
            Creates an instance of this class with a <see cref="T:System.Func`1" /> to call during invocation.
            </summary>
      <param name="func">The <see cref="T:System.Func`1" /> to invoke.</param>
    </member>
    <member name="T:NMock.Matchers.NullMatcher">
      <summary>
            Matcher that checks whether to actual value is equal to null.
            </summary>
    </member>
    <member name="M:NMock.Matchers.NullMatcher.#ctor">
      <summary>
            Initializes an instance of the <see cref="T:NMock.Matchers.NullMatcher" /> class with a description of null.
            </summary>
    </member>
    <member name="M:NMock.Matchers.NullMatcher.Matches(System.Object)">
      <summary>
            Matches the specified object to this matcher and returns whether it matches.
            </summary>
      <param name="o">The object to match.</param>
      <returns>Whether the object is equal to null.</returns>
    </member>
    <member name="T:NMock.Internal.DescriptionWriter">
      <summary>
            Used to describe Matchers and other classes for exception handling.
            </summary>
    </member>
    <member name="M:NMock.Internal.DescriptionWriter.Write(System.Object)">
      <summary>
            Writes the text representation of an object to the text stream by calling ToString on that object.
            </summary>
      <param name="value">The object to write.</param>
      <exception cref="T:System.ObjectDisposedException">
            The <see cref="T:System.IO.TextWriter" /> is closed.
            </exception>
      <exception cref="T:System.IO.IOException">
            An I/O error occurs.
            </exception>
    </member>
    <member name="M:NMock.Internal.DescriptionWriter.FormatValue(System.Object)">
      <summary>
            Formats the given <paramref name="value" /> depending on null and the type of the value.
            </summary>
      <param name="value">The value to format.</param>
      <returns>Returns the formatted string.</returns>
    </member>
    <member name="M:NMock.Internal.DescriptionWriter.FormatString(System.String)">
      <summary>
            Replaces backslashes with three escaped backslashes.
            </summary>
      <param name="s">The string to replace backslashes.</param>
      <returns>Returns the escaped string.</returns>
    </member>
    <member name="T:NMock.Proxy.InterfaceMockBase">
      <summary>
            Used as a base for interface mocks in order to provide a holder
            for a meaningful ToString() value.
            </summary>
    </member>
    <member name="M:NMock.Proxy.InterfaceMockBase.#ctor">
      <summary>
            Default constructor used by Castle.DynamicProxy.
            </summary>
      <remarks>Do not remove.  This is needed by Castle.</remarks>
    </member>
    <member name="M:NMock.Proxy.InterfaceMockBase.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Proxy.InterfaceMockBase" /> class.
            </summary>
      <param name="name">The name of this instance.</param>
    </member>
    <member name="M:NMock.Proxy.InterfaceMockBase.ToString">
      <summary>
            Returns the name of this instance.
            </summary>
      <returns>The name of this instance.</returns>
    </member>
    <member name="M:NMock.Proxy.InterfaceMockBase.Equals(System.Object)">
      <summary>
            Determines whether the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />.
            </summary>
      <param name="obj">The <see cref="T:System.Object" /> to compare with the current <see cref="T:System.Object" />.</param>
      <returns>true if the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />; otherwise, false.</returns>
    </member>
    <member name="M:NMock.Proxy.InterfaceMockBase.GetHashCode">
      <summary>
            Serves as a hash function for a particular type.
            </summary>
      <returns>A hash code for the current System.Object.</returns>
    </member>
    <member name="T:NMock.Actions.FireAction">
      <summary>
            Action that fires an event.
            </summary>
    </member>
    <member name="F:NMock.Actions.FireAction.eventArgs">
      <summary>
            Stores the event arguments.
            </summary>
    </member>
    <member name="F:NMock.Actions.FireAction.eventName">
      <summary>
            Stores the name of the event to fire.
            </summary>
    </member>
    <member name="M:NMock.Actions.FireAction.#ctor(System.String,System.Object[])">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Actions.FireAction" /> class.
            </summary>
      <param name="eventName">Name of the event.</param>
      <param name="eventArgs">The event args.</param>
    </member>
    <member name="T:NMock.MockStyle">
      <summary>
            Specifies how a mock object should behave when it is first created.
            </summary>
    </member>
    <member name="F:NMock.MockStyle.Default">
      <summary>
            Calls to members that do not have expectations set will
            result in ExpectationExceptions.
            </summary>
    </member>
    <member name="F:NMock.MockStyle.Transparent">
      <summary>
            Calls to members that do not have expectations set will
            pass through to the underlying implementation on the class
            being mocked.
            </summary>
    </member>
    <member name="F:NMock.MockStyle.Stub">
      <summary>
            Calls to members that do not have expectations set will
            be ignored. Default values are used for return values 
            (default value of the return type, stub or empty enumerable)
            and the same value is returned on every call to the same member.
            </summary>
    </member>
    <member name="F:NMock.MockStyle.RecursiveStub">
      <summary>
            Calls to members that do not have expectations set will
            be ignored. Default values are used for return values 
            (default value of the return type, stub or empty enumerable)
            and the same value is returned on every call to the same member.
            </summary>
    </member>
    <member name="T:NMock.Matchers.TypeMatcher">
      <summary>
            Matcher that checks whether the actual object can be assigned to the expected type.
            </summary>
    </member>
    <member name="M:NMock.Matchers.TypeMatcher.#ctor(System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Matchers.TypeMatcher" /> class.
            </summary>
      <param name="type">The expected type.</param>
    </member>
    <member name="M:NMock.Matchers.TypeMatcher.Matches(System.Object)">
      <summary>
            Matches the specified object to this matcher and returns whether it matches.
            </summary>
      <param name="o">The object to match.</param>
      <returns>Whether the object castable to the expected type.</returns>
    </member>
    <member name="M:NMock.Matchers.TypeMatcher.DescribeTo(System.IO.TextWriter)">
      <summary>
            Describes this matcher.
            </summary>
      <param name="writer">The text writer to which the description is added.</param>
    </member>
    <member name="T:NMock.Matchers.IndexGetterArgumentsMatcher">
      <summary>
            Matcher for indexer getters. Checks that the arguments passed to the indexer match.
            </summary>
    </member>
    <member name="M:NMock.Matchers.IndexGetterArgumentsMatcher.#ctor(NMock.Matcher[])">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Matchers.IndexGetterArgumentsMatcher" /> class.
            </summary>
      <param name="valueMatchers">The value matchers. This is an ordered list of matchers, each matching a single method argument.</param>
    </member>
    <member name="M:NMock.Matchers.IndexGetterArgumentsMatcher.DescribeTo(System.IO.TextWriter)">
      <summary>
            Describes this matcher.
            </summary>
      <param name="writer">The text writer to which the description is added.</param>
    </member>
    <member name="T:NMock.Syntax.IAutoPropertyActionSyntax`1">
      <summary>
            This interface adds a special method for property expectations.
            </summary>
      <typeparam name="TResult">
      </typeparam>
    </member>
    <member name="M:NMock.Syntax.IAutoPropertyActionSyntax`1.WillReturnSetterValue">
      <summary>
            Sets up an expectation that calls an action to return the value of the property
            that was previously set in code or prior expectation.
            </summary>
      <returns>
      </returns>
      <remarks>
            It is useful in cases where a value is assigned to a property internally in a method
            and only a <see cref="T:NMock.Matchers.TypeMatcher" /> could be used to match the assignment.  This method
            is called on a getter expectation to get that underlying value.
            </remarks>
    </member>
    <member name="T:NMock.Expect">
      <summary>
            Used to set up expectations on types that are not mocks.
            </summary>
    </member>
    <member name="M:NMock.Expect.That(System.Action)">
      <summary>
            Creates an expectation related to the type of <see cref="T:System.Exception" /> thrown.
            </summary>
      <param name="action">The method that should cause the exception.  Hint: use () =&gt; to convert a method to an action.</param>
      <returns>An object to complete the expectation</returns>
      <remarks>Use this in place of a [ExpectedException] unit test attribute.</remarks>
    </member>
    <member name="M:NMock.Expect.On``1(``0)">
      <summary>
            Default expectation, specifies that a method, property, etc. that has to be called at least once.
            </summary>
      <param name="receiver">The receiver.</param>
      <returns>Returns a receiver of a method, property, etc. that has to be called at least once.</returns>
    </member>
    <member name="T:NMock.Actions.InvokeAction">
      <summary>
            An <see cref="T:NMock.IAction" /> that can invoke an <see cref="T:System.Action" /> when the expectation is met.
            </summary>
    </member>
    <member name="M:NMock.Actions.InvokeAction.#ctor(System.Action)">
      <summary>
            Creates an <see cref="T:NMock.IAction" /> that will invoke the <paramref name="action" />.
            </summary>
      <param name="action">The action to invoke.</param>
    </member>
    <member name="T:NMock.Syntax.Invoke">
      <summary>
            A syntax class to create an <see cref="T:NMock.Actions.InvokeAction" /> in a easy to read way.
            </summary>
    </member>
    <member name="M:NMock.Syntax.Invoke.Action(System.Action)">
      <summary>
            A syntax method to create an <see cref="T:NMock.Actions.InvokeAction" /> class.
            </summary>
      <param name="action">The <see cref="M:NMock.Syntax.Invoke.Action(System.Action)" /> to invoke when the <see cref="T:NMock.IAction" /> in invoked.</param>
      <returns>An instance of an <see cref="T:NMock.Actions.InvokeAction" />class.</returns>
    </member>
    <member name="T:NMock.Has">
      <summary>
            Provides shortcuts to matchers.
            </summary>
    </member>
    <member name="M:NMock.Has.ToString(NMock.Matcher)">
      <summary>
            Returns a matcher for testing string representation of objects.
            </summary>
      <param name="matcher">The wrapped matcher.</param>
      <returns>Returns a <see cref="T:NMock.Matchers.ToStringMatcher" /> for testing string representation of objects.</returns>
    </member>
    <member name="M:NMock.Has.Property(System.String,NMock.Matcher)">
      <summary>
            Returns a matcher for checking property values.
            </summary>
      <param name="propertyName">Name of the property.</param>
      <param name="valueMatcher">The value matcher.</param>
      <returns>Returns a <see cref="T:NMock.Matchers.PropertyMatcher" /> for checking property values.</returns>
    </member>
    <member name="M:NMock.Has.Field(System.String,NMock.Matcher)">
      <summary>
            Returns a matcher for checking field values.
            </summary>
      <param name="fieldName">Name of the field.</param>
      <param name="valueMatcher">The value matcher.</param>
      <returns>Returns a <see cref="T:NMock.Matchers.FieldMatcher" /> for checking field values.</returns>
    </member>
    <member name="T:NMock.Matchers.ToStringMatcher">
      <summary>
            Matcher that checks whether the actual value in string representation (actual.ToString())
            matches with the wrapped matcher.
            </summary>
    </member>
    <member name="F:NMock.Matchers.ToStringMatcher.matcher">
      <summary>
            Holds the wrapped matcher.
            </summary>
    </member>
    <member name="M:NMock.Matchers.ToStringMatcher.#ctor(NMock.Matcher)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Matchers.ToStringMatcher" /> class.
            </summary>
      <param name="matcher">The wrapped matcher.</param>
    </member>
    <member name="M:NMock.Matchers.ToStringMatcher.Matches(System.Object)">
      <summary>
            Matches the specified object to this matcher and returns whether it matches.
            </summary>
      <param name="o">The object to match.</param>
      <returns>Whether the object in string representation (o.ToString()) matches the wrapped matcher.</returns>
    </member>
    <member name="M:NMock.Matchers.ToStringMatcher.DescribeTo(System.IO.TextWriter)">
      <summary>
            Describes this matcher.
            </summary>
      <param name="writer">The text writer to which the description is added.</param>
    </member>
    <member name="T:NMock.Matchers.GenericMatcher`1">
      <summary>
            Matcher that checks whether a value matches the check provided as a delegate.
            the expectation.
            </summary>
      <typeparam name="T">The type of the expected value.</typeparam>
    </member>
    <member name="T:NMock.Matchers.GenericMatcher`1.MatchExpression">
      <summary>
            The test that is performed to check if the <paramref name="value" /> matches the expectation.
            </summary>
      <param name="value">The actually received value.</param>
      <returns>True then value matches the expectation.</returns>
    </member>
    <member name="F:NMock.Matchers.GenericMatcher`1.matchExpression">
      <summary>
            The test that is performed to see if the value matches the expectation.
            </summary>
    </member>
    <member name="M:NMock.Matchers.GenericMatcher`1.#ctor(NMock.Matchers.GenericMatcher{`0}.MatchExpression)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Matchers.GenericMatcher`1" /> class.
            </summary>
      <param name="matchExpression">The test that is performed to check if the value matches expectation.</param>
      <exception cref="T:System.ArgumentNullException">
        <c>matchExpression</c> is null.</exception>
    </member>
    <member name="M:NMock.Matchers.GenericMatcher`1.Matches(System.Object)">
      <summary>
            Matches the specified object to this matcher and returns whether it matches.
            </summary>
      <param name="o">The object to match.</param>
      <returns>Whether the object matches.</returns>
    </member>
    <member name="T:NMock.Syntax.IAutoMatchSyntax`1">
      <summary>
            This interface ties together the <see cref="T:NMock.Syntax.IMatchSyntax" /> and <see cref="T:NMock.Syntax.IAutoActionSyntax`1" />
            interfaces to provide syntax on <see cref="M:NMock.Syntax.IStubSyntax`1.GetProperty``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})" />.
            </summary>
      <typeparam name="TProperty">The property type of the lambda expression.</typeparam>
      <remarks>
            This interface doesn't provide any new members.  It is used to tie together two existing
            interfaces so that the <see cref="M:NMock.Syntax.IStubSyntax`1.GetProperty``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})" />
            method will return the right syntax.
            </remarks>
    </member>
    <member name="T:NMock.Matchers.PredicateMatcher`1">
      <summary>
            A matcher that uses lambda expressions to perform matching
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="M:NMock.Matchers.PredicateMatcher`1.#ctor(System.Predicate{`0})">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Matchers.PredicateMatcher`1" /> class with the supplied predicate.
            </summary>
      <param name="matcher">A lambda expression that evaluates to true or false</param>
    </member>
    <member name="M:NMock.Matchers.PredicateMatcher`1.#ctor(System.Predicate{`0},System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Matchers.PredicateMatcher`1" /> class with the supplied predicate.
            </summary>
      <param name="matcher">A lambda expression that evaluates to true or false</param>
      <param name="description">A message to describe the expectation.</param>
    </member>
    <member name="M:NMock.Matchers.PredicateMatcher`1.Matches(System.Object)">
      <summary>
            Matches the specified object to this matcher and returns whether it matches.
            </summary>
      <param name="o">The object to match.</param>
      <returns>Whether the object matches.</returns>
    </member>
    <member name="T:NMock.Monitoring.ParameterList">
      <summary>
            Manages a list of parameters for a mocked method together with the parameter's values.
            </summary>
    </member>
    <member name="F:NMock.Monitoring.ParameterList.isValueSet">
      <summary>
            Holds a boolean for each value if it was set or not.
            </summary>
    </member>
    <member name="F:NMock.Monitoring.ParameterList.method">
      <summary>
            Holds the method to be mocked.
            </summary>
    </member>
    <member name="F:NMock.Monitoring.ParameterList.values">
      <summary>
            An array holding the values of the parameters.
            </summary>
    </member>
    <member name="M:NMock.Monitoring.ParameterList.#ctor(System.Reflection.MethodBase,System.Object[])">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Monitoring.ParameterList" /> class.
            </summary>
      <param name="method">The method to be mocked.</param>
      <param name="values">The values of the parameters.</param>
    </member>
    <member name="M:NMock.Monitoring.ParameterList.IsValueSet(System.Int32)">
      <summary>
            Determines whether the value specified by index was set.
            </summary>
      <param name="index">The index.</param>
      <returns>
            Returns <c>true</c> if value specified by index was set; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:NMock.Monitoring.ParameterList.MarkAllValuesAsSet">
      <summary>
            Marks all values as set.
            </summary>
    </member>
    <member name="M:NMock.Monitoring.ParameterList.CanValueBeSet(System.Int32)">
      <summary>
            Determines whether the parameter specified by index can be set.
            </summary>
      <param name="index">The index of the parameter.</param>
      <returns>
            Returns <c>true</c> if the parameter specified by index can be set; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:NMock.Monitoring.ParameterList.GetParameterName(System.Int32)">
      <summary>
            Gets the parameter name by index.
            </summary>
      <param name="index">The index of the parameter name to get.</param>
      <returns>
            Returns the parameter name with the given index.
            </returns>
    </member>
    <member name="P:NMock.Monitoring.ParameterList.Count">
      <summary>
            Gets the number of values.
            </summary>
      <value>The number of values.</value>
    </member>
    <member name="P:NMock.Monitoring.ParameterList.AsArray">
      <summary>
            Gets the values as array.
            </summary>
      <value>Values as array.</value>
    </member>
    <member name="P:NMock.Monitoring.ParameterList.Item(System.Int32)">
      <summary>
            Gets or sets the <see cref="T:System.Object" /> with the specified index.
            </summary>
      <param name="index">The index of the value to be get or set.</param>
      <value>
            The value of a parameter specified by its <paramref name="index" />.
            </value>
    </member>
    <member name="M:NMock.Internal.UnorderedExpectationList.#ctor(NMock.IExpectationList)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Internal.UnorderedExpectationList" /> class.
            </summary>
      <param name="parent">The parent <see cref="T:NMock.IExpectationList" /> of this instance.</param>
    </member>
    <member name="M:NMock.Internal.UnorderedExpectationList.Matches(NMock.Monitoring.Invocation)">
      <summary>
            Checks whether stored expectations matches the specified invocation.
            </summary>
      <param name="invocation">The invocation to check.</param>
      <returns>Returns whether one of the stored expectations has met the specified invocation.</returns>
    </member>
    <member name="M:NMock.Internal.UnorderedExpectationList.Perform(NMock.Monitoring.Invocation)">
      <summary>
            Performs the specified invocation on the corresponding expectation if a match was found.
            </summary>
      <param name="invocation">The invocation to match.</param>
    </member>
    <member name="P:NMock.Internal.UnorderedExpectationList.IsActive">
      <summary>
            Gets a value indicating whether this instance is active.
            </summary>
      <value>
        <c>true</c> if this instance is active; otherwise, <c>false</c>.</value>
    </member>
    <member name="M:NMock.Internal.BuildableExpectation.#ctor(System.String,NMock.Matcher,NMock.Matcher)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Internal.BuildableExpectation" /> class.
            </summary>
      <param name="expectationDescription">The expectation description.</param>
      <param name="requiredCountMatcher">The required count matcher.</param>
      <param name="matchingCountMatcher">The matching count matcher.</param>
    </member>
    <member name="M:NMock.Internal.BuildableExpectation.Matches(NMock.Monitoring.Invocation)">
      <summary>
            Checks whether stored expectations matches the specified invocation.
            </summary>
      <param name="invocation">The invocation to check.</param>
      <returns>Returns whether one of the stored expectations has met the specified invocation.</returns>
    </member>
    <member name="M:NMock.Internal.BuildableExpectation.QueryExpectationsBelongingTo(NMock.IMockObject,System.Collections.Generic.IList{NMock.IExpectation})">
      <summary>
            Adds itself to the <paramref name="result" /> if the <see cref="P:NMock.Internal.BuildableExpectation.Receiver" /> matches
            the specified <paramref name="mock" />.
            </summary>
      <param name="mock">The mock for which expectations are queried.</param>
      <param name="result">The result to add matching expectations to.</param>
    </member>
    <member name="M:NMock.Internal.BuildableExpectation.ValidationErrors">
      <summary>
            Returns a list of validation errors
            </summary>
      <returns>
      </returns>
    </member>
    <member name="T:NMock.Proxy.CompositeType">
      <summary>
            Represents one or more types that are to be mocked. Provides operations
            that work over top of all the contained types, as well as a means of
            grouping and identifying unique combinations of types.
            </summary>
      <remarks>Duplicate types are ignored when added. Only interface and class types are
            supported, and there may only be a maximum of one class type per CompositeType instance.</remarks>
    </member>
    <member name="M:NMock.Proxy.CompositeType.#ctor(System.Type[])">
      <summary>
            Initializes a new instance of the CompositeType class from the supplied types.
            </summary>
      <param name="types">The types to include in the CompositeType.</param>
    </member>
    <member name="M:NMock.Proxy.CompositeType.#ctor(System.Type,System.Type[])">
      <summary>
            Initializes a new instance of the CompositeType class from the supplied types.
            </summary>
      <param name="type">The first type to include in the CompositeType. This cannot be null.</param>
      <param name="additionalTypesToMock">Zero or more further types to include in the CompositeType.</param>
      <remarks>This constructor is mostly included for convenience.</remarks>
    </member>
    <member name="M:NMock.Proxy.CompositeType.Add(System.Type)">
      <summary>
            Adds a <see cref="T:System.Type" /> to this instance
            </summary>
      <param name="type">
      </param>
    </member>
    <member name="M:NMock.Proxy.CompositeType.Equals(NMock.Proxy.CompositeType)">
      <summary>
            Determines whether the specified CompositeType is equal to the current CompositeType.
            </summary>
      <param name="other">The CompositeType to compare with the current CompositeType.</param>
      <returns>true if the specified CompositeType is equal to the current CompositeType; otherwise, false.</returns>
    </member>
    <member name="M:NMock.Proxy.CompositeType.GetMatchingMethods(NMock.Matcher,System.Boolean)">
      <summary>
            Gets any methods of the contained type(s) that match the specified matcher.
            </summary>
      <param name="matcher">The matcher.</param>
      <param name="firstMatchOnly">if set to <c>true</c> then only the first match is returned.</param>
      <returns>The methods of the contained type(s) that match the specified matcher.</returns>
      <remarks>Only non-private methods can be matched.</remarks>
    </member>
    <member name="M:NMock.Proxy.CompositeType.GetHashCode">
      <summary>
            Returns the hash code for this instance.
            </summary>
      <returns>An Int32 containing the hash code for this instance.</returns>
    </member>
    <member name="M:NMock.Proxy.CompositeType.Equals(System.Object)">
      <summary>
            Determines whether the specified Object is equal to the current CompositeType.
            </summary>
      <param name="obj">The Object to compare with the current CompositeType.</param>
      <returns>true if the specified Object is equal to the current CompositeType; otherwise, false.</returns>
    </member>
    <member name="M:NMock.Proxy.CompositeType.ToString">
      <summary>
            Returns a String that represents the current CompositeType.
            </summary>
      <returns>A String that represents the current CompositeType.</returns>
    </member>
    <member name="M:NMock.Proxy.CompositeType.Initialize(System.Type[])">
      <summary>
            Initializes the specified types.
            </summary>
      <param name="types">The types.</param>
    </member>
    <member name="M:NMock.Proxy.CompositeType.GetInterfacesImplementedByType(System.Type)">
      <summary>
            Gets the interfaces implemented by the specified type.
            </summary>
      <param name="type">The interface type to inspect.</param>
      <returns>The interfaces implemented by the specified type.</returns>
    </member>
    <member name="M:NMock.Proxy.CompositeType.IsMethodVisible(System.Reflection.MethodInfo)">
      <summary>
            Filters out private methods.
            </summary>
      <param name="methodInfo">The method to test for visibility.</param>
      <returns>True if the method is not private, otherwise false.</returns>
    </member>
    <member name="P:NMock.Proxy.CompositeType.PrimaryType">
      <summary>
            Gets the 'primary' type we are mocking. This may be a class or an interface
            and will determine the proxy generation method that will be used.
            </summary>
    </member>
    <member name="P:NMock.Proxy.CompositeType.AdditionalInterfaceTypes">
      <summary>
            Gets any additional types to be mocked. These will always be interfaces.
            </summary>
    </member>
    <member name="P:NMock.Proxy.CompositeType.All">
      <summary>
            Gets all types of this instance.
            </summary>
    </member>
    <member name="M:NMock.Proxy.Castle.MockObjectInterceptor.#ctor(NMock.MockFactory,NMock.Proxy.CompositeType,System.String,NMock.MockStyle)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Proxy.Castle.MockObjectInterceptor" /> class.
            </summary>
      <param name="mockFactory">The mockFactory.</param>
      <param name="mockedType">Type of the mocked.</param>
      <param name="name">The name.</param>
      <param name="mockStyle">The mock style.</param>
    </member>
    <member name="T:NMock.Matchers.MethodNameMatcher">
      <summary>
            Matcher that checks whether the actual object is a <see cref="T:System.Reflection.MethodInfo" /> and its name is equal to the expected name.
            </summary>
    </member>
    <member name="M:NMock.Matchers.MethodNameMatcher.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Matchers.MethodNameMatcher" /> class.
            </summary>
      <param name="methodName">The expected name of the method.</param>
    </member>
    <member name="M:NMock.Matchers.MethodNameMatcher.#ctor(System.String,System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Matchers.MethodNameMatcher" /> class with a method name and declaring type
            </summary>
      <param name="methodName">
      </param>
      <param name="declaringType">
      </param>
    </member>
    <member name="M:NMock.Matchers.MethodNameMatcher.Matches(System.Object)">
      <summary>
            Matches the specified object to this matcher and returns whether it matches.
            </summary>
      <param name="o">The MethodInfo to match.</param>
      <returns>Whether the object is a MethodInfo and its name matches the expected one.</returns>
    </member>
    <member name="T:NMock.Matchers.MethodMatcher">
      <summary>
            Matcher that checks whether the actual object is a <see cref="T:System.Reflection.MethodInfo" /> and its signature matches the expected signature.
            </summary>
    </member>
    <member name="M:NMock.Matchers.MethodMatcher.#ctor(System.Reflection.MethodInfo)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Matchers.MethodMatcher" /> class.
            </summary>
      <param name="methodInfo">The expected method reference.</param>
    </member>
    <member name="M:NMock.Matchers.MethodMatcher.Matches(System.Object)">
      <summary>
            Matches the specified object to this matcher and returns whether it matches.
            </summary>
      <param name="o">The MethodInfo to match.</param>
      <returns>Whether the object is a MethodInfo and its name matches the expected one.</returns>
    </member>
    <member name="T:NMock.Syntax.IStubSyntax`1">
      <summary>
            Syntax methods that are used specifically for stubbing.
            </summary>
      <typeparam name="TInterface">
      </typeparam>
    </member>
    <member name="M:NMock.Syntax.IStubSyntax`1.Method(System.Linq.Expressions.Expression{System.Action{`0}})">
      <summary>
            Creates an expectation for the method specified when the method returns <see langword="void" />.
            The arguments are ignored, use the <see cref="T:NMock.Syntax.IAutoArgumentSyntax`1" /> result of this 
            method to specify the expected arguments.
            </summary>
      <param name="expression">A method call expression that specifies the expected method.</param>
      <returns>An instance of a class used to specify the parameters.</returns>
      <remarks>
        <note type="note">
            This overload is chosen by the compiler when the method specified in the <b>action</b> returns
            <see langword="void" />.
            </note>
        <note type="caution">
            An expectation created with this method will not use the parameters supplied to the method call.
            Parameters must be supplied in order for the code to compile.  Use the <see cref="M:NMock.Syntax.IArgumentSyntax.With(System.Object[])" /> or 
            <see cref="M:NMock.Syntax.IArgumentSyntax.WithAnyArguments" /> methods
            as part of the return type of this method.  As an alternative, use the <see cref="M:NMock.Syntax.IStubSyntax`1.MethodWith(System.Linq.Expressions.Expression{System.Action{`0}})" /> method which
            will use the parameters supplied to the method as part of the expectation.
            </note>
        <note type="tip">
            The <see cref="M:NMock.Syntax.IActionSyntax.Will(NMock.IAction[])" /> method should not be used from this method.  This method
            is used for <see langword="void" /> return types, therefore a return expectation is not needed.
            </note>
      </remarks>
      <seealso cref="M:NMock.Syntax.IStubSyntax`1.MethodWith(System.Linq.Expressions.Expression{System.Action{`0}})" />
      <overloads>
            Creates an expectation for the method specified.
            </overloads>
      <example>
            In this example, the method returns void.
            <code>
            mock.Expects.One.Method(m=&gt;m.MethodName("IgnoredParam")).With("RealParam");
            </code></example>
    </member>
    <member name="M:NMock.Syntax.IStubSyntax`1.Method``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
      <summary>
            Creates an expectation that this method will be called.  The arguments are ignored, use the 
            <see cref="T:NMock.Syntax.IAutoArgumentSyntax`1" /> result of this method to specify the expected arguments.
            </summary>
      <param name="expression">A method call expression that specifies the expected method.</param>
      <returns>An <see cref="T:NMock.Syntax.IAutoArgumentSyntax`1" /> object used to specify expected arguments or return value.</returns>
      <example>
        <code>
            mock.Expects.One.Method(m=&gt;m.MethodName("", 3)).Will(Return.Value(true));
            mock.Expects.One.Method(m=&gt;m.MethodName()).WillReturn(7);
            </code>
      </example>
    </member>
    <member name="M:NMock.Syntax.IStubSyntax`1.MethodWith(System.Linq.Expressions.Expression{System.Action{`0}})">
      <summary>
            Creates an expectation for the method specified when the method returns <see langword="void" />.
            The arguments are used as the expected values.
            </summary>
      <param name="expression">A method call expression that specifies the expected method.</param>
      <returns>An instance of a class used to specify the parameters.</returns>
      <remarks>
        <note type="note">
            This overload is chosen by the compiler when the method specified in the <b>action</b> returns
            <see langword="void" />.
            </note>
        <note type="note">
            An expectation created with this method will use the parameters supplied to the method call.
            </note>
      </remarks>
      <overloads>
            Creates an expectation for the method specified.
            </overloads>
      <example>
            In this example, the method returns void.
            <code>
            mock.Expects.One.MethodWith(m=&gt;m.MethodName("RealParam"));
            </code></example>
    </member>
    <member name="M:NMock.Syntax.IStubSyntax`1.MethodWith``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
      <summary>
            Creates an expectation that this method will be called.  The arguments are used as the expected values.
            </summary>
      <param name="expression">A method call expression that specifies the expected method.</param>
      <returns>An <see cref="T:NMock.Syntax.IAutoActionSyntax`1" /> object used to specify the return value of the method.</returns>
    </member>
    <member name="M:NMock.Syntax.IStubSyntax`1.MethodWith``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},``0)">
      <summary>
            Creates an expectation that this method will be called.  The arguments are used as the expected values.
            </summary>
      <param name="expression">A method call expression that specifies the expected method.</param>
      <param name="returnValue">The value to be returned when the method is called.</param>
      <returns>An <see cref="T:NMock.Syntax.ICommentSyntax" /> object used to specify the explanation for the expectation.</returns>
      <remarks>Compare this method to other versions of this overloaded method in the See Also section.</remarks>
    </member>
    <member name="M:NMock.Syntax.IStubSyntax`1.GetProperty``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
      <summary>
            Creates an expectation that this property will be accessed.
            </summary>
      <typeparam name="TProperty">The property data type.</typeparam>
      <param name="expression">The expression to extract the property name.</param>
      <returns>An <see cref="T:NMock.Syntax.IAutoMatchSyntax`1" /> that can be used to set the return value.</returns>
    </member>
    <member name="M:NMock.Syntax.IStubSyntax`1.GetProperty``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},``0)">
      <summary>
            Creates an expectation that this property will be accessed and it should return the specified value.
            </summary>
      <typeparam name="TProperty">The property data type.</typeparam>
      <param name="expression">A lambda expression to extract the property name.</param>
      <param name="returnValue">The value to be returned when the property is accessed.</param>
      <returns>An object to add comments about this expectation.</returns>
      <remarks>
            Use this method as a shorthand to <see cref="M:NMock.Syntax.IStubSyntax`1.GetProperty``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})" />.
            It sacrifices syntactic sugar but reduces the number of characters to type.
            </remarks>
    </member>
    <member name="M:NMock.Syntax.IStubSyntax`1.DelegateBinding(System.Action{`0})">
      <summary>
            Creates an expectation that a <see cref="T:System.Delegate" /> will be bound to an event.  The type of binding will be infered from the use of += or -=.
            </summary>
      <param name="action">
      </param>
      <returns>
      </returns>
      <remarks>
            If a binding expectation uses <c>null</c>, any arguments will be allowed.
            If a binding references a specific <see cref="T:System.Delegate" />, the expectation will expect that delegate.
            </remarks>
    </member>
    <member name="M:NMock.Syntax.IStubSyntax`1.EventBinding(System.Action{`0})">
      <summary>
            Creates an expectation that an <see cref="T:System.EventHandler" /> will be bound.  The type of binding will be infered from the use of += or -=.
            </summary>
      <param name="action">A lambda expression: e =&gt; e.Event += null</param>
      <returns>
      </returns>
      <remarks>
            Use <see cref="M:NMock.Syntax.IStubSyntax`1.EventBinding``1(System.Action{`0})" /> to bind to <see cref="T:System.EventHandler`1" /> is used.
            </remarks>
    </member>
    <member name="M:NMock.Syntax.IStubSyntax`1.EventBinding``1(System.Action{`0})">
      <summary>
            Creates an expectation that an <see cref="T:System.EventHandler`1" /> will be bound.  The type of binding will be infered from the use of += or -=.
            </summary>
      <param name="action">A lambda expression: e =&gt; e.Event += null</param>
      <typeparam name="TEventArgs">The type of event args for the <see cref="T:System.EventHandler" /></typeparam>
      <returns>
      </returns>
    </member>
    <member name="T:NMock.MockFactory">
      <summary>
            Tracks the expectations created by its <see cref="T:NMock.Mock`1" />s and <see cref="T:NMock.Stub`1" />s.
            </summary>
      <remarks>
            The <b>MockFactory</b> is a main component of the NMock3 API.  It is used to create <see cref="T:NMock.Mock`1" />
            instances and <see cref="T:NMock.Stub`1" /> instances of a <see langword="class" /> or <see langword="interface" />.
            </remarks>
    </member>
    <member name="T:NMock.MockFactory.Popper">
      <summary>
            A popper pops an expectation ordering from the expectations stack on disposal.
            </summary>
    </member>
    <member name="M:NMock.MockFactory.Popper.#ctor(NMock.MockFactory,NMock.IExpectationList)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.MockFactory.Popper" /> class.
            </summary>
      <param name="mockFactory">The mockFactory.</param>
      <param name="previous">The previous.</param>
    </member>
    <member name="M:NMock.MockFactory.Popper.Dispose">
      <summary>
            Pops the expectation ordering from the stack.
            </summary>
    </member>
    <member name="F:NMock.MockFactory.currentMockObjectFactory">
      <summary>
            The mock object factory that is being used by this MockFactory instance.
            </summary>
    </member>
    <member name="F:NMock.MockFactory.stubMockStyleDictionary">
      <summary>
            Holds all mapping from mocks/types to mock styles.
            </summary>
    </member>
    <member name="F:NMock.MockFactory.resolveTypeDelegate">
      <summary>
            The delegate used to resolve the default type returned as return value in calls to mocks with stub behavior.
            </summary>
    </member>
    <member name="F:NMock.MockFactory.thrownUnexpectedInvocationException">
      <summary>
            If an unexpected invocation exception is thrown then it is stored here to re-throw it in the 
            <see cref="M:NMock.MockFactory.VerifyAllExpectationsHaveBeenMet" /> method - exception cannot be swallowed by tested code.
            </summary>
    </member>
    <member name="F:NMock.MockFactory.FirstIncompleteExpectationException">
      <summary>
            A field to store <see cref="T:System.Exception" />s if and Expectation is incomplete
            </summary>
    </member>
    <member name="F:NMock.MockFactory.expectations">
      <summary>
            Expectations at current nesting level.
            </summary>
    </member>
    <member name="M:NMock.MockFactory.#ctor">
      <summary>
            Creates a default <see cref="T:NMock.MockFactory" />.
            </summary>
      <remarks>
            Default <see cref="T:NMock.MockFactory" /> classes do not ignore unexpected incovations.
            </remarks>
    </member>
    <member name="M:NMock.MockFactory.CreateMock``1">
      <summary>
            Creates a <see cref="T:NMock.Mock`1" /> with all of the default values.
            </summary>
      <typeparam name="T">The type of mock to create.</typeparam>
      <returns>
      </returns>
    </member>
    <member name="M:NMock.MockFactory.CreateMock``1(System.String)">
      <summary>
            Creates a <see cref="T:NMock.Mock`1" /> with the specified name.
            </summary>
      <typeparam name="T">The type of mock to create.</typeparam>
      <param name="name">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NMock.MockFactory.CreateMock``1(NMock.MockStyle)">
      <summary>
            Creates a <see cref="T:NMock.Mock`1" /> with the specified <see cref="T:NMock.MockStyle" />.
            </summary>
      <typeparam name="T">The type of mock to create.</typeparam>
      <param name="mockStyle">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NMock.MockFactory.CreateMock``1(NMock.MockStyle,System.Type[])">
      <summary>
            Creates a <see cref="T:NMock.Mock`1" /> with the specified <see cref="T:NMock.MockStyle" /> and additional types.
            </summary>
      <typeparam name="T">The type of mock to create.</typeparam>
      <param name="mockStyle">
      </param>
      <param name="additionalTypesToMock">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NMock.MockFactory.CreateMock``1(System.String,NMock.MockStyle)">
      <summary>
            Creates a <see cref="T:NMock.Mock`1" /> with the specified name and <see cref="T:NMock.MockStyle" />.
            </summary>
      <typeparam name="T">The type of mock to create.</typeparam>
      <param name="name">
      </param>
      <param name="mockStyle">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NMock.MockFactory.CreateMock``1(System.Type[])">
      <summary>
            Creates a <see cref="T:NMock.Mock`1" /> of the primary type and the specified additional types
            </summary>
      <typeparam name="T">The type of mock to create.</typeparam>
      <param name="additionalTypesToMock">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NMock.MockFactory.CreateMock``1(System.Object[])">
      <summary>
            Creates a <see cref="T:NMock.Mock`1" /> with the specified constructor arguments.
            </summary>
      <typeparam name="T">The type of mock to create.</typeparam>
      <param name="constructorArguments">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NMock.MockFactory.CreateMock``1(NMock.IMockDefinition)">
      <summary>
            Creates a <see cref="T:NMock.Mock`1" /> instance.  Use the <see cref="T:NMock.DefinedAs" /> class as a parameter.
            </summary>
      <typeparam name="T">The type of mock to create.</typeparam>
      <param name="mockDefinition">
      </param>
      <returns>
      </returns>
      <remarks>
            This method gives the developer the most control when creating the mock because they can
            specify all parts of the mock definition.
            </remarks>
    </member>
    <member name="M:NMock.MockFactory.CreateMock``1(System.String,NMock.MockStyle,System.Type[],System.Object[])">
      <summary>
            Creates a <see cref="T:NMock.Mock`1" /> using the specified arguments.
            </summary>
      <typeparam name="T">The type of mock to create.</typeparam>
      <param name="name">
      </param>
      <param name="mockStyle">
      </param>
      <param name="additionalTypesToMock">
      </param>
      <param name="constructorArguments">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NMock.MockFactory.CreateInstance``1(NMock.IMockDefinition)">
      <summary>
            Creates a new dynamic mock of the specified type using the supplied definition.
            </summary>
      <typeparam name="TMockedType">The type to mock.</typeparam>
      <param name="definition">An <see cref="T:NMock.IMockDefinition" /> to create the mock from.</param>
      <returns>A dynamic mock for the specified type.</returns>
    </member>
    <member name="M:NMock.MockFactory.CreateInstance``1(System.String)">
      <summary>
            Creates a new dynamic mock of the specified type using the supplied definition.
            </summary>
      <typeparam name="TMockedType">The type to mock.</typeparam>
      <param name="name">The name of the mock.</param>
      <returns>A dynamic mock for the specified type.</returns>
    </member>
    <member name="M:NMock.MockFactory.CreateInstance``1(System.Object[])">
      <summary>
            Creates a new dynamic mock of the specified type.
            </summary>
      <typeparam name="TMockedType">The type to mock.</typeparam>
      <param name="constructorArgs">The arguments for the constructor of the class to be mocked.
            Only applicable when mocking classes with non-default constructors.</param>
      <returns>A dynamic mock for the specified type.</returns>
    </member>
    <member name="M:NMock.MockFactory.CreateInstance``1(NMock.MockStyle,System.Object[])">
      <summary>
            Creates a new dynamic mock of the specified type.
            </summary>
      <typeparam name="TMockedType">The type to mock.</typeparam>
      <param name="mockStyle">Specifies how the mock object should behave when first created.</param>
      <param name="constructorArgs">The arguments for the constructor of the class to be mocked.
            Only applicable when mocking classes with non-default constructors.</param>
      <returns>A dynamic mock for the specified type.</returns>
    </member>
    <member name="M:NMock.MockFactory.Ordered">
      <summary>
            Gets a disposable object and tells the mockFactory that the following expectations are ordered, i.e. they have to be met in the specified order.
            Dispose the returned value to return to previous mode.
            </summary>
      <value>Disposable object. When this object is disposed then the ordered expectation mode is set back to the mode it was previously
            to call to <see cref="M:NMock.MockFactory.Ordered" />.</value>
    </member>
    <member name="M:NMock.MockFactory.Unordered">
      <summary>
            Gets a disposable object and tells the mockFactory that the following expectations are unordered, i.e. they can be met in any order.
            Dispose the returned value to return to previous mode.
            </summary>
      <value>Disposable object. When this object is disposed then the unordered expectation mode is set back to the mode it was previously
            to the call to <see cref="M:NMock.MockFactory.Unordered" />.</value>
    </member>
    <member name="M:NMock.MockFactory.Dispose">
      <summary>
            Disposes the mockFactory be verifying that all expectations were met.
            </summary>
    </member>
    <member name="M:NMock.MockFactory.SuppressUnexpectedAndUnmetExpectations">
      <summary>
            Suppresses when the factory would throw an exception on unmet or unexpected expectations until the next time
            VerifyAllExpectationsHaveBeenMet() is called.
            </summary>
    </member>
    <member name="M:NMock.MockFactory.ChangeDefaultMockObjectFactory(System.Type)">
      <summary>
            Allows the default <see cref="T:NMock.Proxy.IMockObjectFactory" /> to be replaced with a different implementation.
            </summary>
      <param name="factoryType">The System.Type of the <see cref="T:NMock.Proxy.IMockObjectFactory" /> implementation to use.
            This is expected to implement <see cref="T:NMock.Proxy.IMockObjectFactory" /> and have a default constructor.</param>
    </member>
    <member name="M:NMock.MockFactory.ChangeDefaultMockObjectFactory(NMock.Proxy.IMockObjectFactory)">
      <summary>
            Changes the current MockObjectFactory to a user defined one.
            </summary>
      <param name="factory">The new factory</param>
    </member>
    <member name="M:NMock.MockFactory.NewMock(System.Type,System.String,NMock.MockStyle,System.Object[])">
      <summary>
            Creates a new named dynamic mock of the specified type and allows the style
            of the mock to be specified.
            </summary>
      <param name="mockedType">The type to mock.</param>
      <param name="name">A name for the mock that will be used in error messages.</param>
      <param name="mockStyle">Specifies how the mock object should behave when first created.</param>
      <param name="constructorArgs">The arguments for the constructor of the class to be mocked.
            Only applicable when mocking classes with non-default constructors.</param>
      <returns>A named mock.</returns>
    </member>
    <member name="M:NMock.MockFactory.VerifyAllExpectationsHaveBeenMet(System.Boolean)">
      <summary>
            Verifies that all expectations have been met.
            Will be called in <see cref="M:NMock.MockFactory.Dispose" />, too. 
            </summary>
      <param name="rethrowThrownExceptions">A value indicating if exceptions that have already been thrown should be thrown again.</param>
    </member>
    <member name="M:NMock.MockFactory.VerifyAllExpectationsHaveBeenMet">
      <summary>
            Verifies that all expectations have been met.
            Will be called in <see cref="M:NMock.MockFactory.Dispose" />, too. 
            </summary>
    </member>
    <member name="M:NMock.MockFactory.SetResolveTypeHandler(NMock.ResolveTypeDelegate)">
      <summary>
            Sets the resolve type handler used to override default values returned by stubs.
            </summary>
      <param name="resolveTypeHandler">The resolve type handler.</param>
    </member>
    <member name="M:NMock.MockFactory.SetStubMockStyle(System.Object,NMock.MockStyle)">
      <summary>
            Sets the mock style used for all properties and methods returning a value of any type of the <paramref name="mock" />.
            Can be overridden with a type specific mock style with <see cref="M:NMock.MockFactory.SetStubMockStyle``1(System.Object,NMock.MockStyle)" />.
            </summary>
      <param name="mock">The mock (with mock style Stub).</param>
      <param name="nestedMockStyle">The nested mock style.</param>
    </member>
    <member name="M:NMock.MockFactory.SetStubMockStyle``1(System.Object,NMock.MockStyle)">
      <summary>
            Sets the mock style used for all properties and methods returning a value of type <typeparamref name="TStub" />
            of the <paramref name="mock" />.
            </summary>
      <typeparam name="TStub">The type of the stub.</typeparam>
      <param name="mock">The mock (with mock style Stub).</param>
      <param name="nestedMockStyle">The nested mock style.</param>
    </member>
    <member name="M:NMock.MockFactory.SetStubMockStyle(System.Object,System.Type,NMock.MockStyle)">
      <summary>
            Sets the mock style used for all properties and methods returning a value of type <paramref name="nestedMockType" />
            of the <paramref name="mock" />.
            </summary>
      <param name="mock">The mock (with mock style Stub).</param>
      <param name="nestedMockType">Type of the nested mock.</param>
      <param name="nestedMockStyle">The nested mock style.</param>
    </member>
    <member name="M:NMock.MockFactory.ClearExpectations(NMock.IMockObject)">
      <summary>
            Clears all expectation on the specified mock.
            </summary>
      <param name="mockObject">The mock for which all expectations are cleared.</param>
    </member>
    <member name="M:NMock.MockFactory.AddExpectation(NMock.IExpectation)">
      <summary>
            Adds the expectation.
            </summary>
      <param name="expectation">The expectation.</param>
    </member>
    <member name="M:NMock.MockFactory.ResolveType(System.Object,System.Type)">
      <summary>
            Resolves the return value to be used in a call to a mock with stub behavior.
            </summary>
      <param name="mock">The mock on which the call is made.</param>
      <param name="requestedType">The type of the return value.</param>
      <returns>The object to be returned as return value; or <see cref="F:System.Reflection.Missing.Value" />
            if the default value should be used.</returns>
    </member>
    <member name="M:NMock.MockFactory.GetDependencyMockStyle(System.Object,System.Type)">
      <summary>
            Gets the mock style to be used for a mock created for a return value of a call to mock with stub behavior.
            </summary>
      <param name="mock">The mock that wants to create a mock.</param>
      <param name="requestedType">The type of the requested mock.</param>
      <returns>The mock style to use on the created mock. Null if <see cref="F:NMock.MockStyle.Default" /> has to be used.</returns>
    </member>
    <member name="M:NMock.MockFactory.Dispatch(NMock.Monitoring.Invocation)">
      <summary>
            Dispatches the specified invocation.
            </summary>
      <param name="invocation">The invocation.</param>
    </member>
    <member name="M:NMock.MockFactory.HasExpectationFor(NMock.Monitoring.Invocation)">
      <summary>
            Determines whether there exist expectations for the specified invocation.
            </summary>
      <param name="invocation">The invocation.</param>
      <returns>
        <c>true</c> if there exist expectations for the specified invocation; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:NMock.MockFactory.CastToMockObject(System.Object)">
      <summary>
            Casts the argument to <see cref="T:NMock.IMockObject" />.
            </summary>
      <param name="mock">The object to cast.</param>
      <returns>The argument casted to <see cref="T:NMock.IMockObject" /></returns>
      <throws cref="T:System.ArgumentNullException">Thrown if <paramref name="mock" /> is null</throws>
      <throws cref="T:System.ArgumentException">Thrown if <paramref name="mock" /> is not a <see cref="T:NMock.IMockObject" /></throws>
    </member>
    <member name="M:NMock.MockFactory.ClearExpectations">
      <summary>
            Resets the state of the factory.
            </summary>
      <remarks>
            Use this method after expected exceptions.
            </remarks>
    </member>
    <member name="M:NMock.MockFactory.ClearException">
      <summary>
            Clears thrown unexpected exceptions so that a new exception will be thrown.
            </summary>
    </member>
    <member name="M:NMock.MockFactory.Push(NMock.IExpectationList)">
      <summary>
            Pushes the specified new ordering on the expectations stack.
            </summary>
      <param name="newOrdering">The new ordering.</param>
      <returns>Disposable popper.</returns>
    </member>
    <member name="M:NMock.MockFactory.Pop(NMock.IExpectationList)">
      <summary>
            Pops the specified old ordering from the expectations stack.
            </summary>
      <param name="oldOrdering">The old ordering.</param>
    </member>
    <member name="M:NMock.MockFactory.FailUnmetExpectations">
      <summary>
            Throws an exception listing all unmet expectations.
            </summary>
    </member>
    <member name="M:NMock.MockFactory.FailUnexpectedInvocation(NMock.Monitoring.Invocation)">
      <summary>
            Throws an exception indicating that the specified invocation is not expected.
            </summary>
      <param name="invocation">The invocation.</param>
    </member>
    <member name="T:NMock.ResolveTypeDelegate">
      <summary>
            Delegate used to override default type returned in stub behavior.
            </summary>
      <param name="mock">The mock that has to return a value.</param>
      <param name="requestedType">Type of the return value.</param>
      <returns>The object to return as return value for the requested type.</returns>
    </member>
    <member name="T:NMock.Matchers.IndexSetterArgumentsMatcher">
      <summary>
            Matcher for indexer setters. Checks that the arguments passed to the indexer match.
            </summary>
    </member>
    <member name="M:NMock.Matchers.IndexSetterArgumentsMatcher.#ctor(NMock.Matcher[])">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Matchers.IndexSetterArgumentsMatcher" /> class.
            </summary>
      <param name="valueMatchers">The value matchers. This is an ordered list of matchers, each matching a single method argument.</param>
    </member>
    <member name="M:NMock.Matchers.IndexSetterArgumentsMatcher.DescribeTo(System.IO.TextWriter)">
      <summary>
            Describes this matcher.
            </summary>
      <param name="writer">The text writer to which the description is added.</param>
    </member>
    <member name="T:NMock.Matchers.BinaryOperator">
      <summary>
            BinaryOperator is an abstract base class for matchers that combine two matchers into a single matcher. 
            </summary>
    </member>
    <member name="F:NMock.Matchers.BinaryOperator.Left">
      <summary>
            The left hand side of the binary operator.
            </summary>
    </member>
    <member name="F:NMock.Matchers.BinaryOperator.Right">
      <summary>
            The right hand side of the binary operator.
            </summary>
    </member>
    <member name="M:NMock.Matchers.BinaryOperator.#ctor(NMock.Matcher,NMock.Matcher)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Matchers.BinaryOperator" /> class.
            </summary>
      <param name="left">The left operand.</param>
      <param name="right">The right operand.</param>
    </member>
    <member name="T:NMock.Extensions">
      <summary>
            This class contains extension methods to support other classes.
            </summary>
    </member>
    <member name="M:NMock.Extensions.Times(System.Int32)">
      <summary>
            Returns a string representing grammatically correctness of n times depending on the value of <paramref name="count" />.
            </summary>
      <param name="count">An integer value representing n times.</param>
      <returns>The string ' time' or ' times'.</returns>
    </member>
    <member name="M:NMock.Extensions.DefaultNameFor(System.Type)">
      <summary>
            Returns the default name for a type that is used to name mocks.
            </summary>
      <param name="type">The type to get the default name for.</param>
      <returns>Default name for the specified type.</returns>
    </member>
    <member name="M:NMock.Extensions.FirstLowerCaseChar(System.String)">
      <summary>
            Finds the first lower case char in the specified string.
            </summary>
      <param name="s">The string to inspect.</param>
      <returns>the first lower case char in the specified string.</returns>
    </member>
    <member name="T:NMock.Properties.Resources">
      <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
    </member>
    <member name="P:NMock.Properties.Resources.ResourceManager">
      <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
    </member>
    <member name="P:NMock.Properties.Resources.Culture">
      <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
    </member>
    <member name="T:NMock.Matchers.ListMatcher">
      <summary>
            Used by NMock framework to make sure two lists are equal.
            </summary>
    </member>
    <member name="M:NMock.Matchers.ListMatcher.#ctor(System.Collections.IList)">
      <summary>
            Constructor
            </summary>
      <param name="sourceList">The list containing the expected results.</param>
    </member>
    <member name="M:NMock.Matchers.ListMatcher.Matches(System.Object)">
      <summary>
            Called by NMock to verify o corresponds to the source list.
            </summary>
      <param name="o">List to compare against the source list for equality.</param>
      <returns>True: the two lists have the same number of items and their items are equal.</returns>
    </member>
    <member name="M:NMock.Matchers.ListMatcher.DescribeTo(System.IO.TextWriter)">
      <summary>
            Describes this matcher.
            </summary>
      <param name="writer">The text writer to which the description is added.</param>
    </member>
    <member name="T:NMock.Matchers.AndMatcher">
      <summary>
            Matcher that is the logical and combination of two matchers.
            </summary>
    </member>
    <member name="M:NMock.Matchers.AndMatcher.#ctor(NMock.Matcher,NMock.Matcher)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Matchers.AndMatcher" /> class.
            </summary>
      <param name="left">The left operand.</param>
      <param name="right">The right operand.</param>
    </member>
    <member name="M:NMock.Matchers.AndMatcher.Matches(System.Object)">
      <summary>
            Matches the specified object to this matcher and returns whether it matches.
            </summary>
      <param name="o">The object to match.</param>
      <returns>Returns whether the object matches.</returns>
    </member>
    <member name="M:NMock.Matchers.AndMatcher.DescribeTo(System.IO.TextWriter)">
      <summary>
            Describes this matcher.
            </summary>
      <param name="writer">The text writer to which the description is added.</param>
    </member>
    <member name="T:NMock.Syntax.IMethodSyntax`1">
      <summary>
            Contains the methods that define the expectation for either a property, method, or event.
            </summary>
      <typeparam name="TInterface">The interface or class being mocked.</typeparam>
      <remarks>
            This interface defines generic methods that take lambda expressions.
            </remarks>
    </member>
    <member name="M:NMock.Syntax.IMethodSyntax`1.SetProperty``1(System.Func{`0,``0})">
      <summary>
            Creates an expectation that this property will be set to a value specified in the 
            <see cref="T:NMock.Syntax.IAutoValueSyntax`1" /> result of this method.  The value used in the expression
            is ignored.
            </summary>
      <typeparam name="TProperty">
      </typeparam>
      <param name="expression">A set property expression that specifies the property to be set.</param>
      <remarks>
            If the property specified in the expression has a getter, a value isn't required in the expression.
            <code>
            mock.Expects.One.SetProperty(p =&gt; p.Prop)
            </code>
            instead of
            <code>
            mock.Expects.One.SetProperty(p =&gt; p.Prop = "Ignored Value")
            </code>
            The code above only needs to be used in cases where the property is write-only.
            </remarks>
      <returns>
      </returns>
    </member>
    <member name="M:NMock.Syntax.IMethodSyntax`1.SetPropertyTo(System.Action{`0})">
      <summary>
            Creates an expectation that this property will be set to the specified value.
            </summary>
      <param name="action">z =&gt; z.prop = 0</param>
      <returns>An <see cref="T:NMock.Syntax.ICommentSyntax" /> object to specify the comment for the expectation. </returns>
    </member>
    <member name="T:NMock.Mock`1">
      <summary>
            This class represents a mock object of an interface or class.  To create a <see cref="T:NMock.Mock`1" />, 
            use a <see cref="T:NMock.MockFactory" />.
            </summary>
      <typeparam name="T">The type to mock.</typeparam>
      <example>
        <code>
            
            public class TestClass
            {
            	public void TestMethod()
            	{
            		MockFactory factory = new MockFactory();
            		Mock&lt;ISample&gt; mock = factory.CreateMock&lt;ISample&gt;();
            
            		//create an expectation that the property Prop will be set to 3
            		mock.Expects.One.SetPropertyTo(m=&gt;m.Prop=3);
            
            		new Driver(mock.MockObject).Drive(3);
            	}
            }
            
            public interface ISample
            {
            	int Prop {get; set;}
            }
            
            public class Driver
            {
            	public Driver(ISample sample)
            	{
            		Sample = sample;
            	}
            	public int Sample {get;set;}
            	public void Drive(int value)
            	{
            		Sample.Prop = value;
            	}
            }
            
            </code>
      </example>
    </member>
    <member name="M:NMock.Mock`1.#ctor(System.Object,NMock.MockFactory)">
      <summary>
      </summary>
      <param name="proxy">
      </param>
      <param name="factory">
      </param>
      <exception cref="T:System.ArgumentNullException" />
    </member>
    <member name="M:NMock.Mock`1.As``1">
      <summary>
            Duck Typing method: Returns a <see cref="T:NMock.Mock`1" /> instance of the type being specified in <typeparamref name="TType" />.
            </summary>
      <typeparam name="TType">
      </typeparam>
      <returns>
      </returns>
      <remarks>This method will not throw an exception if the cast is not successful.  It will return null.  Use <c cref="M:NMock.Mock`1.As``1(System.Boolean)" /> to specify if an exception should be thrown.</remarks>
    </member>
    <member name="M:NMock.Mock`1.As``1(System.Boolean)">
      <summary>
            Duck Typing method: Returns a <see cref="T:NMock.Mock`1" /> instance of the type being specified in <typeparamref name="TType" />.
            </summary>
      <typeparam name="TType">
      </typeparam>
      <param name="throwException">
      </param>
      <returns>
      </returns>
      <exception cref="T:System.InvalidCastException">
      </exception>
      <remarks>Use this method to specify if an exception should be thrown when a cast is not valid.</remarks>
    </member>
    <member name="M:NMock.Mock`1.ToString">
      <summary>
            Overriden ToString method that throws an exception when called so that the deloper does not
            confuse this ToString with the ToString of the <see cref="P:NMock.Mock`1.MockObject" /> property.
            </summary>
      <returns>The name of the <see cref="T:NMock.Mock`1" /></returns>
      <seealso cref="P:NMock.Mock`1.ThrowToStringException" />
    </member>
    <member name="M:NMock.Mock`1.ClearExpectations">
      <summary>
            Clears all expectations of this mock.
            </summary>
      <remarks>
            Use this method to clear expectations in a test before the test cleanup runs
            to avoid unmet expectations.  It is useful when testing error conditions.
            </remarks>
    </member>
    <member name="P:NMock.Mock`1.MockObject">
      <summary>
            An object of type <typeparamref name="T" /> to be used whenever the Mocked object is needed.
            </summary>
      <remarks>
            This property provides access to the proxy that is mocking the actual type.  Use this property
            when a reference to an object that is of the mocked type is needed.
            </remarks>
      <example>
            This example shows how a presenter needs arguments of the right type during construction.  The
            <c>MockObject</c> property is used because the presenter can't be instantiated with a <see cref="T:NMock.Mock`1" />
            argument.
            <code>
            interface IView { ... }
            interface IModel { ... }
            
            Mock&lt;IView&gt; view = factory.CreateMock&lt;IView&gt;();
            Mock&lt;IModel&gt; view = factory.CreateMock&lt;IModel&gt;();
            
            Presenter p = new Presenter(view.MockObject, model.MockObject);
            </code></example>
    </member>
    <member name="P:NMock.Mock`1.Expects">
      <summary>
            A syntax property used to access members that specify the number of times an expectation could occur.
            </summary>
      <remarks>This would be considered to be the main property of a <see cref="T:NMock.Mock`1" /> class.  This property
            provides access to all other expectation setup methods.</remarks>
      <example>
            In this example:
            <list type="bullet"><item><term><c>mock</c></term><description>is an instance of a <see cref="T:NMock.Mock`1" />.</description></item><item><term><c>Expects</c></term><description>refers to this property.</description></item><item><term><c>One</c></term><description>is the number of times this action is expected.</description></item><item><term><c>SetPropertyTo</c></term><description>is the type of expection.  <see cref="M:NMock.Syntax.IMethodSyntax`1.SetPropertyTo(System.Action{`0})" /> means the mock expects a property to be set to a value.</description></item><item><term><c>m</c></term><description>is the variable in our anonymous method that represents the mocked interface or class.</description></item><item><term><c>Prop</c></term><description>is the property on the mocked interface or class that the expectation is for.  It will be set to the value 3.</description></item></list><code>
            
            //create an expectation that the property Prop will be set to 3
            mock.Expects.One.SetPropertyTo(m=&gt;m.Prop=3);
            
            </code>
            View more of this code in the <see cref="T:NMock.Mock`1" /> example.
            </example>
    </member>
    <member name="P:NMock.Mock`1.Stub">
      <summary>
            A syntax property that returns a <see cref="T:NMock.Stub`1" /> class to stub out a member on the Mock.
            </summary>
    </member>
    <member name="P:NMock.Mock`1.IgnoreUnexpectedInvocations">
      <summary>
            Gets or sets a value indicating if this <see cref="T:NMock.Mock`1" /> should ignore unexpected invocations to properties, methods, or events.
            </summary>
      <remarks>
            Use the property to have a Mock ignore calls with no expectations.  By default, this works fine for property setters, void methods,
            and events.  Property getters and non-void methods will need to indicate how they will be implemented as they <i>need</i> to return
            a value.
            </remarks>
    </member>
    <member name="P:NMock.Mock`1.ThrowToStringException">
      <summary>
            Gets or sets a value indicating if an exception should be thrown when the <see cref="M:NMock.Mock`1.ToString" /> is called.
            </summary>
    </member>
    <member name="P:NMock.Mock`1.Name">
      <summary>
            Returns the name of the underlying proxy
            </summary>
    </member>
    <member name="T:NMock.Matchers.CallbackMatcher`1">
      <summary>
            A matcher that stores a delegate to call back to later.
            </summary>
      <typeparam name="T">Typically a <see cref="T:System.Action" />, <see cref="T:System.Predicate`1" />, <see cref="T:System.Func`1" />, or their equivalents.</typeparam>
    </member>
    <member name="M:NMock.Matchers.CallbackMatcher`1.Matches(System.Object)">
      <summary>
            Determines if the parameter is the same type as <typeparamref name="T" />.
            </summary>
      <param name="o">The value the matcher will evaluate.</param>
      <returns>A value indicating if the parameter matches or not.</returns>
    </member>
    <member name="M:NMock.Matchers.CallbackMatcher`1.DescribeTo(System.IO.TextWriter)">
      <summary>
            Describes this matcher.
            </summary>
      <param name="writer">The text writer to which the description is added.</param>
    </member>
    <member name="P:NMock.Matchers.CallbackMatcher`1.Callback">
      <summary>
            Gets a reference to the callback assigned during the matching operation of the expectation.
            </summary>
    </member>
    <member name="T:NMock.Actions.CollectAction`1">
      <summary>
            Action that calls the collect delegate passed to constructor with the n-th element of the arguments to an invocation.
            </summary>
      <typeparam name="T">Type of the argument to collect.</typeparam>
    </member>
    <member name="T:NMock.Actions.CollectAction`1.Collect">
      <summary>
            Delegate that is called on collecting an argument.
            </summary>
      <param name="collectedParameter">The collected generic parameter.</param>
    </member>
    <member name="F:NMock.Actions.CollectAction`1.argumentIndex">
      <summary>
            Stores the index of the argument.
            </summary>
    </member>
    <member name="F:NMock.Actions.CollectAction`1.collectDelegate">
      <summary>
            Stores the collect delegate.
            </summary>
    </member>
    <member name="M:NMock.Actions.CollectAction`1.#ctor(System.Int32,NMock.Actions.CollectAction{`0}.Collect)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Actions.CollectAction`1" /> class.
            </summary>
      <param name="argumentIndex">Index of the argument.</param>
      <param name="collectDelegate">The collect delegate.</param>
    </member>
    <member name="T:NMock.Throw">
      <summary>
            Defines action for throwing actions.
            </summary>
    </member>
    <member name="M:NMock.Throw.Exception(System.Exception)">
      <summary>
            Throws an exeception when the action is invoked.
            </summary>
      <param name="exception">The exception to throw when invoked.</param>
      <returns>Returns a new instance of the <see cref="T:NMock.Actions.ThrowAction" /> class.</returns>
    </member>
    <member name="T:NMock.Is">
      <summary>
            Provides shortcuts to <see cref="T:NMock.Matcher" />s.
            </summary>
    </member>
    <member name="F:NMock.Is.Anything">
      <summary>
            Matches anything.
            </summary>
    </member>
    <member name="F:NMock.Is.Nothing">
      <summary>
            Matches nothing.
            </summary>
    </member>
    <member name="F:NMock.Is.Null">
      <summary>
            Matches if the value is null.
            </summary>
    </member>
    <member name="F:NMock.Is.NotNull">
      <summary>
            Matches if the value is not null.
            </summary>
    </member>
    <member name="F:NMock.Is.Out">
      <summary>
            Matches out parameters of methods.
            </summary>
    </member>
    <member name="M:NMock.Is.EqualTo(System.Object)">
      <summary>
            Matches objects the are equal to the expected object.
            </summary>
      <param name="expected">The expected.</param>
      <returns>Returns a new instance of the <see cref="T:NMock.Matchers.EqualMatcher" /> class.</returns>
    </member>
    <member name="M:NMock.Is.Same(System.Object)">
      <summary>
            Matches an expected object.
            <seealso cref="M:NMock.Is.EqualTo(System.Object)" /></summary>
      <param name="expected">The expected object.</param>
      <returns>Returns a new instance of the <see cref="T:NMock.Matchers.EqualMatcher" /> class.</returns>
    </member>
    <member name="M:NMock.Is.ComparableTo(System.Object)">
      <summary>
            Matches objects that implement the <see cref="T:System.IComparable" /> interface.
            </summary>
      <param name="expected">The instance to be compared.</param>
      <returns>Returns a new instance of the <see cref="T:NMock.Matchers.ObjectMatcher" /> class.</returns>
    </member>
    <member name="M:NMock.Is.StringContaining(System.String)">
      <summary>
            Matches strings containing the specified <paramref name="substring" />.
            </summary>
      <param name="substring">The substring.</param>
      <returns>Returns a new instance of the <see cref="T:NMock.Matchers.StringContainsMatcher" /> class.</returns>
    </member>
    <member name="M:NMock.Is.GreaterThan(System.IComparable)">
      <summary>
            Matches objects that are greater than <paramref name="value" />.
            </summary>
      <param name="value">The value to compare.</param>
      <returns>Returns a new instance of the <see cref="T:NMock.Matchers.ComparisonMatcher" /> class.</returns>
    </member>
    <member name="M:NMock.Is.AtLeast(System.IComparable)">
      <summary>
            Matches objects that are at least equal to <paramref name="value" />.
            </summary>
      <param name="value">The value to compare.</param>
      <returns>Returns a new instance of the <see cref="T:NMock.Matchers.ComparisonMatcher" /> class.</returns>
    </member>
    <member name="M:NMock.Is.LessThan(System.IComparable)">
      <summary>
            Matches objects less than <paramref name="value" />.
            </summary>
      <param name="value">The value to compare.</param>
      <returns>Returns a new instance of the <see cref="T:NMock.Matchers.ComparisonMatcher" /> class.</returns>
    </member>
    <member name="M:NMock.Is.AtMost(System.IComparable)">
      <summary>
            Matches objects that are less or equal to <paramref name="value" />.
            </summary>
      <param name="value">The value to compare.</param>
      <returns>Returns a new instance of the <see cref="T:NMock.Matchers.ComparisonMatcher" /> class.</returns>
    </member>
    <member name="M:NMock.Is.In(System.Collections.ICollection)">
      <summary>
            Matches objects in the specified collection.
            </summary>
      <param name="collection">The collection with objects to match.</param>
      <returns>Returns a new instance of the <see cref="T:NMock.Matchers.ElementMatcher" /> class.</returns>
    </member>
    <member name="M:NMock.Is.OneOf(System.Object[])">
      <summary>
            Matches objects in the specified elements.
            </summary>
      <param name="elements">The elements to match.</param>
      <returns>Returns a new instance of the <see cref="T:NMock.Matchers.ElementMatcher" /> class.</returns>
    </member>
    <member name="M:NMock.Is.TypeOf(System.Type)">
      <summary>
            Matches objects of the specified type.
            </summary>
      <param name="type">The type to match.</param>
      <returns>Returns a new instance of the <see cref="T:NMock.Matchers.TypeMatcher" /> class.</returns>
    </member>
    <member name="M:NMock.Is.TypeOf``1">
      <summary>
            Matches objects of the specified type.
            </summary>
      <typeparam name="T">The type to match.</typeparam>
      <returns>
            Returns a new instance of the <see cref="T:NMock.Matchers.TypeMatcher" /> class.
            </returns>
    </member>
    <member name="M:NMock.Is.Match``1(System.Predicate{``0})">
      <summary>
            Matches objects against the specified expression.
            </summary>
      <typeparam name="T">Type of the value to match.</typeparam>
      <param name="expression">The match expression.</param>
      <returns>returns a new instance of the <see cref="T:NMock.Matchers.PredicateMatcher`1" />.</returns>
    </member>
    <member name="T:NMock.Syntax.IArgumentSyntax">
      <summary>
            Syntax for defining expected arguments of a method call.
            </summary>
    </member>
    <member name="M:NMock.Syntax.IArgumentSyntax.With(System.Object[])">
      <summary>
            Defines the arguments that are expected on the method call.
            </summary>
      <param name="expectedArguments">The expected arguments.</param>
      <returns>Matcher syntax.</returns>
      <remarks>
            The specified arguments are converted to <see chref="EqualMatcher" />s.  Matchers
            as well as non-Matchers can be used interchangably in the method.
            </remarks>
    </member>
    <member name="M:NMock.Syntax.IArgumentSyntax.WithNoArguments">
      <summary>
            Defines that no arguments are expected on the method call.
            </summary>
      <returns>Matcher syntax.</returns>
    </member>
    <member name="M:NMock.Syntax.IArgumentSyntax.WithAnyArguments">
      <summary>
            Defines that any arguments are allowed on the method call.
            </summary>
      <returns>Matcher syntax.</returns>
    </member>
    <member name="M:NMock.Syntax.IArgumentSyntax.WithArguments(NMock.Matcher[])">
      <summary>
            Defines matching criteria for arguments.
            </summary>
      <param name="argumentMatchers">A list of matchers to match the arguments of a method.</param>
      <returns>Matcher syntax.</returns>
      <remarks>
            The matchers will be automatically wrapped in an ArgumentsMatcher.
            </remarks>
    </member>
    <member name="M:NMock.Internal.ExpectationBuilder.IndexSetterBuilder.#ctor(NMock.Internal.BuildableExpectation,NMock.Internal.ExpectationBuilder)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Internal.ExpectationBuilder.IndexSetterBuilder" /> class.
            </summary>
      <param name="expectation">The expectation.</param>
      <param name="builder">The builder.</param>
    </member>
    <member name="M:NMock.Internal.ExpectationBuilder.PropertyValueBuilder.#ctor(NMock.Internal.ExpectationBuilder)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Internal.ExpectationBuilder.PropertyValueBuilder" /> class.
            </summary>
      <param name="builder">The builder.</param>
    </member>
    <member name="F:NMock.Internal.ExpectationBuilder.UsingMethodWith">
      <summary>
            A flag that specifies if the expectation was set up using 'MethodWith' in which case an ExpectationException is not thrown
            when the method takes no arguments.
            </summary>
    </member>
    <member name="M:NMock.Internal.ExpectationBuilder.#ctor(System.String,NMock.Matcher,NMock.Matcher,System.Object)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Internal.ExpectationBuilder" /> class.
            </summary>
      <param name="description">The description.</param>
      <param name="requiredCountMatcher">The required count matcher.</param>
      <param name="matchingCountMatcher">The matching count matcher.</param>
      <param name="proxy">
      </param>
    </member>
    <member name="M:NMock.Internal.ExpectationBuilder.With(System.Object[])">
      <summary>
            Defines the arguments that are expected on the method call.
            </summary>
      <param name="expectedArguments">The expected arguments.</param>
      <returns>Matcher syntax.</returns>
    </member>
    <member name="M:NMock.Internal.ExpectationBuilder.WithNoArguments">
      <summary>
            Defines that no arguments are expected on the method call.
            </summary>
      <returns>Matcher syntax.</returns>
    </member>
    <member name="M:NMock.Internal.ExpectationBuilder.WithAnyArguments">
      <summary>
            Defines that all arguments are allowed on the method call.
            </summary>
      <returns>Matcher syntax.</returns>
    </member>
    <member name="M:NMock.Internal.ExpectationBuilder.Matching(NMock.Matcher)">
      <summary>
            Defines a matching criteria.
            </summary>
      <param name="matcher">The matcher.</param>
      <returns>
            Action syntax defining the action to take.
            </returns>
    </member>
    <member name="M:NMock.Internal.ExpectationBuilder.Will(NMock.IAction[])">
      <summary>
            Defines what will happen.
            </summary>
      <param name="actions">The actions to take.</param>
      <returns>
            Returns the comment syntax defined after will.
            </returns>
    </member>
    <member name="M:NMock.Internal.ExpectationBuilder.Comment(System.String)">
      <summary>
            Adds a comment for the expectation that is added to the error message if the expectation is not met.
            </summary>
      <param name="comment">The comment that is shown in the error message if this expectation is not met.
            You can describe here why this expectation has to be met.</param>
    </member>
    <member name="M:NMock.Internal.ExpectationBuilder.ProtectedMethod(System.String)">
      <summary>
            Methods the specified method name.
            </summary>
      <param name="methodName">Name of the method.</param>
      <returns>
      </returns>
    </member>
    <member name="M:NMock.Internal.ExpectationBuilder.Method(NMock.Matcher)">
      <summary>
            Defines a method.
            </summary>
      <param name="methodMatcher">Matcher for matching the method on an invocation.</param>
      <returns>
            Argument syntax defining the arguments of the method.
            </returns>
    </member>
    <member name="M:NMock.Internal.ExpectationBuilder.GetProperty(System.String)">
      <summary>
            Gets the property.
            </summary>
      <param name="propertyName">Name of the property.</param>
      <returns>
      </returns>
    </member>
    <member name="M:NMock.Internal.ExpectationBuilder.SetProperty(System.String)">
      <summary>
            Sets the property.
            </summary>
      <param name="propertyName">Name of the property.</param>
      <returns>
      </returns>
    </member>
    <member name="M:NMock.Internal.ExpectationBuilder.On(NMock.IMockObject)">
      <summary>
            Defines the receiver.
            </summary>
      <param name="receiver">The dynamic mock on which the expectation or stub is applied.</param>
      <returns>Method syntax defining the method, property or event.</returns>
    </member>
    <member name="M:NMock.Internal.ExpectationBuilder.ArgumentMatchers(System.Object[])">
      <summary>
            Converts the object array into a List of matchers.
            </summary>
      <param name="expectedArguments">The expected arguments.</param>
      <returns>
      </returns>
    </member>
    <member name="M:NMock.Internal.ExpectationBuilder.EnsureMatchingMethodExistsOnMock(NMock.Matcher,System.String)">
      <summary>
            Ensures the matching method exists on mock.
            </summary>
      <param name="methodMatcher">The method matcher.</param>
      <param name="methodDescription">The method description.</param>
    </member>
    <member name="T:NMock.Collect">
      <summary>
            Gather information about invocations.
            </summary>
    </member>
    <member name="M:NMock.Collect.MethodArgument``1(System.Int32,NMock.Actions.CollectAction{``0}.Collect)">
      <summary>
            Calls the specified <paramref name="collectDelegate" /> with the method argument at index <paramref name="argumentIndex" />.
            Can only be used as action of an expectation on a method call.
            </summary>
      <typeparam name="TArgument">The type of the argument.</typeparam>
      <param name="argumentIndex">Index of the argument.</param>
      <param name="collectDelegate">The collect delegate.</param>
      <returns>Action that collects a method argument.</returns>
    </member>
    <member name="M:NMock.Collect.PropertyValue``1(NMock.Actions.CollectAction{``0}.Collect)">
      <summary>
            Calls the specified <paramref name="collectDelegate" /> with the value that is set to the property.
            Can only be used as action of an expectation on a property setter. 
            </summary>
      <typeparam name="TValue">The type of the value.</typeparam>
      <param name="collectDelegate">The collect delegate.</param>
      <returns>Action that collects a property value.</returns>
    </member>
    <member name="T:NMock.DefinedAs">
      <summary>
            Defines the initial characteristics of a new mock object.
            This is normally used in conjunction with <see cref="M:NMock.MockFactory.CreateMock``1(NMock.IMockDefinition)" /></summary>
    </member>
    <member name="M:NMock.DefinedAs.Implementing``1">
      <summary>
            Specifies a type that this mock should implement. This may be a class or interface,
            but there can only be a maximum of one class implemented by a mock.
            </summary>
      <typeparam name="T">The type to implement.</typeparam>
      <returns>The mock object definition.</returns>
    </member>
    <member name="M:NMock.DefinedAs.Implementing(System.Type[])">
      <summary>
            Specifies the types that this mock should implement. These may be a class or interface,
            but there can only be a maximum of one class implemented by a mock.
            </summary>
      <param name="types">The types to implement.</param>
      <returns>The mock object definition.</returns>
    </member>
    <member name="M:NMock.DefinedAs.OfStyle(NMock.MockStyle)">
      <summary>
            Specifies how the mock object should behave when first created.
            </summary>
      <param name="mockStyle">A MockStyle value.</param>
      <returns>The mock object definition.</returns>
    </member>
    <member name="M:NMock.DefinedAs.WithArgs(System.Object[])">
      <summary>
            Specifies the arguments for the constructor of the class to be mocked.
            Only applicable when mocking a class with a non-default constructor.
            </summary>
      <param name="args">The arguments for the class constructor.</param>
      <returns>The mock object definition.</returns>
    </member>
    <member name="M:NMock.DefinedAs.Named(System.String)">
      <summary>
            Specifies a name for the mock. This will be used in error messages,
            and as the return value of ToString() if not mocking a class.
            </summary>
      <param name="name">The name for the mock.</param>
      <returns>The mock object definition.</returns>
    </member>
    <member name="P:NMock.DefinedAs.Default">
      <summary>
            Returns a default implementation of <see cref="T:NMock.Syntax.IMockDefinitionSyntax" />.
            </summary>
    </member>
    <member name="T:NMock.Actions.DelegateAction">
      <summary>
            Action that executes the delegate passed to the constructor.
            </summary>
    </member>
    <member name="T:NMock.Actions.DelegateAction.Handler">
      <summary>
            Delegate that is executed on invocation of the action.
            </summary>
    </member>
    <member name="F:NMock.Actions.DelegateAction._handler">
      <summary>
            Stores the handler of the delegate action.
            </summary>
    </member>
    <member name="M:NMock.Actions.DelegateAction.#ctor(NMock.Actions.DelegateAction.Handler)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Actions.DelegateAction" /> class.
            </summary>
      <param name="actionHandler">The action handler.</param>
    </member>
    <member name="T:NMock.That">
      <summary>
            A syntax class to setup expectations on methods when they throw exceptions.
            </summary>
    </member>
    <member name="M:NMock.That.#ctor(System.Action)">
      <summary>
            Creates an instance of this class specifying the action that will throw an exception
            </summary>
      <param name="action">
      </param>
    </member>
    <member name="M:NMock.That.Throws">
      <summary>
            Indicates that this method will throw an <see cref="T:System.Exception" />.
            </summary>
    </member>
    <member name="M:NMock.That.Throws(NMock.Matcher[])">
      <summary>
            Indicates that this method will throw an <see cref="T:System.Exception" />.
            </summary>
      <param name="matchers">An array of matchers to match the exception string.</param>
    </member>
    <member name="M:NMock.That.Throws(System.String)">
      <summary>
            Indicates that this method will throw an <see cref="T:System.Exception" />.
            </summary>
      <param name="comment">A description of the reason for this expectation.</param>
    </member>
    <member name="M:NMock.That.Throws(System.String,NMock.Matcher[])">
      <summary>
            Indicates that this method will throw an <see cref="T:System.Exception" />.
            </summary>
      <param name="comment">A description of the reason for this expectation.</param>
      <param name="matchers">An array of matchers to match the exception string.</param>
    </member>
    <member name="M:NMock.That.Throws``1">
      <summary>
            Indicates that this method will throw an <see cref="T:System.Exception" />.
            </summary>
      <typeparam name="T">The type of <see cref="T:System.Exception" /> to throw.</typeparam>
    </member>
    <member name="M:NMock.That.Throws``1(System.String)">
      <summary>
            Indicates that this method will throw an <see cref="T:System.Exception" />.
            </summary>
      <typeparam name="T">The type of <see cref="T:System.Exception" /> to throw.</typeparam>
      <param name="comment">A description of the reason for this expectation.</param>
    </member>
    <member name="M:NMock.That.Throws``1(NMock.Matcher[])">
      <summary>
            Indicates that this method will throw an <see cref="T:System.Exception" />.
            </summary>
      <typeparam name="T">The type of <see cref="T:System.Exception" /> to throw.</typeparam>
      <param name="matchers">An array of matchers to match the exception string.</param>
    </member>
    <member name="M:NMock.That.Throws``1(System.String,NMock.Matcher[])">
      <summary>
            Indicates that this method will throw an <see cref="T:System.Exception" />.
            </summary>
      <typeparam name="T">The type of <see cref="T:System.Exception" /> to throw.</typeparam>
      <param name="comment">A description of the reason for this expectation.</param>
      <param name="matchers">An array of matchers to match the exception string.</param>
    </member>
    <member name="T:NMock.Expects`1">
      <summary>
            This syntax class contains <see cref="T:NMock.Syntax.IMethodSyntax`1" /> properties that control
            the number of expectations added for the referenced <see cref="T:NMock.Mock`1" />.
            </summary>
      <typeparam name="T">The <c>class</c> or <c>interface</c> that is being mocked.</typeparam>
      <remarks>
        <see cref="T:NMock.Expects`1" /> is the return type of the main property used on a <see cref="T:NMock.Mock`1" /> instance.  You
            access it by typing <c>mockObject.Expects</c>.<para>The <see cref="T:NMock.Expects`1" /> class provides access to
            all other methods that help create expectations.</para></remarks>
    </member>
    <member name="M:NMock.Expects`1.#ctor(System.Object)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Expects`1" /> class with the specified type as the template.
            </summary>
      <param name="proxy">
      </param>
    </member>
    <member name="M:NMock.Expects`1.AtLeast(System.Int32)">
      <summary>
            Creates an expectation for at least <c>count</c> number of calls for the referenced member.
            </summary>
      <param name="count">The minimum number of calls expect</param>
      <returns>An <see cref="T:NMock.Syntax.IMethodSyntax`1" /> to reference the expected call.</returns>
    </member>
    <member name="M:NMock.Expects`1.AtMost(System.Int32)">
      <summary>
            Creates an expectation for at most <c>count</c> number of calls for the referenced member.
            </summary>
      <param name="count">The maximum number of calls expect</param>
      <returns>An <see cref="T:NMock.Syntax.IMethodSyntax`1" /> to reference the expected call.</returns>
    </member>
    <member name="M:NMock.Expects`1.Between(System.Int32,System.Int32)">
      <summary>
            Creates an expectation for a range from <c>minCount</c> to <c>maxCount</c> number of calls for the referenced member.
            </summary>
      <param name="minCount">The minimum number of expected calls.</param>
      <param name="maxCount">The maximum number of expected calls.</param>
      <returns>An <see cref="T:NMock.Syntax.IMethodSyntax`1" /> to reference the expected call.</returns>
    </member>
    <member name="M:NMock.Expects`1.Exactly(System.Int32)">
      <summary>
            Creates an expectation for exactly <c>count</c> number of calls for the referenced member.
            </summary>
      <param name="count">The exact number of calls expect</param>
      <returns>An <see cref="T:NMock.Syntax.IMethodSyntax`1" /> to reference the expected call.</returns>
    </member>
    <member name="P:NMock.Expects`1.AtLeastOne">
      <summary>
            Creates an expectation for at least one call of the referenced member.
            </summary>
    </member>
    <member name="P:NMock.Expects`1.AtMostOnce">
      <summary>
            Creates an expectation for at most one call of the referenced member.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:NMock.Expects`1.AtMostOne">
      <summary>
            Creates an expectation for at most one call of the referenced member.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:NMock.Expects`1.No">
      <summary>
            Specifies that there should be no calls to the referenced member.
            </summary>
    </member>
    <member name="P:NMock.Expects`1.One">
      <summary>
            Creates an expectation for one call of the referenced member.
            </summary>
    </member>
    <member name="T:NMock.Matchers.FieldMatcher">
      <summary>
            Matcher that checks whether the specified field of the actual object matches with the specified matcher. 
            </summary>
    </member>
    <member name="F:NMock.Matchers.FieldMatcher.fieldName">
      <summary>
            Name of the field to match against the <seealso cref="F:NMock.Matchers.FieldMatcher.valueMatcher" />.
            </summary>
    </member>
    <member name="F:NMock.Matchers.FieldMatcher.valueMatcher">
      <summary>
            The value <see cref="T:NMock.Matcher" /> used to match the field of the object under investigation.
            </summary>
    </member>
    <member name="M:NMock.Matchers.FieldMatcher.#ctor(System.String,NMock.Matcher)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Matchers.FieldMatcher" /> class.
            </summary>
      <param name="fieldName">Name of the field to match against the <paramref name="valueMatcher" />.</param>
      <param name="valueMatcher">The value matcher.</param>
    </member>
    <member name="M:NMock.Matchers.FieldMatcher.Matches(System.Object)">
      <summary>
            Matches the specified object to this matcher and returns whether it matches.
            </summary>
      <param name="o">The object to match.</param>
      <returns>Whether the object matches.</returns>
    </member>
    <member name="M:NMock.Matchers.FieldMatcher.DescribeTo(System.IO.TextWriter)">
      <summary>
            Describes this matcher.
            </summary>
      <param name="writer">The text writer to which the description is added.</param>
    </member>
    <member name="T:NMock.Matchers.ComparisonMatcher">
      <summary>
            Matcher that checks a value against upper and lower bounds.
            </summary>
    </member>
    <member name="F:NMock.Matchers.ComparisonMatcher.maxComparisonResult">
      <summary>
            Stores the maximum comparison result for a successful match.
            </summary>
    </member>
    <member name="F:NMock.Matchers.ComparisonMatcher.minComparisonResult">
      <summary>
            Stores the minimum comparison result for a successful match.
            </summary>
    </member>
    <member name="F:NMock.Matchers.ComparisonMatcher.value">
      <summary>
            Stores the value to be compared.
            </summary>
    </member>
    <member name="M:NMock.Matchers.ComparisonMatcher.#ctor(System.IComparable,System.Int32,System.Int32)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Matchers.ComparisonMatcher" /> class.
            </summary>
      <param name="value">The value to compare.</param>
      <param name="comparisonResult1">The first allowed comparison result (result of value.CompareTo(other)).</param>
      <param name="comparisonResult2">The second allowed comparison result (result of value.CompareTo(other)).</param>
      <exception cref="T:System.ArgumentException">Thrown when one value is -1 and the other is 1.</exception>
    </member>
    <member name="M:NMock.Matchers.ComparisonMatcher.Matches(System.Object)">
      <summary>
            Matches the specified object to this matcher and returns whether it matches.
            </summary>
      <param name="o">The object to match.</param>
      <returns>Whether the object compared to the value resulted in either of both specified comparison results.</returns>
    </member>
    <member name="M:NMock.Matchers.ComparisonMatcher.DescribeTo(System.IO.TextWriter)">
      <summary>
            Describes this matcher.
            </summary>
      <param name="writer">The text writer to which the description is added.</param>
    </member>
    <member name="T:NMock.Syntax.IAutoValueSyntax`1">
      <summary>
            Extends <see cref="T:NMock.Syntax.IValueSyntax" /> by adding other syntax methods.
            </summary>
    </member>
    <member name="M:NMock.Syntax.IAutoValueSyntax`1.ToAnything">
      <summary>
            Creates an expectation that this property can be set to any value.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NMock.Syntax.IAutoValueSyntax`1.To(`0)">
      <summary>
            Creates an expectation that the property will be set to this value.
            </summary>
      <param name="equalValue">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:NMock.Proxy.Castle.CastleMockObjectFactory">
      <summary>
            Class that creates mocks for interfaces and classes (virtual members only) using the
            Castle proxy generator.
            </summary>
    </member>
    <member name="F:NMock.Proxy.Castle.CastleMockObjectFactory.CachedProxyTypes">
      <summary>
            A collection of types
            </summary>
    </member>
    <member name="M:NMock.Proxy.Castle.CastleMockObjectFactory.#ctor">
      <summary>
            Initializes a new instance of a <see cref="T:NMock.Proxy.Castle.CastleMockObjectFactory" /></summary>
    </member>
    <member name="M:NMock.Proxy.Castle.CastleMockObjectFactory.#ctor(System.Boolean)">
      <summary>
            Initializes a new instance of a <see cref="T:NMock.Proxy.Castle.CastleMockObjectFactory" /></summary>
      <param name="usePersistentProxyBuilder">A value indicating if the ProxyBuilder should be persistent</param>
    </member>
    <member name="M:NMock.Proxy.Castle.CastleMockObjectFactory.CreateMock(NMock.MockFactory,NMock.Proxy.CompositeType,System.String,NMock.MockStyle,System.Object[])">
      <summary>
            Creates a mock of the specified type(s).
            </summary>
      <param name="mockFactory">The mockFactory used to create this mock instance.</param>
      <param name="typesToMock">The type(s) to include in the mock.</param>
      <param name="name">The name to use for the mock instance.</param>
      <param name="mockStyle">The behaviour of the mock instance when first created.</param>
      <param name="constructorArgs">Constructor arguments for the class to be mocked. Only valid if mocking a class type.</param>
      <returns>A mock instance of the specified type(s).</returns>
    </member>
    <member name="T:NMock.Actions.ReturnAction`1">
      <summary>
            Action that sets the result value on an invocation.
            </summary>
    </member>
    <member name="F:NMock.Actions.ReturnAction`1._result">
      <summary>
            Stores the result to set on the invocation as the return value.
            </summary>
    </member>
    <member name="M:NMock.Actions.ReturnAction`1.#ctor(`0)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Actions.ReturnAction" /> class.
            </summary>
      <param name="result">The result to set on the invocation as the return value.</param>
    </member>
    <member name="M:NMock.Actions.ReturnAction`1.Invoke(NMock.Monitoring.Invocation)">
      <summary>
            Invokes this object. Sets the result value of the invocation.
            </summary>
      <param name="invocation">The invocation.</param>
    </member>
    <member name="M:NMock.Actions.ReturnAction`1.DescribeTo(System.IO.TextWriter)">
      <summary>
            Describes this object.
            </summary>
      <param name="writer">The text writer the description is added to.</param>
    </member>
    <member name="P:NMock.Actions.ReturnAction`1.ReturnType">
      <summary>
            Gets the type of the template parameter <typeparamref name="T" />.
            </summary>
    </member>
    <member name="T:NMock.Actions.ReturnAction">
      <summary>
            Action that sets the result value on an invocation.
            </summary>
    </member>
    <member name="M:NMock.Actions.ReturnAction.#ctor(System.Object)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Actions.ReturnAction" /> class.
            </summary>
      <param name="result">The result to set on the invocation as the return value.</param>
    </member>
    <member name="T:NMock.Verify">
      <summary>
            Verify that a condition is met.
            </summary>
    </member>
    <member name="M:NMock.Verify.That(System.Object,NMock.Matcher,System.String,System.Object[])">
      <summary>
            Verifies that the <paramref name="actualValue" /> is matched by the <paramref name="matcher" />.
            </summary>
      <param name="actualValue">The actual value to match.</param>
      <param name="matcher">The matcher.</param>
      <param name="message">The error message.</param>
      <param name="formatArgs">The format args for the error message.</param>
      <exception cref="T:NMock.ExpectationException">Thrown if value does not match.</exception>
    </member>
    <member name="M:NMock.Verify.That(System.Object,NMock.Matcher)">
      <summary>
            Verifies that the <paramref name="actualValue" /> is matched by the <paramref name="matcher" />.
            </summary>
      <param name="actualValue">The actual value.</param>
      <param name="matcher">The matcher.</param>
      <exception cref="T:NMock.ExpectationException">Thrown if value does not match.</exception>
    </member>
    <member name="M:NMock.Verify.WriteDescriptionOfFailedMatch(System.IO.TextWriter,System.Object,NMock.Matcher)">
      <summary>
            Writes the description of a failed match to the specified <paramref name="writer" />.
            </summary>
      <param name="writer">The <see cref="T:System.IO.TextWriter" /> where the description is written to.</param>
      <param name="actualValue">The actual value to be written.</param>
      <param name="matcher">The matcher which is used for the expected value to be written.</param>
    </member>
    <member name="T:NMock.Return">
      <summary>
            Provides shortcuts to <see cref="T:NMock.IAction" />s that return values
            </summary>
    </member>
    <member name="M:NMock.Return.Value(System.Object)">
      <summary>
            Returns the specified value as an object.
            </summary>
      <param name="result">The value to return.</param>
      <returns>An action that returns the specified value.</returns>
    </member>
    <member name="M:NMock.Return.Value``1(``0)">
      <summary>
            Returns the specified value as a strongly-typed value.
            </summary>
      <param name="result">The value to return.</param>
      <returns>An action that returns the specified value.</returns>
    </member>
    <member name="M:NMock.Return.Value``1(System.Func{``0})">
      <summary>
            Calls a method that will provide the return value.
            </summary>
      <typeparam name="T">The type that needs to be returned.</typeparam>
      <param name="delegate">The method that will provide the return value. (anonymous or otherwise)</param>
      <returns>An action that will provide the return value.</returns>
    </member>
    <member name="M:NMock.Return.Value``1(System.Func{NMock.Monitoring.Invocation,``0})">
      <summary>
            Calls a method that will provide the return value.
            </summary>
      <typeparam name="T">The type that needs to be returned.</typeparam>
      <param name="delegate">The method that will provide the return value. (anonymous or otherwise)</param>
      <returns>An action that will provide the return value.</returns>
    </member>
    <member name="M:NMock.Return.Queue``1(System.Collections.Generic.Queue{``0})">
      <summary>
            Specifies a queue of return values to be used for each call to the expectation.
            </summary>
      <typeparam name="T">The type that needs to be returned.</typeparam>
      <param name="queue">The <see cref="M:NMock.Return.Queue``1(System.Collections.Generic.Queue{``0})" /> of items to be returned.</param>
      <returns>An action that will return one value each time the expectation is met.</returns>
    </member>
    <member name="M:NMock.Return.CloneOf(System.ICloneable)">
      <summary>
            Returns a clone as method return value.
            </summary>
      <param name="prototype">The prototype to clone.</param>
      <returns>Action defining the return value of a method.</returns>
    </member>
    <member name="M:NMock.Return.OutValue(System.String,System.Object)">
      <summary>
            Defines the value returned by an out parameter.
            </summary>
      <param name="parameterName">Name of the parameter.</param>
      <param name="value">The value to return.</param>
      <returns>Action defining the value of an out parameter.</returns>
    </member>
    <member name="M:NMock.Return.OutValue(System.Int32,System.Object)">
      <summary>
            Defines the value returned by an out parameter.
            </summary>
      <param name="parameterIndex">Index of the parameter.</param>
      <param name="value">The value to return.</param>
      <returns>Action defining the value of an out parameter.</returns>
    </member>
    <member name="T:NMock.GetArguments">
      <summary>
            short cut to initialize GetArgumentAction
            </summary>
    </member>
    <member name="M:NMock.GetArguments.WhenCalled(System.Action{NMock.Monitoring.ParameterList})">
      <summary>
            Create a GetArgumentAction to get arments of invoked method
            </summary>
      <param name="handler">delegate used to get argments of executed method</param>
      <returns>
      </returns>
    </member>
    <member name="T:NMock.Matchers.OrMatcher">
      <summary>
            Matcher that combines two matcher with a logically or.
            </summary>
    </member>
    <member name="M:NMock.Matchers.OrMatcher.#ctor(NMock.Matcher,NMock.Matcher)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Matchers.OrMatcher" /> class.
            </summary>
      <param name="left">The left operand.</param>
      <param name="right">The right operand.</param>
    </member>
    <member name="M:NMock.Matchers.OrMatcher.Matches(System.Object)">
      <summary>
            Matches the specified object to this matcher and returns whether it matches.
            </summary>
      <param name="o">The object to match.</param>
      <returns>Whether the object matches one of the two combined matchers.</returns>
    </member>
    <member name="M:NMock.Matchers.OrMatcher.DescribeTo(System.IO.TextWriter)">
      <summary>
            Describes this matcher.
            </summary>
      <param name="writer">The text writer to which the description is added.</param>
    </member>
    <member name="T:NMock.Matchers.GenericMethodTypeParametersMatcher">
      <summary>
            Matcher that checks whether parameters of a method match with the specified list of matchers.
            </summary>
    </member>
    <member name="F:NMock.Matchers.GenericMethodTypeParametersMatcher._typeMatchers">
      <summary>
            An ordered list of type <see cref="T:NMock.Matcher" />'s each matching a single method argument.
            </summary>
    </member>
    <member name="M:NMock.Matchers.GenericMethodTypeParametersMatcher.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Matchers.GenericMethodTypeParametersMatcher" /> class and specifies no generic types.
            </summary>
    </member>
    <member name="M:NMock.Matchers.GenericMethodTypeParametersMatcher.#ctor(NMock.Matcher[])">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Matchers.GenericMethodTypeParametersMatcher" /> class.
            </summary>
      <param name="typeMatchers">The value matchers. This is an ordered list of matchers, each matching a single method argument.</param>
    </member>
    <member name="M:NMock.Matchers.GenericMethodTypeParametersMatcher.#ctor(System.Type[])">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Matchers.GenericMethodTypeParametersMatcher" /> class and specifies the types to match.
            </summary>
      <param name="genericTypeParameters">The types to match.  (Typically a result of the <see cref="M:System.Reflection.MethodInfo.GetGenericArguments" /> method.</param>
    </member>
    <member name="M:NMock.Matchers.GenericMethodTypeParametersMatcher.Matches(System.Object)">
      <summary>
            Matches the specified object to this matcher and returns whether it matches.
            </summary>
      <param name="o">The object to match.</param>
      <returns>Whether the object is an <see cref="T:NMock.Monitoring.Invocation" /> and all method arguments match their corresponding matcher.</returns>
    </member>
    <member name="M:NMock.Matchers.GenericMethodTypeParametersMatcher.DescribeTo(System.IO.TextWriter)">
      <summary>
            Describes this matcher.
            </summary>
      <param name="writer">The text writer to which the description is added.</param>
    </member>
    <member name="M:NMock.Matchers.GenericMethodTypeParametersMatcher.WriteListOfMatchers(System.Int32,System.IO.TextWriter)">
      <summary>
            Writes the list of matchers to a <see cref="T:System.IO.TextWriter" />.
            </summary>
      <param name="listLength">Length of the list.</param>
      <param name="writer">The writer.</param>
    </member>
    <member name="M:NMock.Matchers.GenericMethodTypeParametersMatcher.MatchesTypes(System.Reflection.MethodInfo)">
      <summary>
            Determines whether the arguments of the invocation matches the initial arguments.
            </summary>
      <param name="methodInfo">The invocation to match against the initial arguments.</param>
      <returns>
            Returns true if invocation matches the initial arguments; false otherwise.
            </returns>
    </member>
    <member name="M:NMock.Matchers.GenericMethodTypeParametersMatcher.MatchesTypeValues(System.Reflection.MethodBase)">
      <summary>
            Determines whether all argument types of the generic method matches the invocation.
            </summary>
      <param name="methodInfo">The invocation to match against the initial argument types.</param>
      <returns>
            Returns true if invocation types matches the inital argument types; false otherwise.
            </returns>
    </member>
    <member name="T:NMock.Matchers.DescriptionOverride">
      <summary>
            Matcher that is used to change the description the wrapped matcher.
            </summary>
    </member>
    <member name="M:NMock.Matchers.DescriptionOverride.#ctor(System.String,NMock.Matcher)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Matchers.DescriptionOverride" /> class.
            </summary>
      <param name="description">The new description for the wrapped matcher.</param>
      <param name="otherMatcher">The matcher to wrap.</param>
    </member>
    <member name="M:NMock.Matchers.DescriptionOverride.Matches(System.Object)">
      <summary>
            Matches the specified object to this matcher and returns whether it matches.
            </summary>
      <param name="o">The object to match.</param>
      <returns>Whether the wrapped matcher matches.</returns>
    </member>
    <member name="P:NMock.Matchers.DescriptionOverride.WrappedMatcher">
      <summary>
            Stores the matcher to wrap.
            </summary>
    </member>
    <member name="T:NMock.Matchers.AlwaysMatcher">
      <summary>
            A matcher that will always or never match independent of the value matched but depending on how it is initialized.
            </summary>
    </member>
    <member name="M:NMock.Matchers.AlwaysMatcher.#ctor(System.Boolean,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Matchers.AlwaysMatcher" /> class.
            </summary>
      <param name="matches">if set to <c>true</c> the matcher will always match, otherwise it will never match.</param>
      <param name="description">The description which will be printed out when calling <see cref="M:NMock.Matcher.DescribeTo(System.IO.TextWriter)" />.</param>
    </member>
    <member name="M:NMock.Matchers.AlwaysMatcher.Matches(System.Object)">
      <summary>
            Matches the specified object to this matcher and returns whether it matches.
            </summary>
      <param name="o">The object to match.</param>
      <returns>Returns whether the object matches.</returns>
    </member>
    <member name="T:NMock.Actions.ResultSynthesizer">
      <summary>
            Responsible for handling the results of an invocation.
            </summary>
    </member>
    <member name="F:NMock.Actions.ResultSynthesizer.defaultResults">
      <summary>
            Stores the default results.
            </summary>
    </member>
    <member name="F:NMock.Actions.ResultSynthesizer._results">
      <summary>
            Stores the results.
            </summary>
    </member>
    <member name="M:NMock.Actions.ResultSynthesizer.SetResult(System.Type,System.Object)">
      <summary>
            Sets the result of the specified <paramref name="returnType" />.
            </summary>
      <param name="returnType">The type to be returned as a result.</param>
      <param name="result">The result to be set.</param>
    </member>
    <member name="M:NMock.Actions.ResultSynthesizer.NewEmptyArray(System.Type)">
      <summary>
            Gets a new the empty array of the specified <paramref name="arrayType" />.
            </summary>
      <param name="arrayType">Type of the array to be returned.</param>
      <returns>
            Returns a new empty array of the specified <paramref name="arrayType" />.
            </returns>
    </member>
    <member name="T:NMock.Actions.ThrowAction">
      <summary>
            Action that sets the exception of an invocation.
            </summary>
    </member>
    <member name="F:NMock.Actions.ThrowAction.exception">
      <summary>
            Stores the exception to be thrown.
            </summary>
    </member>
    <member name="M:NMock.Actions.ThrowAction.#ctor(System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Actions.ThrowAction" /> class.
            </summary>
      <param name="exception">The exception.</param>
    </member>
    <member name="T:NMock.Internal.StubMockStyleDictionary">
      <summary>
            Provides functionality to map stubs and specific types of a stub to mock styles.
            </summary>
    </member>
    <member name="T:NMock.Internal.StubMockStyleDictionary.Key">
      <summary>
            Key into the <see cref="F:NMock.Internal.StubMockStyleDictionary.mockStyleForType" /> dictionary.
            </summary>
    </member>
    <member name="M:NMock.Internal.StubMockStyleDictionary.Key.#ctor(NMock.IMockObject,System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Internal.StubMockStyleDictionary.Key" /> class.
            </summary>
      <param name="mock">The mock object.</param>
      <param name="nestedMockType">Type of the nested mock.</param>
    </member>
    <member name="M:NMock.Internal.StubMockStyleDictionary.Key.Equals(System.Object)">
      <summary>
            Whether this instance equals the specified other.
            </summary>
      <param name="other">The other to compare to.</param>
      <returns>A value indicating whether both instances are equal.</returns>
    </member>
    <member name="M:NMock.Internal.StubMockStyleDictionary.Key.Equals(NMock.Internal.StubMockStyleDictionary.Key)">
      <summary>
            Whether this instance equals the specified other.
            </summary>
      <param name="other">The other to compare to.</param>
      <returns>A value indicating whether both instances are equal.</returns>
    </member>
    <member name="M:NMock.Internal.StubMockStyleDictionary.Key.GetHashCode">
      <summary>
            Serves as a hash function for a particular type.
            </summary>
      <returns>
            A hash code for the current <see cref="T:System.Object" />.
            </returns>
    </member>
    <member name="P:NMock.Internal.StubMockStyleDictionary.Key.Mock">
      <summary>
            Gets the mock.
            </summary>
      <value>The mock object.</value>
    </member>
    <member name="P:NMock.Internal.StubMockStyleDictionary.Key.NestedMockType">
      <summary>
            Gets the type of the nested mock.
            </summary>
      <value>The type of the nested mock.</value>
    </member>
    <member name="F:NMock.Internal.StubMockStyleDictionary.mockStyleForStub">
      <summary>
            holds mappings from stub to mock style (holds for all types unless there is a mapping defined in <see cref="F:NMock.Internal.StubMockStyleDictionary.mockStyleForType" />.
            </summary>
    </member>
    <member name="F:NMock.Internal.StubMockStyleDictionary.mockStyleForType">
      <summary>
            holds mappings from stub.type to mock style.
            </summary>
    </member>
    <member name="P:NMock.Internal.StubMockStyleDictionary.Item(NMock.IMockObject)">
      <summary>
            Gets or sets the mock style for the specified mock.
            </summary>
      <param name="mock">the mock object</param>
      <value>mock style. null if no value defined.</value>
    </member>
    <member name="P:NMock.Internal.StubMockStyleDictionary.Item(NMock.IMockObject,System.Type)">
      <summary>
            Gets or sets the mock style for the specified mock and type.
            </summary>
      <param name="mock">the mock object</param>
      <param name="nestedMockType">the type of the nested mock.</param>
      <value>mock style. null if no value defined.</value>
    </member>
    <member name="T:NMock.Matchers.DelegateMatcher">
      <summary>
            Represents a delegate in an expectation that can be matched
            </summary>
    </member>
    <member name="M:NMock.Matchers.DelegateMatcher.#ctor(System.MulticastDelegate)">
      <summary>
            Initializes an instance of this class with a <see cref="T:System.MulticastDelegate" /> to match.
            </summary>
      <param name="delegate">
      </param>
    </member>
    <member name="M:NMock.Matchers.DelegateMatcher.Matches(System.Object)">
      <summary>
            Determines if this delegate matches the specified parameter
            </summary>
      <param name="o">The delegate to match</param>
      <returns>true if the delegates match, false if the object is null or does not match</returns>
    </member>
    <member name="T:NMock.ExpectationException">
      <summary>
            Exception representing an expectation exception.
            </summary>
    </member>
    <member name="M:NMock.ExpectationException.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.ExpectationException" /> class.
            </summary>
    </member>
    <member name="M:NMock.ExpectationException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.ExpectationException" /> class.
            </summary>
      <param name="message">The message.</param>
    </member>
    <member name="M:NMock.ExpectationException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.ExpectationException" /> class.
            </summary>
      <param name="message">The message.</param>
      <param name="innerException">The inner exception.</param>
    </member>
    <member name="M:NMock.ExpectationException.ToString">
      <summary>
            Creates and returns a string representation of the current exception.
            </summary>
      <returns>
            A string representation of the current exception.
            </returns>
    </member>
    <member name="T:NMock.UnexpectedInvocationException">
      <summary>
            Represents an unexpected action during the course of exercising a unit test
            </summary>
    </member>
    <member name="M:NMock.UnexpectedInvocationException.#ctor(NMock.MockFactory,NMock.Monitoring.Invocation,NMock.IExpectationList,System.String)">
      <summary>
            Constructs a <see cref="T:NMock.UnexpectedInvocationException" /> with the given parameters.
            </summary>
      <param name="factory">The MockFactory that threw this exception</param>
      <param name="invocation">The unexpected invocation</param>
      <param name="expectations">The expectations collection to describe</param>
      <param name="message">A message to help the user understand what was unexpected</param>
    </member>
    <member name="P:NMock.UnexpectedInvocationException.Message">
      <summary>
            Gets the exception's message
            </summary>
    </member>
    <member name="T:NMock.UnmetExpectationException">
      <summary>
            Represents an expectation that was not met after <see cref="M:NMock.MockFactory.VerifyAllExpectationsHaveBeenMet" /> has been called
            </summary>
    </member>
    <member name="M:NMock.UnmetExpectationException.#ctor(System.String)">
      <summary>
            Initializes the exception with a message
            </summary>
      <param name="message">
      </param>
    </member>
    <member name="M:NMock.UnmetExpectationException.#ctor(System.String,System.Exception)">
      <summary>
            Wraps an exception and provides a message
            </summary>
      <param name="message">
      </param>
      <param name="innerException">
      </param>
    </member>
    <member name="T:NMock.IncompleteExpectationException">
      <summary>
            Represents an expectation that was not completely filled out
            </summary>
    </member>
    <member name="M:NMock.IncompleteExpectationException.#ctor(System.String)">
      <summary>
            Initializes an exception with a message
            </summary>
      <param name="message">
      </param>
    </member>
    <member name="T:NMock.Constants">
      <summary>
            Defines public constants
            </summary>
    </member>
    <member name="F:NMock.Constants.InternalsVisibleToNMock">
      <summary>
            A string that represents the name and Public Key of the NMock assembly.
            </summary>
      <remarks>
            Use this field in your assembly when NMock needs access to internal types
            </remarks>
      <example>
            [assembly: InternalsVisibleTo(NMock.Constants.InternalsVisibleTo)]
            </example>
      <seealso cref="T:System.Runtime.CompilerServices.InternalsVisibleToAttribute" />
    </member>
    <member name="F:NMock.Constants.InternalsVisibleToDynamicProxy">
      <summary>
            A string that represents the name and Public Key of the DynamicProxyGenAssembly assembly.
            </summary>
      <remarks>
            Use this field in your assembly when NMock needs access to internal types
            </remarks>
      <example>
            [assembly: InternalsVisibleTo(NMock.Constants.InternalsVisibleTo)]
            </example>
      <seealso cref="T:System.Runtime.CompilerServices.InternalsVisibleToAttribute" />
    </member>
    <member name="F:NMock.Constants.NMockPublicKey">
      <summary>
            The NMock Public Key string.
            </summary>
      <remarks>
            This string is used internally to reference the public key.
            </remarks>
    </member>
    <member name="T:NMock.Actions.SignalAction">
      <summary>
            Action that signals an event.
            You can use this action to synchronize threads when an expectation is invoked.
            </summary>
    </member>
    <member name="F:NMock.Actions.SignalAction.signal">
      <summary>
            Stores the wait handle to be signalled.
            </summary>
    </member>
    <member name="M:NMock.Actions.SignalAction.#ctor(System.Threading.EventWaitHandle)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Actions.SignalAction" /> class.
            </summary>
      <param name="signal">The signal.</param>
    </member>
    <member name="P:NMock.Actions.SignalAction.Signal">
      <summary>
            Gets the signal.
            You can use this signal to wait for this action beeing invoked.
            </summary>
      <value>The signal.</value>
    </member>
    <member name="T:Castle.Core.Pair`2">
      <summary>
            General purpose class to represent a standard pair of values. 
            </summary>
      <typeparam name="TFirst">Type of the first value</typeparam>
      <typeparam name="TSecond">Type of the second value</typeparam>
    </member>
    <member name="M:Castle.Core.Pair`2.#ctor(`0,`1)">
      <summary>
            Constructs a pair with its values
            </summary>
      <param name="first">
      </param>
      <param name="second">
      </param>
    </member>
    <member name="T:Castle.Core.Logging.ILoggerFactory">
      <summary>
              Manages the instantiation of <see cref="T:Castle.Core.Logging.ILogger" />s.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.ILoggerFactory.Create(System.Type)">
      <summary>
              Creates a new logger, getting the logger name from the specified type.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.ILoggerFactory.Create(System.String)">
      <summary>
              Creates a new logger.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.ILoggerFactory.Create(System.Type,Castle.Core.Logging.LoggerLevel)">
      <summary>
              Creates a new logger, getting the logger name from the specified type.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.ILoggerFactory.Create(System.String,Castle.Core.Logging.LoggerLevel)">
      <summary>
              Creates a new logger.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.AbstractLoggerFactory.GetConfigFile(System.String)">
      <summary>
              Gets the configuration file.
            </summary>
      <param name="fileName">i.e. log4net.config</param>
      <returns>
      </returns>
    </member>
    <member name="T:Castle.Core.Logging.NullLogFactory">
      <summary>
            NullLogFactory used when logging is turned off.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.NullLogFactory.Create(System.String)">
      <summary>
              Creates an instance of ILogger with the specified name.
            </summary>
      <param name="name">Name.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Core.Logging.NullLogFactory.Create(System.String,Castle.Core.Logging.LoggerLevel)">
      <summary>
              Creates an instance of ILogger with the specified name and LoggerLevel.
            </summary>
      <param name="name">Name.</param>
      <param name="level">Level.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.DynamicProxy.IProxyTargetAccessor.DynProxyGetTarget">
      <summary>
              Get the proxy target (note that null is a valid target!)
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.DynamicProxy.IProxyTargetAccessor.GetInterceptors">
      <summary>
              Gets the interceptors for the proxy
            </summary>
      <returns>
      </returns>
    </member>
    <member name="T:Castle.DynamicProxy.IProxyBuilder">
      <summary>
              Abstracts the implementation of proxy type construction.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.IProxyBuilder.CreateClassProxyType(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)">
      <summary>
              Creates a proxy type for given <paramref name="classToProxy" />, implementing <paramref name="additionalInterfacesToProxy" />, using <paramref name="options" /> provided.
            </summary>
      <param name="classToProxy">The class type to proxy.</param>
      <param name="additionalInterfacesToProxy">Additional interface types to proxy.</param>
      <param name="options">The proxy generation options.</param>
      <returns>The generated proxy type.</returns>
      <remarks>
              Implementers should return a proxy type for the specified class and interfaces.
              Additional interfaces should be only 'mark' interfaces, that is, they should work like interface proxy without target. (See <see cref="M:Castle.DynamicProxy.IProxyBuilder.CreateInterfaceProxyTypeWithoutTarget(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)" /> method.)
            </remarks>
      <exception cref="T:Castle.DynamicProxy.Generators.GeneratorException">Thrown when <paramref name="classToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is a generic type definition.</exception>
      <exception cref="T:Castle.DynamicProxy.Generators.GeneratorException">Thrown when <paramref name="classToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is not public.
              Note that to avoid this exception, you can mark offending type internal, and define <see cref="T:System.Runtime.CompilerServices.InternalsVisibleToAttribute" /> 
              pointing to Castle Dynamic Proxy assembly, in assembly containing that type, if this is appropriate.</exception>
      <seealso cref="T:Castle.DynamicProxy.Generators.ClassProxyGenerator" />
    </member>
    <member name="M:Castle.DynamicProxy.IProxyBuilder.CreateInterfaceProxyTypeWithTarget(System.Type,System.Type[],System.Type,Castle.DynamicProxy.ProxyGenerationOptions)">
      <summary>
              Creates a proxy type that proxies calls to <paramref name="interfaceToProxy" /> members on <paramref name="targetType" />, implementing <paramref name="additionalInterfacesToProxy" />, using <paramref name="options" /> provided.
            </summary>
      <param name="interfaceToProxy">The interface type to proxy.</param>
      <param name="additionalInterfacesToProxy">Additional interface types to proxy.</param>
      <param name="targetType">Type implementing <paramref name="interfaceToProxy" /> on which calls to the interface members should be intercepted.</param>
      <param name="options">The proxy generation options.</param>
      <returns>The generated proxy type.</returns>
      <remarks>
              Implementers should return a proxy type for the specified interface that 'proceeds' executions to the specified target.
              Additional interfaces should be only 'mark' interfaces, that is, they should work like interface proxy without target. (See <see cref="M:Castle.DynamicProxy.IProxyBuilder.CreateInterfaceProxyTypeWithoutTarget(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)" /> method.)
            </remarks>
      <exception cref="T:Castle.DynamicProxy.Generators.GeneratorException">Thrown when <paramref name="interfaceToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is a generic type definition.</exception>
      <exception cref="T:Castle.DynamicProxy.Generators.GeneratorException">Thrown when <paramref name="interfaceToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is not public.
              Note that to avoid this exception, you can mark offending type internal, and define <see cref="T:System.Runtime.CompilerServices.InternalsVisibleToAttribute" /> 
              pointing to Castle Dynamic Proxy assembly, in assembly containing that type, if this is appropriate.</exception>
      <seealso cref="T:Castle.DynamicProxy.Generators.InterfaceProxyWithTargetGenerator" />
    </member>
    <member name="M:Castle.DynamicProxy.IProxyBuilder.CreateInterfaceProxyTypeWithTargetInterface(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)">
      <summary>
              Creates a proxy type for given <paramref name="interfaceToProxy" /> and <parmaref name="additionalInterfacesToProxy" /> that delegates all calls to the provided interceptors and allows interceptors to switch the actual target of invocation.
            </summary>
      <param name="interfaceToProxy">The interface type to proxy.</param>
      <param name="additionalInterfacesToProxy">Additional interface types to proxy.</param>
      <param name="options">The proxy generation options.</param>
      <returns>The generated proxy type.</returns>
      <remarks>
              Implementers should return a proxy type for the specified interface(s) that delegate all executions to the specified interceptors
              and uses an instance of the interface as their targets (i.e. <see cref="P:Castle.DynamicProxy.IInvocation.InvocationTarget" />), rather than a class. All <see cref="T:Castle.DynamicProxy.IInvocation" /> classes should then implement <see cref="T:Castle.DynamicProxy.IChangeProxyTarget" /> interface,
              to allow interceptors to switch invocation target with instance of another type implementing called interface.
            </remarks>
      <exception cref="T:Castle.DynamicProxy.Generators.GeneratorException">Thrown when <paramref name="interfaceToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is a generic type definition.</exception>
      <exception cref="T:Castle.DynamicProxy.Generators.GeneratorException">Thrown when <paramref name="interfaceToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is not public.
              Note that to avoid this exception, you can mark offending type internal, and define <see cref="T:System.Runtime.CompilerServices.InternalsVisibleToAttribute" /> 
              pointing to Castle Dynamic Proxy assembly, in assembly containing that type, if this is appropriate.</exception>
      <seealso cref="T:Castle.DynamicProxy.Generators.InterfaceProxyWithTargetInterfaceGenerator" />
    </member>
    <member name="M:Castle.DynamicProxy.IProxyBuilder.CreateInterfaceProxyTypeWithoutTarget(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)">
      <summary>
              Creates a proxy type for given <paramref name="interfaceToProxy" /> that delegates all calls to the provided interceptors.
            </summary>
      <param name="interfaceToProxy">The interface type to proxy.</param>
      <param name="additionalInterfacesToProxy">Additional interface types to proxy.</param>
      <param name="options">The proxy generation options.</param>
      <returns>The generated proxy type.</returns>
      <remarks>
              Implementers should return a proxy type for the specified interface and additional interfaces that delegate all executions to the specified interceptors.
            </remarks>
      <exception cref="T:Castle.DynamicProxy.Generators.GeneratorException">Thrown when <paramref name="interfaceToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is a generic type definition.</exception>
      <exception cref="T:Castle.DynamicProxy.Generators.GeneratorException">Thrown when <paramref name="interfaceToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is not public.
              Note that to avoid this exception, you can mark offending type internal, and define <see cref="T:System.Runtime.CompilerServices.InternalsVisibleToAttribute" /> 
              pointing to Castle Dynamic Proxy assembly, in assembly containing that type, if this is appropriate.</exception>
      <seealso cref="T:Castle.DynamicProxy.Generators.InterfaceProxyWithoutTargetGenerator" />
    </member>
    <member name="P:Castle.DynamicProxy.IProxyBuilder.Logger">
      <summary>
              Gets or sets the <see cref="T:Castle.Core.Logging.ILogger" /> that this <see cref="T:Castle.DynamicProxy.ProxyGenerator" /> logs to.
            </summary>
    </member>
    <member name="P:Castle.DynamicProxy.IProxyBuilder.ModuleScope">
      <summary>
              Gets the <see cref="P:Castle.DynamicProxy.IProxyBuilder.ModuleScope" /> associated with this builder.
            </summary>
      <value>The module scope associated with this builder.</value>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.IDynamicValue">
      <summary>
            Contract for dynamic value resolution.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.IDynamicValue`1">
      <summary>
            Contract for typed dynamic value resolution.
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="T:Castle.Core.Internal.AttributesUtil">
      <summary>
              Helper class for retrieving attributes.
            </summary>
    </member>
    <member name="M:Castle.Core.Internal.AttributesUtil.GetAttribute``1(System.Reflection.ICustomAttributeProvider)">
      <summary>
              Gets the attribute.
            </summary>
      <param name="member">The member.</param>
      <returns>The member attribute.</returns>
    </member>
    <member name="M:Castle.Core.Internal.AttributesUtil.GetAttributes``1(System.Reflection.ICustomAttributeProvider)">
      <summary>
              Gets the attributes. Does not consider inherited attributes!
            </summary>
      <param name="member">The member.</param>
      <returns>The member attributes.</returns>
    </member>
    <member name="M:Castle.Core.Internal.AttributesUtil.GetTypeAttribute``1(System.Type)">
      <summary>
              Gets the type attribute.
            </summary>
      <param name="type">The type.</param>
      <returns>The type attribute.</returns>
    </member>
    <member name="M:Castle.Core.Internal.AttributesUtil.GetTypeAttributes``1(System.Type)">
      <summary>
              Gets the type attributes.
            </summary>
      <param name="type">The type.</param>
      <returns>The type attributes.</returns>
    </member>
    <member name="M:Castle.Core.Internal.AttributesUtil.GetTypeConverter(System.Reflection.MemberInfo)">
      <summary>
              Gets the type converter.
            </summary>
      <param name="member">The member.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Core.Internal.AttributesUtil.HasAttribute``1(System.Reflection.ICustomAttributeProvider)">
      <summary>
              Gets the attribute.
            </summary>
      <param name="member">The member.</param>
      <returns>The member attribute.</returns>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.IDictionaryBehavior">
      <summary>
            Defines the contract for customizing dictionary access.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IDictionaryBehavior.Copy">
      <summary>
            Copies the dictionary behavior.
            </summary>
      <returns>null if should not be copied.  Otherwise copy.</returns>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.IDictionaryBehavior.ExecutionOrder">
      <summary>
            Determines relative order to apply related behaviors.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.IDictionaryKeyBuilder">
      <summary>
            Defines the contract for building typed dictionary keys.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IDictionaryKeyBuilder.GetKey(Castle.Components.DictionaryAdapter.IDictionaryAdapter,System.String,Castle.Components.DictionaryAdapter.PropertyDescriptor)">
      <summary>
            Builds the specified key.
            </summary>
      <param name="dictionaryAdapter">The dictionary adapter.</param>
      <param name="key">The current key.</param>
      <param name="property">The property.</param>
      <returns>The updated key</returns>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.IDictionaryEdit">
      <summary>
            Contract for editing the Dictionary adapter.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.IDictionaryNotify">
      <summary>
            Contract for managing Dictionary adapter notifications.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.IDictionaryValidate">
      <summary>
            Contract for validating Dictionary adapter.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.IDictionaryCreate">
      <summary>
            Contract for creating additional Dictionary adapters.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.IDictionaryAdapter">
      <summary>
            Contract for manipulating the Dictionary adapter.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.GroupAttribute">
      <summary>
            Assigns a property to a group.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.GroupAttribute.#ctor(System.Object)">
      <summary>
            Constructs a group assignment.
            </summary>
      <param name="group">The group name.</param>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.GroupAttribute.#ctor(System.Object[])">
      <summary>
            Constructs a group assignment.
            </summary>
      <param name="group">The group name.</param>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.GroupAttribute.Group">
      <summary>
            Gets the group the property is assigned to.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.DictionaryBehaviorAttribute">
      <summary>
            Assigns a specific dictionary key.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.IDictionaryMetaInitializer">
      <summary>
             Contract for dictionary meta-data initialization.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IDictionaryMetaInitializer.Initialize(Castle.Components.DictionaryAdapter.IDictionaryAdapterFactory,Castle.Components.DictionaryAdapter.DictionaryAdapterMeta)">
      <summary>
            	Initializes the given <see cref="T:Castle.Components.DictionaryAdapter.DictionaryAdapterMeta" /> object.
            </summary>
      <param name="factory">The dictionary adapter factory.</param>
      <param name="dictionaryMeta">The dictionary adapter meta.</param>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IDictionaryMetaInitializer.ShouldHaveBehavior(System.Object)">
      <summary>
            	Determines whether the given behavior should be included in a new
            	<see cref="T:Castle.Components.DictionaryAdapter.DictionaryAdapterMeta" /> object.
            </summary>
      <param name="behavior">A dictionary behavior or annotation.</param>
      <returns>True if the behavior should be included; otherwise, false.</returns>
      <remarks>
        <see cref="T:Castle.Components.DictionaryAdapter.IDictionaryMetaInitializer" /> behaviors are always included,
            	regardless of the result of this method.
            </remarks>
    </member>
    <member name="T:Castle.Core.Resource.IResource">
      <summary>
            Represents a 'streamable' resource. Can
            be a file, a resource in an assembly.
            </summary>
    </member>
    <member name="M:Castle.Core.Resource.IResource.GetStreamReader">
      <summary>
            Returns a reader for the stream
            </summary>
      <remarks>
            It's up to the caller to dispose the reader.
            </remarks>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Core.Resource.IResource.GetStreamReader(System.Text.Encoding)">
      <summary>
            Returns a reader for the stream
            </summary>
      <remarks>
            It's up to the caller to dispose the reader.
            </remarks>
      <param name="encoding">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Core.Resource.IResource.CreateRelative(System.String)">
      <summary>
            Returns an instance of <see cref="T:Castle.Core.Resource.IResource" />
            created according to the <c>relativePath</c>
            using itself as the root.
            </summary>
      <param name="relativePath">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:Castle.Core.Resource.IResource.FileBasePath">
      <summary>
      </summary>
      <remarks>
            Only valid for resources that
            can be obtained through relative paths
            </remarks>
    </member>
    <member name="T:Castle.Core.Resource.AbstractStreamResource">
      <summary>
      </summary>
    </member>
    <member name="F:Castle.Core.Resource.AbstractStreamResource.createStream">
      <summary>
            This returns a new stream instance each time it is called.
            It is the responsibility of the caller to dispose of this stream
            </summary>
    </member>
    <member name="T:Castle.DynamicProxy.Generators.Emitters.SimpleAST.IndirectReference">
      <summary>
              Wraps a reference that is passed 
              ByRef and provides indirect load/store support.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.Contributors.MembersCollector.AcceptMethod(System.Reflection.MethodInfo,System.Boolean,Castle.DynamicProxy.IProxyGenerationHook)">
      <summary>
              Performs some basic screening and invokes the <see cref="T:Castle.DynamicProxy.IProxyGenerationHook" />
              to select methods.
            </summary>
      <param name="method">
      </param>
      <param name="onlyVirtuals">
      </param>
      <param name="hook">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.IDictionaryValidator">
      <summary>
            Contract for dictionary validation.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IDictionaryValidator.IsValid(Castle.Components.DictionaryAdapter.IDictionaryAdapter)">
      <summary>
            Determines if <see cref="T:Castle.Components.DictionaryAdapter.IDictionaryAdapter" /> is valid.
            </summary>
      <param name="dictionaryAdapter">The dictionary adapter.</param>
      <returns>true if valid.</returns>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IDictionaryValidator.Validate(Castle.Components.DictionaryAdapter.IDictionaryAdapter)">
      <summary>
            Validates the <see cref="T:Castle.Components.DictionaryAdapter.IDictionaryAdapter" />.
            </summary>
      <param name="dictionaryAdapter">The dictionary adapter.</param>
      <returns>The error summary information.</returns>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IDictionaryValidator.Validate(Castle.Components.DictionaryAdapter.IDictionaryAdapter,Castle.Components.DictionaryAdapter.PropertyDescriptor)">
      <summary>
            Validates the <see cref="T:Castle.Components.DictionaryAdapter.IDictionaryAdapter" /> for a property.
            </summary>
      <param name="dictionaryAdapter">The dictionary adapter.</param>
      <param name="property">The property to validate.</param>
      <returns>The property summary information.</returns>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IDictionaryValidator.Invalidate(Castle.Components.DictionaryAdapter.IDictionaryAdapter)">
      <summary>
            Invalidates any results cached by the validator.
            </summary>
      <param name="dictionaryAdapter">The dictionary adapter.</param>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.IDictionaryAdapterFactory">
      <summary>
            Defines the contract for building typed dictionary adapters.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IDictionaryAdapterFactory.GetAdapter``1(System.Collections.IDictionary)">
      <summary>
            Gets a typed adapter bound to the <see cref="T:System.Collections.IDictionary" />.
            </summary>
      <typeparam name="T">The typed interface.</typeparam>
      <param name="dictionary">The underlying source of properties.</param>
      <returns>An implementation of the typed interface bound to the dictionary.</returns>
      <remarks>
            The type represented by T must be an interface with properties.
            </remarks>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IDictionaryAdapterFactory.GetAdapter(System.Type,System.Collections.IDictionary)">
      <summary>
            Gets a typed adapter bound to the <see cref="T:System.Collections.IDictionary" />.
            </summary>
      <param name="type">The typed interface.</param>
      <param name="dictionary">The underlying source of properties.</param>
      <returns>An implementation of the typed interface bound to the dictionary.</returns>
      <remarks>
            The type represented by T must be an interface with properties.
            </remarks>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IDictionaryAdapterFactory.GetAdapter(System.Type,System.Collections.IDictionary,Castle.Components.DictionaryAdapter.PropertyDescriptor)">
      <summary>
            Gets a typed adapter bound to the <see cref="T:System.Collections.IDictionary" />.
            </summary>
      <param name="type">The typed interface.</param>
      <param name="dictionary">The underlying source of properties.</param>
      <param name="descriptor">The property descriptor.</param>
      <returns>An implementation of the typed interface bound to the dictionary.</returns>
      <remarks>
            The type represented by T must be an interface with properties.
            </remarks>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IDictionaryAdapterFactory.GetAdapter``1(System.Collections.Specialized.NameValueCollection)">
      <summary>
            Gets a typed adapter bound to the <see cref="T:System.Collections.Specialized.NameValueCollection" />.
            </summary>
      <typeparam name="T">The typed interface.</typeparam>
      <param name="nameValues">The underlying source of properties.</param>
      <returns>An implementation of the typed interface bound to the namedValues.</returns>
      <remarks>
            The type represented by T must be an interface with properties.
            </remarks>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IDictionaryAdapterFactory.GetAdapter(System.Type,System.Collections.Specialized.NameValueCollection)">
      <summary>
            Gets a typed adapter bound to the <see cref="T:System.Collections.Specialized.NameValueCollection" />.
            </summary>
      <param name="type">The typed interface.</param>
      <param name="nameValues">The underlying source of properties.</param>
      <returns>An implementation of the typed interface bound to the namedValues.</returns>
      <remarks>
            The type represented by T must be an interface with properties.
            </remarks>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IDictionaryAdapterFactory.GetAdapter``1(System.Xml.XmlNode)">
      <summary>
            Gets a typed adapter bound to the <see cref="T:System.Xml.XmlNode" />.
            </summary>
      <typeparam name="T">The typed interface.</typeparam>
      <param name="xmlNode">The underlying source of properties.</param>
      <returns>An implementation of the typed interface bound to the <see cref="T:System.Xml.XmlNode" />.</returns>
      <remarks>
            The type represented by T must be an interface with properties.
            </remarks>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IDictionaryAdapterFactory.GetAdapter(System.Type,System.Xml.XmlNode)">
      <summary>
            Gets a typed adapter bound to the <see cref="T:System.Xml.XmlNode" />.
            </summary>
      <param name="type">The typed interface.</param>
      <param name="xmlNode">The underlying source of properties.</param>
      <returns>An implementation of the typed interface bound to the <see cref="T:System.Xml.XmlNode" />.</returns>
      <remarks>
            The type represented by T must be an interface with properties.
            </remarks>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IDictionaryAdapterFactory.GetAdapterMeta(System.Type)">
      <summary>
            Gets the <see cref="T:Castle.Components.DictionaryAdapter.DictionaryAdapterMeta" /> associated with the type.
            </summary>
      <param name="type">The typed interface.</param>
      <returns>The adapter meta-data.</returns>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IDictionaryAdapterFactory.GetAdapterMeta(System.Type,Castle.Components.DictionaryAdapter.PropertyDescriptor)">
      <summary>
            Gets the <see cref="T:Castle.Components.DictionaryAdapter.DictionaryAdapterMeta" /> associated with the type.
            </summary>
      <param name="type">The typed interface.</param>
      <param name="descriptor">The property descriptor.</param>
      <returns>The adapter meta-data.</returns>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IDictionaryAdapterFactory.GetAdapterMeta(System.Type,Castle.Components.DictionaryAdapter.DictionaryAdapterMeta)">
      <summary>
            Gets the <see cref="T:Castle.Components.DictionaryAdapter.DictionaryAdapterMeta" /> associated with the type.
            </summary>
      <param name="type">The typed interface.</param>
      <param name="other">Another <see cref="T:Castle.Components.DictionaryAdapter.DictionaryAdapterMeta" /> from which to copy behaviors.</param>
      <returns>The adapter meta-data.</returns>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.IDictionaryPropertyGetter">
      <summary>
            Defines the contract for retrieving dictionary values.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IDictionaryPropertyGetter.GetPropertyValue(Castle.Components.DictionaryAdapter.IDictionaryAdapter,System.String,System.Object,Castle.Components.DictionaryAdapter.PropertyDescriptor,System.Boolean)">
      <summary>
            Gets the effective dictionary value.
            </summary>
      <param name="dictionaryAdapter">The dictionary adapter.</param>
      <param name="key">The key.</param>
      <param name="storedValue">The stored value.</param>
      <param name="property">The property.</param>
      <param name="ifExists">true if return only existing.</param>
      <returns>The effective property value.</returns>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.DefaultPropertyGetter">
      <summary>
            Manages conversion between property values.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.DefaultPropertyGetter.#ctor(System.ComponentModel.TypeConverter)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Components.DictionaryAdapter.DefaultPropertyGetter" /> class.
            </summary>
      <param name="converter">The converter.</param>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.DefaultPropertyGetter.GetPropertyValue(Castle.Components.DictionaryAdapter.IDictionaryAdapter,System.String,System.Object,Castle.Components.DictionaryAdapter.PropertyDescriptor,System.Boolean)">
      <summary>
            Gets the effective dictionary value.
            </summary>
      <param name="dictionaryAdapter">The dictionary adapter.</param>
      <param name="key">The key.</param>
      <param name="storedValue">The stored value.</param>
      <param name="property">The property.</param>
      <param name="ifExists">true if return only existing.</param>
      <returns>The effective property value.</returns>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.DefaultPropertyGetter.ExecutionOrder">
      <summary>
      </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.IPropertyDescriptorInitializer">
      <summary>
             Contract for property descriptor initialization.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IPropertyDescriptorInitializer.Initialize(Castle.Components.DictionaryAdapter.PropertyDescriptor,System.Object[])">
      <summary>
            Performs any initialization of the <see cref="T:Castle.Components.DictionaryAdapter.PropertyDescriptor" /></summary>
      <param name="propertyDescriptor">The property descriptor.</param>
      <param name="behaviors">The property behaviors.</param>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.SuppressNotificationsAttribute">
      <summary>
            Suppress property change notifications.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.OnDemandAttribute">
      <summary>
            Support for on-demand value resolution.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerationOptions.#ctor(Castle.DynamicProxy.IProxyGenerationHook)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.DynamicProxy.ProxyGenerationOptions" /> class.
            </summary>
      <param name="hook">The hook.</param>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerationOptions.#ctor">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.DynamicProxy.ProxyGenerationOptions" /> class.
            </summary>
    </member>
    <member name="T:Castle.DynamicProxy.DefaultProxyBuilder">
      <summary>
              Default implementation of <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> interface producing in-memory proxy assemblies.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.DefaultProxyBuilder.#ctor">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.DynamicProxy.DefaultProxyBuilder" /> class with new <see cref="P:Castle.DynamicProxy.DefaultProxyBuilder.ModuleScope" />.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.DefaultProxyBuilder.#ctor(Castle.DynamicProxy.ModuleScope)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.DynamicProxy.DefaultProxyBuilder" /> class.
            </summary>
      <param name="scope">The module scope for generated proxy types.</param>
    </member>
    <member name="T:Castle.DynamicProxy.PersistentProxyBuilder">
      <summary>
              ProxyBuilder that persists the generated type.
            </summary>
      <remarks>
              The saved assembly contains just the last generated type.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.PersistentProxyBuilder.#ctor">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.DynamicProxy.PersistentProxyBuilder" /> class.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.PersistentProxyBuilder.SaveAssembly">
      <summary>
              Saves the generated assembly to a physical file. Note that this renders the <see cref="T:Castle.DynamicProxy.PersistentProxyBuilder" /> unusable.
            </summary>
      <returns>The path of the generated assembly file, or null if no assembly has been generated.</returns>
      <remarks>
              This method does not support saving multiple files. If both a signed and an unsigned module have been generated, use the 
              respective methods of the <see cref="T:Castle.DynamicProxy.ModuleScope" />.
            </remarks>
    </member>
    <member name="T:Castle.DynamicProxy.Contributors.ITypeContributor">
      <summary>
              Interface describing elements composing generated type
            </summary>
    </member>
    <member name="T:Castle.DynamicProxy.Generators.BaseProxyGenerator">
      <summary>
              Base class that exposes the common functionalities
              to proxy generation.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.BaseProxyGenerator.AddMappingNoCheck(System.Type,Castle.DynamicProxy.Contributors.ITypeContributor,System.Collections.Generic.IDictionary{System.Type,Castle.DynamicProxy.Contributors.ITypeContributor})">
      <summary>
              It is safe to add mapping (no mapping for the interface exists)
            </summary>
      <param name="implementer">
      </param>
      <param name="interface">
      </param>
      <param name="mapping">
      </param>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.BaseProxyGenerator.GenerateParameterlessConstructor(Castle.DynamicProxy.Generators.Emitters.ClassEmitter,System.Type,Castle.DynamicProxy.Generators.Emitters.SimpleAST.FieldReference)">
      <summary>
              Generates a parameters constructor that initializes the proxy
              state with <see cref="T:Castle.DynamicProxy.StandardInterceptor" /> just to make it non-null.
              <para>
                This constructor is important to allow proxies to be XML serializable
              </para></summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.KeySubstitutionAttribute">
      <summary>
            Substitutes part of key with another string.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.KeySubstitutionAttribute.#ctor(System.String,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Components.DictionaryAdapter.KeySubstitutionAttribute" /> class.
            </summary>
      <param name="oldValue">The old value.</param>
      <param name="newValue">The new value.</param>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.AbstractDictionaryAdapter">
      <summary>
            Abstract adapter for the <see cref="T:System.Collections.IDictionary" /> support
            needed by the <see cref="T:Castle.Components.DictionaryAdapter.DictionaryAdapterFactory" /></summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.AbstractDictionaryAdapter.Add(System.Object,System.Object)">
      <summary>
            Adds an element with the provided key and value to the <see cref="T:System.Collections.IDictionary"></see> object.
            </summary>
      <param name="key">The <see cref="T:System.Object"></see> to use as the key of the element to add.</param>
      <param name="value">The <see cref="T:System.Object"></see> to use as the value of the element to add.</param>
      <exception cref="T:System.ArgumentException">An element with the same key already exists in the <see cref="T:System.Collections.IDictionary"></see> object. </exception>
      <exception cref="T:System.ArgumentNullException">key is null. </exception>
      <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.IDictionary"></see> is read-only.-or- The <see cref="T:System.Collections.IDictionary"></see> has a fixed size. </exception>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.AbstractDictionaryAdapter.Clear">
      <summary>
            Removes all elements from the <see cref="T:System.Collections.IDictionary"></see> object.
            </summary>
      <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.IDictionary"></see> object is read-only. </exception>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.AbstractDictionaryAdapter.Contains(System.Object)">
      <summary>
            Determines whether the <see cref="T:System.Collections.IDictionary"></see> object contains an element with the specified key.
            </summary>
      <param name="key">The key to locate in the <see cref="T:System.Collections.IDictionary"></see> object.</param>
      <returns>
            true if the <see cref="T:System.Collections.IDictionary"></see> contains an element with the key; otherwise, false.
            </returns>
      <exception cref="T:System.ArgumentNullException">key is null. </exception>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.AbstractDictionaryAdapter.GetEnumerator">
      <summary>
            Returns an <see cref="T:System.Collections.IDictionaryEnumerator"></see> object for the <see cref="T:System.Collections.IDictionary"></see> object.
            </summary>
      <returns>
            An <see cref="T:System.Collections.IDictionaryEnumerator"></see> object for the <see cref="T:System.Collections.IDictionary"></see> object.
            </returns>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.AbstractDictionaryAdapter.Remove(System.Object)">
      <summary>
            Removes the element with the specified key from the <see cref="T:System.Collections.IDictionary"></see> object.
            </summary>
      <param name="key">The key of the element to remove.</param>
      <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.IDictionary"></see> object is read-only.-or- The <see cref="T:System.Collections.IDictionary"></see> has a fixed size. </exception>
      <exception cref="T:System.ArgumentNullException">key is null. </exception>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.AbstractDictionaryAdapter.CopyTo(System.Array,System.Int32)">
      <summary>
            Copies the elements of the <see cref="T:System.Collections.ICollection"></see> to an <see cref="T:System.Array"></see>, starting at a particular <see cref="T:System.Array"></see> index.
            </summary>
      <param name="array">The one-dimensional <see cref="T:System.Array"></see> that is the destination of the elements copied from <see cref="T:System.Collections.ICollection"></see>. The <see cref="T:System.Array"></see> must have zero-based indexing.</param>
      <param name="index">The zero-based index in array at which copying begins.</param>
      <exception cref="T:System.ArgumentNullException">array is null. </exception>
      <exception cref="T:System.ArgumentException">The type of the source <see cref="T:System.Collections.ICollection"></see> cannot be cast automatically to the type of the destination array. </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">index is less than zero. </exception>
      <exception cref="T:System.ArgumentException">array is multidimensional.-or- index is equal to or greater than the length of array.-or- The number of elements in the source <see cref="T:System.Collections.ICollection"></see> is greater than the available space from index to the end of the destination array. </exception>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.AbstractDictionaryAdapter.IsFixedSize">
      <summary>
            Gets a value indicating whether the <see cref="T:System.Collections.IDictionary"></see> object has a fixed size.
            </summary>
      <value>
      </value>
      <returns>true if the <see cref="T:System.Collections.IDictionary"></see> object has a fixed size; otherwise, false.</returns>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.AbstractDictionaryAdapter.IsReadOnly">
      <summary>
            Gets a value indicating whether the <see cref="T:System.Collections.IDictionary"></see> object is read-only.
            </summary>
      <value>
      </value>
      <returns>true if the <see cref="T:System.Collections.IDictionary"></see> object is read-only; otherwise, false.</returns>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.AbstractDictionaryAdapter.Keys">
      <summary>
            Gets an <see cref="T:System.Collections.ICollection"></see> object containing the keys of the <see cref="T:System.Collections.IDictionary"></see> object.
            </summary>
      <value>
      </value>
      <returns>An <see cref="T:System.Collections.ICollection"></see> object containing the keys of the <see cref="T:System.Collections.IDictionary"></see> object.</returns>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.AbstractDictionaryAdapter.Values">
      <summary>
            Gets an <see cref="T:System.Collections.ICollection"></see> object containing the values in the <see cref="T:System.Collections.IDictionary"></see> object.
            </summary>
      <value>
      </value>
      <returns>An <see cref="T:System.Collections.ICollection"></see> object containing the values in the <see cref="T:System.Collections.IDictionary"></see> object.</returns>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.AbstractDictionaryAdapter.Item(System.Object)">
      <summary>
            Gets or sets the <see cref="T:System.Object" /> with the specified key.
            </summary>
      <value>
      </value>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.AbstractDictionaryAdapter.Count">
      <summary>
            Gets the number of elements contained in the <see cref="T:System.Collections.ICollection"></see>.
            </summary>
      <value>
      </value>
      <returns>The number of elements contained in the <see cref="T:System.Collections.ICollection"></see>.</returns>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.AbstractDictionaryAdapter.IsSynchronized">
      <summary>
            Gets a value indicating whether access to the <see cref="T:System.Collections.ICollection"></see> is synchronized (thread safe).
            </summary>
      <value>
      </value>
      <returns>true if access to the <see cref="T:System.Collections.ICollection"></see> is synchronized (thread safe); otherwise, false.</returns>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.AbstractDictionaryAdapter.SyncRoot">
      <summary>
            Gets an object that can be used to synchronize access to the <see cref="T:System.Collections.ICollection"></see>.
            </summary>
      <value>
      </value>
      <returns>An object that can be used to synchronize access to the <see cref="T:System.Collections.ICollection"></see>.</returns>
    </member>
    <member name="T:Castle.Core.Resource.StaticContentResource">
      <summary>
            Adapts a static string content as an <see cref="T:Castle.Core.Resource.IResource" /></summary>
    </member>
    <member name="T:Castle.Core.Resource.IResourceFactory">
      <summary>
            Depicts the contract for resource factories.
            </summary>
    </member>
    <member name="M:Castle.Core.Resource.IResourceFactory.Accept(Castle.Core.Resource.CustomUri)">
      <summary>
            Used to check whether the resource factory
            is able to deal with the given resource
            identifier.
            </summary>
      <remarks>
            Implementors should return <c>true</c>
            only if the given identifier is supported
            by the resource factory
            </remarks>
      <param name="uri">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Core.Resource.IResourceFactory.Create(Castle.Core.Resource.CustomUri)">
      <summary>
            Creates an <see cref="T:Castle.Core.Resource.IResource" /> instance
            for the given resource identifier
            </summary>
      <param name="uri">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Core.Resource.IResourceFactory.Create(Castle.Core.Resource.CustomUri,System.String)">
      <summary>
            Creates an <see cref="T:Castle.Core.Resource.IResource" /> instance
            for the given resource identifier
            </summary>
      <param name="uri">
      </param>
      <param name="basePath">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:Castle.Core.Logging.IExtendedLoggerFactory">
      <summary>
              Provides a factory that can produce either <see cref="T:Castle.Core.Logging.ILogger" /> or
              <see cref="T:Castle.Core.Logging.IExtendedLogger" /> classes.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.IExtendedLoggerFactory.Create(System.Type)">
      <summary>
              Creates a new extended logger, getting the logger name from the specified type.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.IExtendedLoggerFactory.Create(System.String)">
      <summary>
              Creates a new extended logger.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.IExtendedLoggerFactory.Create(System.Type,Castle.Core.Logging.LoggerLevel)">
      <summary>
              Creates a new extended logger, getting the logger name from the specified type.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.IExtendedLoggerFactory.Create(System.String,Castle.Core.Logging.LoggerLevel)">
      <summary>
              Creates a new extended logger.
            </summary>
    </member>
    <member name="T:Castle.DynamicProxy.IInvocation">
      <summary>
              Encapsulates an invocation of a proxied method.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.IInvocation.GetArgumentValue(System.Int32)">
      <summary>
              Gets the value of the argument at the specified <paramref name="index" />.
            </summary>
      <param name="index">The index.</param>
      <returns>The value of the argument at the specified <paramref name="index" />.</returns>
    </member>
    <member name="M:Castle.DynamicProxy.IInvocation.GetConcreteMethod">
      <summary>
              Returns the concrete instantiation of the <see cref="P:Castle.DynamicProxy.IInvocation.Method" /> on the proxy, with any generic
              parameters bound to real types.
            </summary>
      <returns>
              The concrete instantiation of the <see cref="P:Castle.DynamicProxy.IInvocation.Method" /> on the proxy, or the <see cref="P:Castle.DynamicProxy.IInvocation.Method" /> if
              not a generic method.
            </returns>
      <remarks>
              Can be slower than calling <see cref="P:Castle.DynamicProxy.IInvocation.Method" />.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.IInvocation.GetConcreteMethodInvocationTarget">
      <summary>
              Returns the concrete instantiation of <see cref="P:Castle.DynamicProxy.IInvocation.MethodInvocationTarget" />, with any
              generic parameters bound to real types.
              For interface proxies, this will point to the <see cref="T:System.Reflection.MethodInfo" /> on the target class.
            </summary>
      <returns>The concrete instantiation of <see cref="P:Castle.DynamicProxy.IInvocation.MethodInvocationTarget" />, or
              <see cref="P:Castle.DynamicProxy.IInvocation.MethodInvocationTarget" /> if not a generic method.</returns>
      <remarks>
              In debug builds this can be slower than calling <see cref="P:Castle.DynamicProxy.IInvocation.MethodInvocationTarget" />.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.IInvocation.Proceed">
      <summary>
              Proceeds the call to the next interceptor in line, and ultimately to the target method.
            </summary>
      <remarks>
              Since interface proxies without a target don't have the target implementation to proceed to,
              it is important, that the last interceptor does not call this method, otherwise a
              <see cref="T:System.NotImplementedException" /> will be thrown.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.IInvocation.SetArgumentValue(System.Int32,System.Object)">
      <summary>
              Overrides the value of an argument at the given <paramref name="index" /> with the
              new <paramref name="value" /> provided.
            </summary>
      <remarks>
              This method accepts an <see cref="T:System.Object" />, however the value provided must be compatible
              with the type of the argument defined on the method, otherwise an exception will be thrown.
            </remarks>
      <param name="index">The index of the argument to override.</param>
      <param name="value">The new value for the argument.</param>
    </member>
    <member name="P:Castle.DynamicProxy.IInvocation.Arguments">
      <summary>
              Gets the arguments that the <see cref="P:Castle.DynamicProxy.IInvocation.Method" /> has been invoked with.
            </summary>
      <value>The arguments the method was invoked with.</value>
    </member>
    <member name="P:Castle.DynamicProxy.IInvocation.GenericArguments">
      <summary>
              Gets the generic arguments of the method.
            </summary>
      <value>The generic arguments, or null if not a generic method.</value>
    </member>
    <member name="P:Castle.DynamicProxy.IInvocation.InvocationTarget">
      <summary>
              Gets the object on which the invocation is performed. This is different from proxy object
              because most of the time this will be the proxy target object.
            </summary>
      <seealso cref="T:Castle.DynamicProxy.IChangeProxyTarget" />
      <value>The invocation target.</value>
    </member>
    <member name="P:Castle.DynamicProxy.IInvocation.Method">
      <summary>
              Gets the <see cref="T:System.Reflection.MethodInfo" /> representing the method being invoked on the proxy.
            </summary>
      <value>The <see cref="T:System.Reflection.MethodInfo" /> representing the method being invoked.</value>
    </member>
    <member name="P:Castle.DynamicProxy.IInvocation.MethodInvocationTarget">
      <summary>
              For interface proxies, this will point to the <see cref="T:System.Reflection.MethodInfo" /> on the target class.
            </summary>
      <value>The method invocation target.</value>
    </member>
    <member name="P:Castle.DynamicProxy.IInvocation.Proxy">
      <summary>
              Gets the proxy object on which the intercepted method is invoked.
            </summary>
      <value>Proxy object on which the intercepted method is invoked.</value>
    </member>
    <member name="P:Castle.DynamicProxy.IInvocation.ReturnValue">
      <summary>
              Gets or sets the return value of the method.
            </summary>
      <value>The return value of the method.</value>
    </member>
    <member name="P:Castle.DynamicProxy.IInvocation.TargetType">
      <summary>
              Gets the type of the target object for the intercepted method.
            </summary>
      <value>The type of the target object.</value>
    </member>
    <member name="M:Castle.DynamicProxy.Serialization.RemotableInvocation.Proceed">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="P:Castle.DynamicProxy.Serialization.RemotableInvocation.Method">
      <summary>
      </summary>
    </member>
    <member name="P:Castle.DynamicProxy.Serialization.RemotableInvocation.MethodInvocationTarget">
      <summary>
              For interface proxies, this will point to the
              <see cref="T:System.Reflection.MethodInfo" /> on the target class
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.MetaEvent.#ctor(System.String,System.Type,System.Type,Castle.DynamicProxy.Generators.MetaMethod,Castle.DynamicProxy.Generators.MetaMethod,System.Reflection.EventAttributes)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.DynamicProxy.Generators.MetaEvent" /> class.
            </summary>
      <param name="name">The name.</param>
      <param name="declaringType">Type declaring the original event being overriten, or null.</param>
      <param name="eventDelegateType">
      </param>
      <param name="adder">The add method.</param>
      <param name="remover">The remove method.</param>
      <param name="attributes">The attributes.</param>
    </member>
    <member name="T:Castle.DynamicProxy.Generators.Emitters.SimpleAST.NewArrayExpression">
      <summary>
              Summary description for NewArrayExpression.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.ICondition">
      <summary>
            Contract for value matching.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.IDictionaryBehaviorBuilder">
      <summary>
            Defines the contract for building <see cref="T:Castle.Components.DictionaryAdapter.IDictionaryBehavior" />s.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IDictionaryBehaviorBuilder.BuildBehaviors">
      <summary>
            Builds the dictionary behaviors.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.VolatileAttribute">
      <summary>
            Indicates that underlying values are changeable and should not be cached.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.FetchAttribute">
      <summary>
            Identifies an interface or property to be pre-fetched.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.FetchAttribute.#ctor">
      <summary>
            Instructs fetching to occur.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.FetchAttribute.#ctor(System.Boolean)">
      <summary>
            Instructs fetching according to <paramref name="fetch" /></summary>
      <param name="fetch">
      </param>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.FetchAttribute.Fetch">
      <summary>
            Gets whether or not fetching should occur.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.IDictionaryInitializer">
      <summary>
             Contract for dictionary initialization.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IDictionaryInitializer.Initialize(Castle.Components.DictionaryAdapter.IDictionaryAdapter,System.Object[])">
      <summary>
            Performs any initialization of the <see cref="T:Castle.Components.DictionaryAdapter.IDictionaryAdapter" /></summary>
      <param name="dictionaryAdapter">The dictionary adapter.</param>
      <param name="behaviors">The dictionary behaviors.</param>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.IDictionaryPropertySetter">
      <summary>
            Defines the contract for updating dictionary values.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IDictionaryPropertySetter.SetPropertyValue(Castle.Components.DictionaryAdapter.IDictionaryAdapter,System.String,System.Object@,Castle.Components.DictionaryAdapter.PropertyDescriptor)">
      <summary>
            Sets the stored dictionary value.
            </summary>
      <param name="dictionaryAdapter">The dictionary adapter.</param>
      <param name="key">The key.</param>
      <param name="value">The stored value.</param>
      <param name="property">The property.</param>
      <returns>true if the property should be stored.</returns>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.Xml.XmlAdapter.#ctor(Castle.Components.DictionaryAdapter.Xml.IXmlNode,Castle.Components.DictionaryAdapter.Xml.XmlReferenceManager)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Components.DictionaryAdapter.Xml.XmlAdapter" /> class
            that represents a child object in a larger object graph.
            </summary>
      <param name="node">
      </param>
      <param name="references">
      </param>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.BindingList`1">
      <summary>
              Provides a generic collection that supports data binding.
            </summary>
      <remarks>
              This class wraps the CLR <see cref="T:System.ComponentModel.BindingList`1" />
              in order to implement the Castle-specific <see cref="T:Castle.Components.DictionaryAdapter.IBindingList`1" />.
            </remarks>
      <typeparam name="T">The type of elements in the list.</typeparam>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.BindingList`1.#ctor">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.Components.DictionaryAdapter.BindingList`1" /> class
              using default values.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.BindingList`1.#ctor(System.Collections.Generic.IList{`0})">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.Components.DictionaryAdapter.BindingList`1" /> class
              with the specified list.
            </summary>
      <param name="list">
              An <see cref="T:System.Collections.Generic.IList`1" /> of items
              to be contained in the <see cref="T:Castle.Components.DictionaryAdapter.BindingList`1" />.
            </param>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.BindingList`1.#ctor(System.ComponentModel.BindingList{`0})">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.Components.DictionaryAdapter.BindingList`1" /> class
              wrapping the specified <see cref="T:System.ComponentModel.BindingList`1" /> instance.
            </summary>
      <param name="list">
              A <see cref="T:System.ComponentModel.BindingList`1" />
              to be wrapped by the <see cref="T:Castle.Components.DictionaryAdapter.BindingList`1" />.
            </param>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.RemoveIfAttribute">
      <summary>
            Removes a property if matches value.
            </summary>
    </member>
    <member name="T:Castle.Core.Resource.FileResourceFactory">
      <summary>
      </summary>
    </member>
    <member name="M:Castle.Core.Configuration.Xml.XmlConfigurationDeserializer.Deserialize(System.Xml.XmlNode)">
      <summary>
              Deserializes the specified node into an abstract representation of configuration.
            </summary>
      <param name="node">The node.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Core.Configuration.Xml.XmlConfigurationDeserializer.GetConfigValue(System.String)">
      <summary>
              If a config value is an empty string we return null, this is to keep
              backward compatibility with old code
            </summary>
    </member>
    <member name="T:Castle.DynamicProxy.Generators.Emitters.LdindOpCodesDictionary">
      <summary>
              Provides appropriate Ldind.X opcode for 
              the type of primitive value to be loaded indirectly.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.Internal.TypeUtil.GetAllInterfaces(System.Type[])">
      <summary>
              Returns list of all unique interfaces implemented given types, including their base interfaces.
            </summary>
      <param name="types">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:Castle.DynamicProxy.IProxyGenerationHook">
      <summary>
              Used during the target type inspection process. Implementors have a chance to customize the
              proxy generation process.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.IProxyGenerationHook.MethodsInspected">
      <summary>
              Invoked by the generation process to notify that the whole process has completed.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.IProxyGenerationHook.NonProxyableMemberNotification(System.Type,System.Reflection.MemberInfo)">
      <summary>
              Invoked by the generation process to notify that a member was not marked as virtual.
            </summary>
      <param name="type">The type which declares the non-virtual member.</param>
      <param name="memberInfo">The non-virtual member.</param>
      <remarks>
              This method gives an opportunity to inspect any non-proxyable member of a type that has 
              been requested to be proxied, and if appropriate - throw an exception to notify the caller.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.IProxyGenerationHook.ShouldInterceptMethod(System.Type,System.Reflection.MethodInfo)">
      <summary>
              Invoked by the generation process to determine if the specified method should be proxied.
            </summary>
      <param name="type">The type which declares the given method.</param>
      <param name="methodInfo">The method to inspect.</param>
      <returns>True if the given method should be proxied; false otherwise.</returns>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.KeyPrefixAttribute">
      <summary>
            Assigns a prefix to the keyed properties of an interface.
            </summary>
      <remarks>
            Key prefixes are not inherited by sub-interfaces.
            </remarks>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.KeyPrefixAttribute.#ctor">
      <summary>
            Initializes a default instance of the <see cref="T:Castle.Components.DictionaryAdapter.KeyPrefixAttribute" /> class.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.KeyPrefixAttribute.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Components.DictionaryAdapter.KeyPrefixAttribute" /> class.
            </summary>
      <param name="keyPrefix">The prefix for the keyed properties of the interface.</param>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.KeyPrefixAttribute.KeyPrefix">
      <summary>
            Gets the prefix key added to the properties of the interface.
            </summary>
    </member>
    <member name="T:Castle.Core.Configuration.IConfiguration">
      <summary>
        <see cref="T:Castle.Core.Configuration.IConfiguration" /> is a interface encapsulating a configuration node
            used to retrieve configuration values.
            </summary>
    </member>
    <member name="M:Castle.Core.Configuration.IConfiguration.GetValue(System.Type,System.Object)">
      <summary>
            Gets the value of the node and converts it 
            into specified <see cref="T:System.Type" />.
            </summary>
      <param name="type">The <see cref="T:System.Type" /></param>
      <param name="defaultValue">
            The Default value returned if the conversion fails.
            </param>
      <returns>The Value converted into the specified type.</returns>
    </member>
    <member name="P:Castle.Core.Configuration.IConfiguration.Name">
      <summary>
            Gets the name of the node.
            </summary>
      <value>
            The Name of the node.
            </value>
    </member>
    <member name="P:Castle.Core.Configuration.IConfiguration.Value">
      <summary>
            Gets the value of the node.
            </summary>
      <value>
            The Value of the node.
            </value>
    </member>
    <member name="P:Castle.Core.Configuration.IConfiguration.Children">
      <summary>
            Gets an <see cref="T:Castle.Core.Configuration.ConfigurationCollection" /> of <see cref="T:Castle.Core.Configuration.IConfiguration" />
            elements containing all node children.
            </summary>
      <value>The Collection of child nodes.</value>
    </member>
    <member name="P:Castle.Core.Configuration.IConfiguration.Attributes">
      <summary>
            Gets an <see cref="T:System.Collections.IDictionary" /> of the configuration attributes.
            </summary>
    </member>
    <member name="T:Castle.Core.Configuration.AbstractConfiguration">
      <summary>
              This is an abstract <see cref="T:Castle.Core.Configuration.IConfiguration" /> implementation
              that deals with methods that can be abstracted away
              from underlying implementations.
            </summary>
      <remarks>
        <para>
          <b>AbstractConfiguration</b> makes easier to implementers 
                to create a new version of <see cref="T:Castle.Core.Configuration.IConfiguration" /></para>
      </remarks>
    </member>
    <member name="M:Castle.Core.Configuration.AbstractConfiguration.GetValue(System.Type,System.Object)">
      <summary>
              Gets the value of the node and converts it
              into specified <see cref="T:System.Type" />.
            </summary>
      <param name="type">The <see cref="T:System.Type" /></param>
      <param name="defaultValue">
              The Default value returned if the conversion fails.
            </param>
      <returns>The Value converted into the specified type.</returns>
    </member>
    <member name="P:Castle.Core.Configuration.AbstractConfiguration.Attributes">
      <summary>
              Gets node attributes.
            </summary>
      <value>
              All attributes of the node.
            </value>
    </member>
    <member name="P:Castle.Core.Configuration.AbstractConfiguration.Children">
      <summary>
              Gets all child nodes.
            </summary>
      <value>The <see cref="T:Castle.Core.Configuration.ConfigurationCollection" /> of child nodes.</value>
    </member>
    <member name="P:Castle.Core.Configuration.AbstractConfiguration.Name">
      <summary>
              Gets the name of the <see cref="T:Castle.Core.Configuration.IConfiguration" />.
            </summary>
      <value>
              The Name of the <see cref="T:Castle.Core.Configuration.IConfiguration" />.
            </value>
    </member>
    <member name="P:Castle.Core.Configuration.AbstractConfiguration.Value">
      <summary>
              Gets the value of <see cref="T:Castle.Core.Configuration.IConfiguration" />.
            </summary>
      <value>
              The Value of the <see cref="T:Castle.Core.Configuration.IConfiguration" />.
            </value>
    </member>
    <member name="T:Castle.Core.Configuration.MutableConfiguration">
      <summary>
            Summary description for MutableConfiguration.
            </summary>
    </member>
    <member name="M:Castle.Core.Configuration.MutableConfiguration.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.Configuration.MutableConfiguration" /> class.
            </summary>
      <param name="name">The name.</param>
    </member>
    <member name="P:Castle.Core.Configuration.MutableConfiguration.Value">
      <summary>
            Gets the value of <see cref="T:Castle.Core.Configuration.IConfiguration" />.
            </summary>
      <value>
            The Value of the <see cref="T:Castle.Core.Configuration.IConfiguration" />.
            </value>
    </member>
    <member name="T:Castle.Core.Logging.ILogger">
      <summary>
              Manages logging.
            </summary>
      <remarks>
              This is a facade for the different logging subsystems.
              It offers a simplified interface that follows IOC patterns
              and a simplified priority/level/severity abstraction.
            </remarks>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.CreateChildLogger(System.String)">
      <summary>
              Create a new child logger.
              The name of the child logger is [current-loggers-name].[passed-in-name]
            </summary>
      <param name="loggerName">The Subname of this logger.</param>
      <returns>The New ILogger instance.</returns>
      <exception cref="T:System.ArgumentException">If the name has an empty element name.</exception>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Debug(System.String)">
      <summary>
              Logs a debug message.
            </summary>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Debug(System.Func{System.String})">
      <summary>
              Logs a debug message with lazily constructed message. The message will be constructed only if the <see cref="P:Castle.Core.Logging.ILogger.IsDebugEnabled" /> is true.
            </summary>
      <param name="messageFactory">
      </param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Debug(System.String,System.Exception)">
      <summary>
              Logs a debug message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.DebugFormat(System.String,System.Object[])">
      <summary>
              Logs a debug message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.DebugFormat(System.Exception,System.String,System.Object[])">
      <summary>
              Logs a debug message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.DebugFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
              Logs a debug message.
            </summary>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.DebugFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
              Logs a debug message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Error(System.String)">
      <summary>
              Logs an error message.
            </summary>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Error(System.Func{System.String})">
      <summary>
              Logs an error message with lazily constructed message. The message will be constructed only if the <see cref="P:Castle.Core.Logging.ILogger.IsErrorEnabled" /> is true.
            </summary>
      <param name="messageFactory">
      </param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Error(System.String,System.Exception)">
      <summary>
              Logs an error message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.ErrorFormat(System.String,System.Object[])">
      <summary>
              Logs an error message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.ErrorFormat(System.Exception,System.String,System.Object[])">
      <summary>
              Logs an error message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.ErrorFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
              Logs an error message.
            </summary>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.ErrorFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
              Logs an error message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Fatal(System.String)">
      <summary>
              Logs a fatal message.
            </summary>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Fatal(System.Func{System.String})">
      <summary>
              Logs a fatal message with lazily constructed message. The message will be constructed only if the <see cref="P:Castle.Core.Logging.ILogger.IsFatalEnabled" /> is true.
            </summary>
      <param name="messageFactory">
      </param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Fatal(System.String,System.Exception)">
      <summary>
              Logs a fatal message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.FatalFormat(System.String,System.Object[])">
      <summary>
              Logs a fatal message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.FatalFormat(System.Exception,System.String,System.Object[])">
      <summary>
              Logs a fatal message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.FatalFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
              Logs a fatal message.
            </summary>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.FatalFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
              Logs a fatal message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Info(System.String)">
      <summary>
              Logs an info message.
            </summary>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Info(System.Func{System.String})">
      <summary>
              Logs a info message with lazily constructed message. The message will be constructed only if the <see cref="P:Castle.Core.Logging.ILogger.IsInfoEnabled" /> is true.
            </summary>
      <param name="messageFactory">
      </param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Info(System.String,System.Exception)">
      <summary>
              Logs an info message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.InfoFormat(System.String,System.Object[])">
      <summary>
              Logs an info message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.InfoFormat(System.Exception,System.String,System.Object[])">
      <summary>
              Logs an info message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.InfoFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
              Logs an info message.
            </summary>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.InfoFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
              Logs an info message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Warn(System.String)">
      <summary>
              Logs a warn message.
            </summary>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Warn(System.Func{System.String})">
      <summary>
              Logs a warn message with lazily constructed message. The message will be constructed only if the <see cref="P:Castle.Core.Logging.ILogger.IsWarnEnabled" /> is true.
            </summary>
      <param name="messageFactory">
      </param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Warn(System.String,System.Exception)">
      <summary>
              Logs a warn message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.WarnFormat(System.String,System.Object[])">
      <summary>
              Logs a warn message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.WarnFormat(System.Exception,System.String,System.Object[])">
      <summary>
              Logs a warn message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.WarnFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
              Logs a warn message.
            </summary>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.WarnFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
              Logs a warn message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="P:Castle.Core.Logging.ILogger.IsDebugEnabled">
      <summary>
              Determines if messages of priority "debug" will be logged.
            </summary>
      <value>True if "debug" messages will be logged.</value>
    </member>
    <member name="P:Castle.Core.Logging.ILogger.IsErrorEnabled">
      <summary>
              Determines if messages of priority "error" will be logged.
            </summary>
      <value>True if "error" messages will be logged.</value>
    </member>
    <member name="P:Castle.Core.Logging.ILogger.IsFatalEnabled">
      <summary>
              Determines if messages of priority "fatal" will be logged.
            </summary>
      <value>True if "fatal" messages will be logged.</value>
    </member>
    <member name="P:Castle.Core.Logging.ILogger.IsInfoEnabled">
      <summary>
              Determines if messages of priority "info" will be logged.
            </summary>
      <value>True if "info" messages will be logged.</value>
    </member>
    <member name="P:Castle.Core.Logging.ILogger.IsWarnEnabled">
      <summary>
              Determines if messages of priority "warn" will be logged.
            </summary>
      <value>True if "warn" messages will be logged.</value>
    </member>
    <member name="T:Castle.Core.Logging.IContextProperties">
      <summary>
              Interface for Context Properties implementations
            </summary>
      <remarks>
        <para>
                This interface defines a basic property get set accessor.
              </para>
        <para>
                Based on the ContextPropertiesBase of log4net, by Nicko Cadell.
              </para>
      </remarks>
    </member>
    <member name="P:Castle.Core.Logging.IContextProperties.Item(System.String)">
      <summary>
              Gets or sets the value of a property
            </summary>
      <value>
              The value for the property with the specified key
            </value>
      <remarks>
        <para>
                Gets or sets the value of a property
              </para>
      </remarks>
    </member>
    <member name="M:Castle.Core.Internal.Lock.Create">
      <summary>
            Creates a new lock.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.IDictionaryAdapterVisitor">
      <summary>
            Conract for traversing a <see cref="T:Castle.Components.DictionaryAdapter.IDictionaryAdapter" />.
            </summary>
    </member>
    <member name="T:Castle.Core.Logging.LevelFilteredLogger">
      <summary>
            The Level Filtered Logger class.  This is a base clase which
            provides a LogLevel attribute and reroutes all functions into
            one Log method.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.#ctor">
      <summary>
              Creates a new <c>LevelFilteredLogger</c>.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.InitializeLifetimeService">
      <summary>
            Keep the instance alive in a remoting scenario
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Debug(System.String)">
      <summary>
              Logs a debug message.
            </summary>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Debug(System.String,System.Exception)">
      <summary>
              Logs a debug message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.DebugFormat(System.String,System.Object[])">
      <summary>
              Logs a debug message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.DebugFormat(System.Exception,System.String,System.Object[])">
      <summary>
              Logs a debug message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.DebugFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
              Logs a debug message.
            </summary>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.DebugFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
              Logs a debug message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Info(System.String)">
      <summary>
              Logs an info message.
            </summary>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Info(System.String,System.Exception)">
      <summary>
              Logs an info message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.InfoFormat(System.String,System.Object[])">
      <summary>
              Logs an info message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.InfoFormat(System.Exception,System.String,System.Object[])">
      <summary>
              Logs an info message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.InfoFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
              Logs an info message.
            </summary>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.InfoFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
              Logs an info message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Warn(System.String)">
      <summary>
              Logs a warn message.
            </summary>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Warn(System.String,System.Exception)">
      <summary>
              Logs a warn message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.WarnFormat(System.String,System.Object[])">
      <summary>
              Logs a warn message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.WarnFormat(System.Exception,System.String,System.Object[])">
      <summary>
              Logs a warn message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.WarnFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
              Logs a warn message.
            </summary>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.WarnFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
              Logs a warn message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Error(System.String)">
      <summary>
              Logs an error message.
            </summary>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Error(System.String,System.Exception)">
      <summary>
              Logs an error message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.ErrorFormat(System.String,System.Object[])">
      <summary>
              Logs an error message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.ErrorFormat(System.Exception,System.String,System.Object[])">
      <summary>
              Logs an error message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.ErrorFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
              Logs an error message.
            </summary>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.ErrorFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
              Logs an error message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Fatal(System.String)">
      <summary>
              Logs a fatal message.
            </summary>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Fatal(System.String,System.Exception)">
      <summary>
              Logs a fatal message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.FatalFormat(System.String,System.Object[])">
      <summary>
              Logs a fatal message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.FatalFormat(System.Exception,System.String,System.Object[])">
      <summary>
              Logs a fatal message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.FatalFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
              Logs a fatal message.
            </summary>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.FatalFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
              Logs a fatal message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Log(Castle.Core.Logging.LoggerLevel,System.String,System.String,System.Exception)">
      <summary>
              Implementors output the log content by implementing this method only.
              Note that exception can be null
            </summary>
      <param name="loggerLevel">
      </param>
      <param name="loggerName">
      </param>
      <param name="message">
      </param>
      <param name="exception">
      </param>
    </member>
    <member name="P:Castle.Core.Logging.LevelFilteredLogger.Level">
      <value>
              The <c>LoggerLevel</c> that this logger
              will be using. Defaults to <c>LoggerLevel.Off</c></value>
    </member>
    <member name="P:Castle.Core.Logging.LevelFilteredLogger.Name">
      <value>
              The name that this logger will be using. 
              Defaults to <c>String.Empty</c></value>
    </member>
    <member name="P:Castle.Core.Logging.LevelFilteredLogger.IsDebugEnabled">
      <summary>
              Determines if messages of priority "debug" will be logged.
            </summary>
      <value>
        <c>true</c> if log level flags include the <see cref="F:Castle.Core.Logging.LoggerLevel.Debug" /> bit</value>
    </member>
    <member name="P:Castle.Core.Logging.LevelFilteredLogger.IsInfoEnabled">
      <summary>
              Determines if messages of priority "info" will be logged.
            </summary>
      <value>
        <c>true</c> if log level flags include the <see cref="F:Castle.Core.Logging.LoggerLevel.Info" /> bit</value>
    </member>
    <member name="P:Castle.Core.Logging.LevelFilteredLogger.IsWarnEnabled">
      <summary>
              Determines if messages of priority "warn" will be logged.
            </summary>
      <value>
        <c>true</c> if log level flags include the <see cref="F:Castle.Core.Logging.LoggerLevel.Warn" /> bit</value>
    </member>
    <member name="P:Castle.Core.Logging.LevelFilteredLogger.IsErrorEnabled">
      <summary>
              Determines if messages of priority "error" will be logged.
            </summary>
      <value>
        <c>true</c> if log level flags include the <see cref="F:Castle.Core.Logging.LoggerLevel.Error" /> bit</value>
    </member>
    <member name="P:Castle.Core.Logging.LevelFilteredLogger.IsFatalEnabled">
      <summary>
              Determines if messages of priority "fatal" will be logged.
            </summary>
      <value>
        <c>true</c> if log level flags include the <see cref="F:Castle.Core.Logging.LoggerLevel.Fatal" /> bit</value>
    </member>
    <member name="T:Castle.Core.Logging.TraceLogger">
      <summary>
              The TraceLogger sends all logging to the System.Diagnostics.TraceSource
              built into the .net framework.
            </summary>
      <remarks>
              Logging can be configured in the system.diagnostics configuration 
              section. 
            
              If logger doesn't find a source name with a full match it will
              use source names which match the namespace partially. For example you can
              configure from all castle components by adding a source name with the
              name "Castle". 
            
              If no portion of the namespace matches the source named "Default" will
              be used.
            </remarks>
    </member>
    <member name="M:Castle.Core.Logging.TraceLogger.#ctor(System.String)">
      <summary>
            Build a new trace logger based on the named TraceSource
            </summary>
      <param name="name">The name used to locate the best TraceSource. In most cases comes from the using type's fullname.</param>
    </member>
    <member name="M:Castle.Core.Logging.TraceLogger.#ctor(System.String,Castle.Core.Logging.LoggerLevel)">
      <summary>
            Build a new trace logger based on the named TraceSource
            </summary>
      <param name="name">The name used to locate the best TraceSource. In most cases comes from the using type's fullname.</param>
      <param name="level">The default logging level at which this source should write messages. In almost all cases this
            default value will be overridden in the config file. </param>
    </member>
    <member name="M:Castle.Core.Logging.TraceLogger.CreateChildLogger(System.String)">
      <summary>
            Create a new child logger.
            The name of the child logger is [current-loggers-name].[passed-in-name]
            </summary>
      <param name="loggerName">The Subname of this logger.</param>
      <returns>The New ILogger instance.</returns>
    </member>
    <member name="T:Castle.DynamicProxy.IAttributeDisassembler">
      <summary>
              Provides functionality for disassembling instances of attributes to CustomAttributeBuilder form, during the process of emiting new types by Dynamic Proxy.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.IAttributeDisassembler.Disassemble(System.Attribute)">
      <summary>
              Disassembles given attribute instance back to corresponding CustomAttributeBuilder.
            </summary>
      <param name="attribute">An instance of attribute to disassemble</param>
      <returns>
        <see cref="T:System.Reflection.Emit.CustomAttributeBuilder" /> corresponding 1 to 1 to given attribute instance, or null reference.</returns>
      <remarks>
              Implementers should return <see cref="T:System.Reflection.Emit.CustomAttributeBuilder" /> that corresponds to given attribute instance 1 to 1,
              that is after calling specified constructor with specified arguments, and setting specified properties and fields with values specified
              we should be able to get an attribute instance identical to the one passed in <paramref name="attribute" />. Implementer can return null
              if it wishes to opt out of replicating the attribute. Notice however, that for some cases, like attributes passed explicitly by the user
              it is illegal to return null, and doing so will result in exception.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.MixinData.#ctor(System.Collections.Generic.IEnumerable{System.Object})">
      <summary>
              Because we need to cache the types based on the mixed in mixins, we do the following here:
              - Get all the mixin interfaces
              - Sort them by full name
              - Return them by position
            
            The idea is to have reproducible behavior for the case that mixins are registered in different orders.
            This method is here because it is required 
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.StringListAttribute">
      <summary>
            Identifies a property should be represented as a delimited string value.
            </summary>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.StringListAttribute.Separator">
      <summary>
            Gets the separator.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.DictionaryAdapterAttribute">
      <summary>
            Identifies the dictionary adapter types.
            </summary>
    </member>
    <member name="T:Castle.Core.Logging.TraceLoggerFactory">
      <summary>
              Used to create the TraceLogger implementation of ILogger interface. See <see cref="T:Castle.Core.Logging.TraceLogger" />.
            </summary>
    </member>
    <member name="T:Castle.DynamicProxy.Tokens.SerializationInfoMethods">
      <summary>
              Holds <see cref="T:System.Reflection.MethodInfo" /> objects representing methods of <see cref="T:System.Runtime.Serialization.SerializationInfo" /> class.
            </summary>
    </member>
    <member name="F:Castle.DynamicProxy.Tokens.SerializationInfoMethods.AddValue_Bool">
      <summary>
        <see cref="M:System.Runtime.Serialization.SerializationInfo.AddValue(System.String,System.Boolean)" />
      </summary>
    </member>
    <member name="F:Castle.DynamicProxy.Tokens.SerializationInfoMethods.AddValue_Int32">
      <summary>
        <see cref="M:System.Runtime.Serialization.SerializationInfo.AddValue(System.String,System.Int32)" />
      </summary>
    </member>
    <member name="F:Castle.DynamicProxy.Tokens.SerializationInfoMethods.AddValue_Object">
      <summary>
        <see cref="M:System.Runtime.Serialization.SerializationInfo.AddValue(System.String,System.Object)" />
      </summary>
    </member>
    <member name="F:Castle.DynamicProxy.Tokens.SerializationInfoMethods.GetValue">
      <summary>
        <see cref="M:System.Runtime.Serialization.SerializationInfo.GetValue(System.String,System.Type)" />
      </summary>
    </member>
    <member name="F:Castle.DynamicProxy.Tokens.SerializationInfoMethods.SetType">
      <summary>
        <see cref="M:System.Runtime.Serialization.SerializationInfo.SetType(System.Type)" />
      </summary>
    </member>
    <member name="T:Castle.DynamicProxy.Generators.INamingScope">
      <summary>
              Represents the scope of uniquenes of names for types and their members
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.INamingScope.GetUniqueName(System.String)">
      <summary>
              Gets a unique name based on <paramref name="suggestedName" /></summary>
      <param name="suggestedName">Name suggested by the caller</param>
      <returns>Unique name based on <paramref name="suggestedName" />.</returns>
      <remarks>
              Implementers should provide name as closely resembling <paramref name="suggestedName" /> as possible.
              Generally if no collision occurs it is suggested to return suggested name, otherwise append sequential suffix.
              Implementers must return deterministic names, that is when <see cref="M:Castle.DynamicProxy.Generators.INamingScope.GetUniqueName(System.String)" /> is called twice 
              with the same suggested name, the same returned name should be provided each time. Non-deterministic return
              values, like appending random suffices will break serialization of proxies.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.INamingScope.SafeSubScope">
      <summary>
              Returns new, disposable naming scope. It is responsibilty of the caller to make sure that no naming collision
              with enclosing scope, or other subscopes is possible.
            </summary>
      <returns>New naming scope.</returns>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.InvocationTypeGenerator.GetBaseCtorArguments(System.Type,Castle.DynamicProxy.ProxyGenerationOptions,System.Reflection.ConstructorInfo@)">
      <summary>
              Generates the constructor for the class that extends
              <see cref="T:Castle.DynamicProxy.AbstractInvocation" /></summary>
      <param name="targetFieldType">
      </param>
      <param name="proxyGenerationOptions">
      </param>
      <param name="baseConstructor">
      </param>
    </member>
    <member name="T:Castle.Core.Resource.UncResource">
      <summary>
            Enable access to files on network shares
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.AbstractExtendedLoggerFactory.Create(System.Type)">
      <summary>
              Creates a new extended logger, getting the logger name from the specified type.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.AbstractExtendedLoggerFactory.Create(System.String)">
      <summary>
              Creates a new extended logger.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.AbstractExtendedLoggerFactory.Create(System.Type,Castle.Core.Logging.LoggerLevel)">
      <summary>
              Creates a new extended logger, getting the logger name from the specified type.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.AbstractExtendedLoggerFactory.Create(System.String,Castle.Core.Logging.LoggerLevel)">
      <summary>
              Creates a new extended logger.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.AbstractExtendedLoggerFactory.GetConfigFile(System.String)">
      <summary>
              Gets the configuration file.
            </summary>
      <param name="fileName">i.e. log4net.config</param>
      <returns>
      </returns>
    </member>
    <member name="T:Castle.DynamicProxy.IInterceptorSelector">
      <summary>
              Provides an extension point that allows proxies to choose specific interceptors on
              a per method basis.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.IInterceptorSelector.SelectInterceptors(System.Type,System.Reflection.MethodInfo,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Selects the interceptors that should intercept calls to the given <paramref name="method" />.
            </summary>
      <param name="type">The type declaring the method to intercept.</param>
      <param name="method">The method that will be intercepted.</param>
      <param name="interceptors">All interceptors registered with the proxy.</param>
      <returns>An array of interceptors to invoke upon calling the <paramref name="method" />.</returns>
      <remarks>
              This method is called only once per proxy instance, upon the first call to the
              <paramref name="method" />. Either an empty array or null are valid return values to indicate
              that no interceptor should intercept calls to the method. Although it is not advised, it is
              legal to return other <see cref="T:Castle.DynamicProxy.IInterceptor" /> implementations than these provided in
              <paramref name="interceptors" />.
            </remarks>
    </member>
    <member name="T:Castle.DynamicProxy.Serialization.ProxyObjectReference">
      <summary>
              Handles the deserialization of proxies.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.Serialization.ProxyObjectReference.ResetScope">
      <summary>
              Resets the <see cref="P:Castle.DynamicProxy.Serialization.ProxyObjectReference.ModuleScope" /> used for deserialization to a new scope.
            </summary>
      <remarks>
              This is useful for test cases.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.Serialization.ProxyObjectReference.SetScope(Castle.DynamicProxy.ModuleScope)">
      <summary>
              Resets the <see cref="P:Castle.DynamicProxy.Serialization.ProxyObjectReference.ModuleScope" /> used for deserialization to a given <paramref name="scope" />.
            </summary>
      <param name="scope"> The scope to be used for deserialization. </param>
      <remarks>
              By default, the deserialization process uses a different scope than the rest of the application, which can lead to multiple proxies
              being generated for the same type. By explicitly setting the deserialization scope to the application's scope, this can be avoided.
            </remarks>
    </member>
    <member name="P:Castle.DynamicProxy.Serialization.ProxyObjectReference.ModuleScope">
      <summary>
              Gets the <see cref="P:Castle.DynamicProxy.Serialization.ProxyObjectReference.ModuleScope" /> used for deserialization.
            </summary>
      <value> As <see cref="T:Castle.DynamicProxy.Serialization.ProxyObjectReference" /> has no way of automatically determining the scope used by the application (and the application might use more than one scope at the same time), <see cref="T:Castle.DynamicProxy.Serialization.ProxyObjectReference" /> uses a dedicated scope instance for deserializing proxy types. This instance can be reset and set to a specific value via <see cref="M:Castle.DynamicProxy.Serialization.ProxyObjectReference.ResetScope" /> and <see cref="M:Castle.DynamicProxy.Serialization.ProxyObjectReference.SetScope(Castle.DynamicProxy.ModuleScope)" /> . </value>
    </member>
    <member name="M:Castle.DynamicProxy.Internal.InternalsUtil.IsInternal(System.Reflection.MethodBase)">
      <summary>
              Determines whether the specified method is internal.
            </summary>
      <param name="method">The method.</param>
      <returns>
        <c>true</c> if the specified method is internal; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Castle.DynamicProxy.Internal.InternalsUtil.IsInternalToDynamicProxy(System.Reflection.Assembly)">
      <summary>
              Determines whether this assembly has internals visible to dynamic proxy.
            </summary>
      <param name="asm">The assembly to inspect.</param>
    </member>
    <member name="M:Castle.DynamicProxy.Internal.InternalsUtil.IsAccessible(System.Reflection.MethodBase)">
      <summary>
              Checks if the method is public or protected.
            </summary>
      <param name="method">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:Castle.DynamicProxy.Generators.Emitters.StindOpCodesDictionary">
      <summary>
              Provides appropriate Stind.X opcode 
              for the type of primitive value to be stored indirectly.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.Emitters.OpCodeUtil.EmitLoadIndirectOpCodeForType(System.Reflection.Emit.ILGenerator,System.Type)">
      <summary>
              Emits a load indirect opcode of the appropriate type for a value or object reference.
              Pops a pointer off the evaluation stack, dereferences it and loads
              a value of the specified type.
            </summary>
      <param name="gen">
      </param>
      <param name="type">
      </param>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.Emitters.OpCodeUtil.EmitLoadOpCodeForConstantValue(System.Reflection.Emit.ILGenerator,System.Object)">
      <summary>
              Emits a load opcode of the appropriate kind for a constant string or
              primitive value.
            </summary>
      <param name="gen">
      </param>
      <param name="value">
      </param>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.Emitters.OpCodeUtil.EmitLoadOpCodeForDefaultValueOfType(System.Reflection.Emit.ILGenerator,System.Type)">
      <summary>
              Emits a load opcode of the appropriate kind for the constant default value of a
              type, such as 0 for value types and null for reference types.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.Emitters.OpCodeUtil.EmitStoreIndirectOpCodeForType(System.Reflection.Emit.ILGenerator,System.Type)">
      <summary>
              Emits a store indirectopcode of the appropriate type for a value or object reference.
              Pops a value of the specified type and a pointer off the evaluation stack, and
              stores the value.
            </summary>
      <param name="gen">
      </param>
      <param name="type">
      </param>
    </member>
    <member name="M:Castle.DynamicProxy.Internal.AttributeUtil.AddDisassembler``1(Castle.DynamicProxy.IAttributeDisassembler)">
      <summary>
              Registers custom disassembler to handle disassembly of specified type of attributes.
            </summary>
      <typeparam name="TAttribute">Type of attributes to handle</typeparam>
      <param name="disassembler">Disassembler converting existing instances of Attributes to CustomAttributeBuilders</param>
      <remarks>
              When disassembling an attribute Dynamic Proxy will first check if an custom disassembler has been registered to handle attributes of that type, 
              and if none is found, it'll use the <see cref="P:Castle.DynamicProxy.Internal.AttributeUtil.FallbackDisassembler" />.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.Internal.AttributeUtil.ShouldSkipAttributeReplication(System.Type)">
      <summary>
              Attributes should be replicated if they are non-inheritable,
              but there are some special cases where the attributes means
              something to the CLR, where they should be skipped.
            </summary>
    </member>
    <member name="T:Castle.Core.Logging.LoggerLevel">
      <summary>
              Supporting Logger levels.
            </summary>
    </member>
    <member name="F:Castle.Core.Logging.LoggerLevel.Off">
      <summary>
              Logging will be off
            </summary>
    </member>
    <member name="F:Castle.Core.Logging.LoggerLevel.Fatal">
      <summary>
              Fatal logging level
            </summary>
    </member>
    <member name="F:Castle.Core.Logging.LoggerLevel.Error">
      <summary>
              Error logging level
            </summary>
    </member>
    <member name="F:Castle.Core.Logging.LoggerLevel.Warn">
      <summary>
              Warn logging level
            </summary>
    </member>
    <member name="F:Castle.Core.Logging.LoggerLevel.Info">
      <summary>
              Info logging level
            </summary>
    </member>
    <member name="F:Castle.Core.Logging.LoggerLevel.Debug">
      <summary>
              Debug logging level
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.PropertyDescriptor">
      <summary>
            Describes a dictionary property.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.PropertyDescriptor.#ctor">
      <summary>
            Initializes an empty <see cref="T:Castle.Components.DictionaryAdapter.PropertyDescriptor" /> class.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.PropertyDescriptor.#ctor(System.Reflection.PropertyInfo,System.Object[])">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Components.DictionaryAdapter.PropertyDescriptor" /> class.
            </summary>
      <param name="property">The property.</param>
      <param name="annotations">The annotations.</param>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.PropertyDescriptor.#ctor(System.Object[])">
      <summary>
            Initializes a new instance <see cref="T:Castle.Components.DictionaryAdapter.PropertyDescriptor" /> class.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.PropertyDescriptor.#ctor(Castle.Components.DictionaryAdapter.PropertyDescriptor,System.Boolean)">
      <summary>
             Copies an existinginstance of the <see cref="T:Castle.Components.DictionaryAdapter.PropertyDescriptor" /> class.
            </summary>
      <param name="source">
      </param>
      <param name="copyBehaviors">
      </param>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.PropertyDescriptor.GetKey(Castle.Components.DictionaryAdapter.IDictionaryAdapter,System.String,Castle.Components.DictionaryAdapter.PropertyDescriptor)">
      <summary>
            Gets the key.
            </summary>
      <param name="dictionaryAdapter">The dictionary adapter.</param>
      <param name="key">The key.</param>
      <param name="descriptor">The descriptor.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.PropertyDescriptor.GetPropertyValue(Castle.Components.DictionaryAdapter.IDictionaryAdapter,System.String,System.Object,Castle.Components.DictionaryAdapter.PropertyDescriptor,System.Boolean)">
      <summary>
            Gets the property value.
            </summary>
      <param name="dictionaryAdapter">The dictionary adapter.</param>
      <param name="key">The key.</param>
      <param name="storedValue">The stored value.</param>
      <param name="descriptor">The descriptor.</param>
      <param name="ifExists">true if return only existing.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.PropertyDescriptor.SetPropertyValue(Castle.Components.DictionaryAdapter.IDictionaryAdapter,System.String,System.Object@,Castle.Components.DictionaryAdapter.PropertyDescriptor)">
      <summary>
            Sets the property value.
            </summary>
      <param name="dictionaryAdapter">The dictionary adapter.</param>
      <param name="key">The key.</param>
      <param name="value">The value.</param>
      <param name="descriptor">The descriptor.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.PropertyDescriptor.AddBehavior(Castle.Components.DictionaryAdapter.IDictionaryBehavior)">
      <summary>
            Adds a single behavior.
            </summary>
      <param name="behavior">The behavior.</param>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.PropertyDescriptor.AddBehaviors(Castle.Components.DictionaryAdapter.IDictionaryBehavior[])">
      <summary>
            Adds the behaviors.
            </summary>
      <param name="behaviors">The behaviors.</param>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.PropertyDescriptor.AddBehaviors(System.Collections.Generic.IEnumerable{Castle.Components.DictionaryAdapter.IDictionaryBehavior})">
      <summary>
            Adds the behaviors.
            </summary>
      <param name="behaviors">The behaviors.</param>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.PropertyDescriptor.CopyBehaviors(Castle.Components.DictionaryAdapter.PropertyDescriptor)">
      <summary>
            Copies the behaviors to the other <see cref="T:Castle.Components.DictionaryAdapter.PropertyDescriptor" /></summary>
      <param name="other">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.PropertyDescriptor.Copy">
      <summary>
            Copies the <see cref="T:Castle.Components.DictionaryAdapter.PropertyDescriptor" /></summary>
      <returns>
      </returns>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.PropertyDescriptor.ExecutionOrder">
      <summary>
      </summary>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.PropertyDescriptor.PropertyName">
      <summary>
            Gets the property name.
            </summary>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.PropertyDescriptor.PropertyType">
      <summary>
            Gets the property type.
            </summary>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.PropertyDescriptor.Property">
      <summary>
            Gets the property.
            </summary>
      <value>The property.</value>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.PropertyDescriptor.IsDynamicProperty">
      <summary>
            Returns true if the property is dynamic.
            </summary>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.PropertyDescriptor.State">
      <summary>
            Gets additional state.
            </summary>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.PropertyDescriptor.Fetch">
      <summary>
            Determines if property should be fetched.
            </summary>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.PropertyDescriptor.IfExists">
      <summary>
            Determines if property must exist first.
            </summary>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.PropertyDescriptor.SuppressNotifications">
      <summary>
            Determines if notifications should occur.
            </summary>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.PropertyDescriptor.Annotations">
      <summary>
            Gets the property behaviors.
            </summary>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.PropertyDescriptor.TypeConverter">
      <summary>
            Gets the type converter.
            </summary>
      <value>The type converter.</value>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.PropertyDescriptor.ExtendedProperties">
      <summary>
            Gets the extended properties.
            </summary>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.PropertyDescriptor.Behaviors">
      <summary>
            Gets the setter.
            </summary>
      <value>The setter.</value>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.PropertyDescriptor.KeyBuilders">
      <summary>
            Gets the key builders.
            </summary>
      <value>The key builders.</value>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.PropertyDescriptor.Setters">
      <summary>
            Gets the setter.
            </summary>
      <value>The setter.</value>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.PropertyDescriptor.Getters">
      <summary>
            Gets the getter.
            </summary>
      <value>The getter.</value>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.PropertyDescriptor.Initializers">
      <summary>
            Gets the initializers.
            </summary>
      <value>The initializers.</value>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.PropertyDescriptor.MetaInitializers">
      <summary>
            Gets the meta-data initializers.
            </summary>
      <value>The meta-data initializers.</value>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.StringValuesAttribute">
      <summary>
            Converts all properties to strings.
            </summary>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.StringValuesAttribute.Format">
      <summary>
            Gets or sets the format.
            </summary>
      <value>The format.</value>
    </member>
    <member name="F:Castle.Core.Internal.InternalsVisible.ToCastleCore">
      <summary>
              Constant to use when making assembly internals visible to Castle.Core 
              <c>[assembly: InternalsVisibleTo(CoreInternalsVisible.ToCastleCore)]</c></summary>
    </member>
    <member name="F:Castle.Core.Internal.InternalsVisible.ToDynamicProxyGenAssembly2">
      <summary>
              Constant to use when making assembly internals visible to proxy types generated by DynamicProxy. Required when proxying internal types.
              <c>[assembly: InternalsVisibleTo(CoreInternalsVisible.ToDynamicProxyGenAssembly2)]</c></summary>
    </member>
    <member name="M:Castle.Core.Internal.CollectionExtensions.IsNullOrEmpty(System.Collections.IEnumerable)">
      <summary>
              Checks whether or not collection is null or empty. Assumes colleciton can be safely enumerated multiple times.
            </summary>
      <param name="this">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:Castle.Core.Logging.IExtendedLogger">
      <summary>
              Provides an interface that supports <see cref="T:Castle.Core.Logging.ILogger" /> and
              allows the storage and retrieval of Contexts. These are supported in
              both log4net and NLog.
            </summary>
    </member>
    <member name="P:Castle.Core.Logging.IExtendedLogger.GlobalProperties">
      <summary>
              Exposes the Global Context of the extended logger.
            </summary>
    </member>
    <member name="P:Castle.Core.Logging.IExtendedLogger.ThreadProperties">
      <summary>
              Exposes the Thread Context of the extended logger.
            </summary>
    </member>
    <member name="P:Castle.Core.Logging.IExtendedLogger.ThreadStacks">
      <summary>
              Exposes the Thread Stack of the extended logger.
            </summary>
    </member>
    <member name="T:Castle.Core.IServiceProviderEx">
      <summary>
            Increments <c>IServiceProvider</c> with a generic service resolution operation.
            </summary>
    </member>
    <member name="T:Castle.Core.IServiceEnabledComponent">
      <summary>
            Defines that the implementation wants a 
            <see cref="T:System.IServiceProvider" /> in order to 
            access other components. The creator must be aware
            that the component might (or might not) implement 
            the interface.
            </summary>
      <remarks>
            Used by Castle Project components to, for example, 
            gather logging factories
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.CacheKey.#ctor(System.Reflection.MemberInfo,System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.DynamicProxy.Generators.CacheKey" /> class.
            </summary>
      <param name="target">Target element. This is either target type or target method for invocation types.</param>
      <param name="type">The type of the proxy. This is base type for invocation types.</param>
      <param name="interfaces">The interfaces.</param>
      <param name="options">The options.</param>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.CacheKey.#ctor(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.DynamicProxy.Generators.CacheKey" /> class.
            </summary>
      <param name="target">Type of the target.</param>
      <param name="interfaces">The interfaces.</param>
      <param name="options">The options.</param>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.MultiLevelEditAttribute">
      <summary>
            Requests support for multi-level editing.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.IfExistsAttribute">
      <summary>
            Suppresses any on-demand behaviors.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.ReferenceAttribute">
      <summary>
            Specifies assignment by reference rather than by copying.
            </summary>
    </member>
    <member name="T:Castle.Core.Logging.DiagnosticsLogger">
      <summary>
              The Logger using standart Diagnostics namespace.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.DiagnosticsLogger.#ctor(System.String)">
      <summary>
              Creates a logger based on <see cref="T:System.Diagnostics.EventLog" />.
            </summary>
      <param name="logName">
        <see cref="P:System.Diagnostics.EventLog.Log" />
      </param>
    </member>
    <member name="M:Castle.Core.Logging.DiagnosticsLogger.#ctor(System.String,System.String)">
      <summary>
              Creates a logger based on <see cref="T:System.Diagnostics.EventLog" />.
            </summary>
      <param name="logName">
        <see cref="P:System.Diagnostics.EventLog.Log" />
      </param>
      <param name="source">
        <see cref="P:System.Diagnostics.EventLog.Source" />
      </param>
    </member>
    <member name="M:Castle.Core.Logging.DiagnosticsLogger.#ctor(System.String,System.String,System.String)">
      <summary>
              Creates a logger based on <see cref="T:System.Diagnostics.EventLog" />.
            </summary>
      <param name="logName">
        <see cref="P:System.Diagnostics.EventLog.Log" />
      </param>
      <param name="machineName">
        <see cref="P:System.Diagnostics.EventLog.MachineName" />
      </param>
      <param name="source">
        <see cref="P:System.Diagnostics.EventLog.Source" />
      </param>
    </member>
    <member name="T:Castle.Core.Logging.StreamLoggerFactory">
      <summary>
              Creates <see cref="T:Castle.Core.Logging.StreamLogger" /> outputing 
              to files. The name of the file is derived from the log name
              plus the 'log' extension.
            </summary>
    </member>
    <member name="T:Castle.DynamicProxy.Tokens.InvocationMethods">
      <summary>
              Holds <see cref="T:System.Reflection.MethodInfo" /> objects representing methods of <see cref="T:Castle.DynamicProxy.AbstractInvocation" /> class.
            </summary>
    </member>
    <member name="T:Castle.DynamicProxy.Generators.MethodFinder">
      <summary>
              Returns the methods implemented by a type. Use this instead of Type.GetMethods() to work around a CLR issue
              where duplicate MethodInfos are returned by Type.GetMethods() after a token of a generic type's method was loaded.
            </summary>
    </member>
    <member name="T:Castle.DynamicProxy.Generators.Emitters.PropertiesCollection">
      <summary>
              Summary description for PropertiesCollection.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.AttributeDisassembler.HandleError(System.Type,System.Exception)">
      <summary>
              Handles error during disassembly process
            </summary>
      <param name="attributeType">Type of the attribute being disassembled</param>
      <param name="exception">Exception thrown during the process</param>
      <returns>usually null, or (re)throws the exception</returns>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.AttributeDisassembler.InitializeConstructorArgs(System.Type,System.Attribute,System.Reflection.ParameterInfo[])">
      <summary>
              Here we try to match a constructor argument to its value.
              Since we can't get the values from the assembly, we use some heuristics to get it.
              a/ we first try to match all the properties on the attributes by name (case insensitive) to the argument
              b/ if we fail we try to match them by property type, with some smarts about convertions (i,e: can use Guid for string).
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.AttributeDisassembler.ReplaceIfBetterMatch(System.Reflection.ParameterInfo,System.Reflection.PropertyInfo,System.Reflection.PropertyInfo)">
      <summary>
              We have the following rules here.
              Try to find a matching type, failing that, if the parameter is string, get the first property (under the assumption that
              we can convert it.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.AttributeDisassembler.ConvertValue(System.Object,System.Type)">
      <summary>
              Attributes can only accept simple types, so we return null for null,
              if the value is passed as string we call to string (should help with converting), 
              otherwise, we use the value as is (enums, integer, etc).
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.StringFormatAttribute">
      <summary>
            Provides simple string formatting from existing properties.
            </summary>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.StringFormatAttribute.Format">
      <summary>
            Gets the string format.
            </summary>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.StringFormatAttribute.Properties">
      <summary>
            Gets the format properties.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.KeyAttribute">
      <summary>
            Assigns a specific dictionary key.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.KeyAttribute.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Components.DictionaryAdapter.KeyAttribute" /> class.
            </summary>
      <param name="key">The key.</param>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.KeyAttribute.#ctor(System.String[])">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Components.DictionaryAdapter.KeyAttribute" /> class.
            </summary>
      <param name="keys">The compound key.</param>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.RemoveIfEmptyAttribute">
      <summary>
            Removes a property if null or empty string, guid or collection.
            </summary>
    </member>
    <member name="T:Castle.Core.Logging.ConsoleLogger">
      <summary>
            The Logger sending everything to the standard output streams.
            This is mainly for the cases when you have a utility that
            does not have a logger to supply.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.ConsoleLogger.#ctor">
      <summary>
              Creates a new ConsoleLogger with the <c>Level</c>
              set to <c>LoggerLevel.Debug</c> and the <c>Name</c>
              set to <c>String.Empty</c>.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.ConsoleLogger.#ctor(Castle.Core.Logging.LoggerLevel)">
      <summary>
              Creates a new ConsoleLogger with the <c>Name</c>
              set to <c>String.Empty</c>.
            </summary>
      <param name="logLevel">The logs Level.</param>
    </member>
    <member name="M:Castle.Core.Logging.ConsoleLogger.#ctor(System.String)">
      <summary>
              Creates a new ConsoleLogger with the <c>Level</c>
              set to <c>LoggerLevel.Debug</c>.
            </summary>
      <param name="name">The logs Name.</param>
    </member>
    <member name="M:Castle.Core.Logging.ConsoleLogger.#ctor(System.String,Castle.Core.Logging.LoggerLevel)">
      <summary>
              Creates a new ConsoleLogger.
            </summary>
      <param name="name">The logs Name.</param>
      <param name="logLevel">The logs Level.</param>
    </member>
    <member name="M:Castle.Core.Logging.ConsoleLogger.Log(Castle.Core.Logging.LoggerLevel,System.String,System.String,System.Exception)">
      <summary>
              A Common method to log.
            </summary>
      <param name="loggerLevel">The level of logging</param>
      <param name="loggerName">The name of the logger</param>
      <param name="message">The Message</param>
      <param name="exception">The Exception</param>
    </member>
    <member name="M:Castle.Core.Logging.ConsoleLogger.CreateChildLogger(System.String)">
      <summary>
              Returns a new <c>ConsoleLogger</c> with the name
              added after this loggers name, with a dot in between.
            </summary>
      <param name="loggerName">The added hierarchical name.</param>
      <returns>A new <c>ConsoleLogger</c>.</returns>
    </member>
    <member name="T:Castle.DynamicProxy.IChangeProxyTarget">
      <summary>
              Exposes means to change target objects of proxies and invocations
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.IChangeProxyTarget.ChangeInvocationTarget(System.Object)">
      <summary>
              Changes the target object (<see cref="P:Castle.DynamicProxy.IInvocation.InvocationTarget" />) of current <see cref="T:Castle.DynamicProxy.IInvocation" />.
            </summary>
      <param name="target">The new value of target of invocation.</param>
      <remarks>
              Although the method takes <see cref="T:System.Object" /> the actual instance must be of type assignable to <see cref="P:Castle.DynamicProxy.IInvocation.TargetType" />, otherwise an <see cref="T:System.InvalidCastException" /> will be thrown.
              Also while it's technically legal to pass null reference (Nothing in Visual Basic) as <paramref name="target" />, for obvious reasons Dynamic Proxy will not be able to call the intercepted method on such target.
              In this case last interceptor in the pipeline mustn't call <see cref="M:Castle.DynamicProxy.IInvocation.Proceed" /> or a <see cref="T:System.NotImplementedException" /> will be throws.
              Also while it's technically legal to pass proxy itself as <paramref name="target" />, this would create stack overflow.
              In this case last interceptor in the pipeline mustn't call <see cref="M:Castle.DynamicProxy.IInvocation.Proceed" /> or a <see cref="T:System.InvalidOperationException" /> will be throws.
            </remarks>
      <exception cref="T:System.InvalidCastException">Thrown when <paramref name="target" /> is not assignable to the proxied type.</exception>
    </member>
    <member name="M:Castle.DynamicProxy.IChangeProxyTarget.ChangeProxyTarget(System.Object)">
      <summary>
              Permanently changes the target object of the proxy. This does not affect target of the current invocation.
            </summary>
      <param name="target">The new value of target of the proxy.</param>
      <remarks>
              Although the method takes <see cref="T:System.Object" /> the actual instance must be of type assignable to proxy's target type, otherwise an <see cref="T:System.InvalidCastException" /> will be thrown.
              Also while it's technically legal to pass null reference (Nothing in Visual Basic) as <paramref name="target" />, for obvious reasons Dynamic Proxy will not be able to call the intercepted method on such target.
              In this case last interceptor in the pipeline mustn't call <see cref="M:Castle.DynamicProxy.IInvocation.Proceed" /> or a <see cref="T:System.NotImplementedException" /> will be throws.
              Also while it's technically legal to pass proxy itself as <paramref name="target" />, this would create stack overflow.
              In this case last interceptor in the pipeline mustn't call <see cref="M:Castle.DynamicProxy.IInvocation.Proceed" /> or a <see cref="T:System.InvalidOperationException" /> will be throws.
            </remarks>
      <exception cref="T:System.InvalidCastException">Thrown when <paramref name="target" /> is not assignable to the proxied type.</exception>
    </member>
    <member name="T:Castle.Core.IServiceProviderExAccessor">
      <summary>
            This interface should be implemented by classes
            that are available in a bigger context, exposing
            the container to different areas in the same application.
            <para>
            For example, in Web application, the (global) HttpApplication
            subclasses should implement this interface to expose 
            the configured container
            </para></summary>
    </member>
    <member name="T:Castle.DynamicProxy.Generators.Emitters.SimpleAST.ReferencesToObjectArrayExpression">
      <summary>
      </summary>
    </member>
    <member name="T:Castle.Core.Configuration.ConfigurationCollection">
      <summary>
            A collection of <see cref="T:Castle.Core.Configuration.IConfiguration" /> objects.
            </summary>
    </member>
    <member name="M:Castle.Core.Configuration.ConfigurationCollection.#ctor">
      <summary>
            Creates a new instance of <c>ConfigurationCollection</c>.
            </summary>
    </member>
    <member name="M:Castle.Core.Configuration.ConfigurationCollection.#ctor(System.Collections.Generic.IEnumerable{Castle.Core.Configuration.IConfiguration})">
      <summary>
            Creates a new instance of <c>ConfigurationCollection</c>.
            </summary>
    </member>
    <member name="T:Castle.Core.Logging.NullLogger">
      <summary>
              The Null Logger class.  This is useful for implementations where you need
              to provide a logger to a utility class, but do not want any output from it.
              It also helps when you have a utility that does not have a logger to supply.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.CreateChildLogger(System.String)">
      <summary>
              Returns this <c>NullLogger</c>.
            </summary>
      <param name="loggerName">Ignored</param>
      <returns>This ILogger instance.</returns>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Debug(System.String)">
      <summary>
              No-op.
            </summary>
      <param name="message">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Debug(System.String,System.Exception)">
      <summary>
              No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="message">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.DebugFormat(System.String,System.Object[])">
      <summary>
              No-op.
            </summary>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.DebugFormat(System.Exception,System.String,System.Object[])">
      <summary>
              No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.DebugFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
              No-op.
            </summary>
      <param name="formatProvider">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.DebugFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
              No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="formatProvider">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Error(System.String)">
      <summary>
              No-op.
            </summary>
      <param name="message">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Error(System.String,System.Exception)">
      <summary>
              No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="message">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.ErrorFormat(System.String,System.Object[])">
      <summary>
              No-op.
            </summary>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.ErrorFormat(System.Exception,System.String,System.Object[])">
      <summary>
              No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.ErrorFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
              No-op.
            </summary>
      <param name="formatProvider">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.ErrorFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
              No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="formatProvider">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Fatal(System.String)">
      <summary>
              No-op.
            </summary>
      <param name="message">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Fatal(System.String,System.Exception)">
      <summary>
              No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="message">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.FatalFormat(System.String,System.Object[])">
      <summary>
              No-op.
            </summary>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.FatalFormat(System.Exception,System.String,System.Object[])">
      <summary>
              No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.FatalFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
              No-op.
            </summary>
      <param name="formatProvider">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.FatalFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
              No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="formatProvider">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Info(System.String)">
      <summary>
              No-op.
            </summary>
      <param name="message">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Info(System.String,System.Exception)">
      <summary>
              No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="message">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.InfoFormat(System.String,System.Object[])">
      <summary>
              No-op.
            </summary>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.InfoFormat(System.Exception,System.String,System.Object[])">
      <summary>
              No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.InfoFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
              No-op.
            </summary>
      <param name="formatProvider">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.InfoFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
              No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="formatProvider">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Warn(System.String)">
      <summary>
              No-op.
            </summary>
      <param name="message">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Warn(System.String,System.Exception)">
      <summary>
              No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="message">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.WarnFormat(System.String,System.Object[])">
      <summary>
              No-op.
            </summary>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.WarnFormat(System.Exception,System.String,System.Object[])">
      <summary>
              No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.WarnFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
              No-op.
            </summary>
      <param name="formatProvider">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.WarnFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
              No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="formatProvider">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="P:Castle.Core.Logging.NullLogger.GlobalProperties">
      <summary>
              Returns empty context properties.
            </summary>
    </member>
    <member name="P:Castle.Core.Logging.NullLogger.ThreadProperties">
      <summary>
              Returns empty context properties.
            </summary>
    </member>
    <member name="P:Castle.Core.Logging.NullLogger.ThreadStacks">
      <summary>
              Returns empty context stacks.
            </summary>
    </member>
    <member name="P:Castle.Core.Logging.NullLogger.IsDebugEnabled">
      <summary>
              No-op.
            </summary>
      <value>false</value>
    </member>
    <member name="P:Castle.Core.Logging.NullLogger.IsErrorEnabled">
      <summary>
              No-op.
            </summary>
      <value>false</value>
    </member>
    <member name="P:Castle.Core.Logging.NullLogger.IsFatalEnabled">
      <summary>
              No-op.
            </summary>
      <value>false</value>
    </member>
    <member name="P:Castle.Core.Logging.NullLogger.IsInfoEnabled">
      <summary>
              No-op.
            </summary>
      <value>false</value>
    </member>
    <member name="P:Castle.Core.Logging.NullLogger.IsWarnEnabled">
      <summary>
              No-op.
            </summary>
      <value>false</value>
    </member>
    <member name="T:Castle.DynamicProxy.IInterceptor">
      <summary>
              New interface that is going to be used by DynamicProxy 2
            </summary>
    </member>
    <member name="T:Castle.DynamicProxy.ModuleScope">
      <summary>
              Summary description for ModuleScope.
            </summary>
    </member>
    <member name="F:Castle.DynamicProxy.ModuleScope.DEFAULT_FILE_NAME">
      <summary>
              The default file name used when the assembly is saved using <see cref="F:Castle.DynamicProxy.ModuleScope.DEFAULT_FILE_NAME" />.
            </summary>
    </member>
    <member name="F:Castle.DynamicProxy.ModuleScope.DEFAULT_ASSEMBLY_NAME">
      <summary>
              The default assembly (simple) name used for the assemblies generated by a <see cref="T:Castle.DynamicProxy.ModuleScope" /> instance.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.ModuleScope.#ctor">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.DynamicProxy.ModuleScope" /> class; assemblies created by this instance will not be saved.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.ModuleScope.#ctor(System.Boolean)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.DynamicProxy.ModuleScope" /> class, allowing to specify whether the assemblies generated by this instance
              should be saved.
            </summary>
      <param name="savePhysicalAssembly">If set to <c>true</c> saves the generated module.</param>
    </member>
    <member name="M:Castle.DynamicProxy.ModuleScope.#ctor(System.Boolean,System.Boolean)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.DynamicProxy.ModuleScope" /> class, allowing to specify whether the assemblies generated by this instance
              should be saved.
            </summary>
      <param name="savePhysicalAssembly">If set to <c>true</c> saves the generated module.</param>
      <param name="disableSignedModule">If set to <c>true</c> disables ability to generate signed module. This should be used in cases where ran under constrained permissions.</param>
    </member>
    <member name="M:Castle.DynamicProxy.ModuleScope.#ctor(System.Boolean,System.Boolean,System.String,System.String,System.String,System.String)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.DynamicProxy.ModuleScope" /> class, allowing to specify whether the assemblies generated by this instance
              should be saved and what simple names are to be assigned to them.
            </summary>
      <param name="savePhysicalAssembly">If set to <c>true</c> saves the generated module.</param>
      <param name="disableSignedModule">If set to <c>true</c> disables ability to generate signed module. This should be used in cases where ran under constrained permissions.</param>
      <param name="strongAssemblyName">The simple name of the strong-named assembly generated by this <see cref="T:Castle.DynamicProxy.ModuleScope" />.</param>
      <param name="strongModulePath">The path and file name of the manifest module of the strong-named assembly generated by this <see cref="T:Castle.DynamicProxy.ModuleScope" />.</param>
      <param name="weakAssemblyName">The simple name of the weak-named assembly generated by this <see cref="T:Castle.DynamicProxy.ModuleScope" />.</param>
      <param name="weakModulePath">The path and file name of the manifest module of the weak-named assembly generated by this <see cref="T:Castle.DynamicProxy.ModuleScope" />.</param>
    </member>
    <member name="M:Castle.DynamicProxy.ModuleScope.#ctor(System.Boolean,System.Boolean,Castle.DynamicProxy.Generators.INamingScope,System.String,System.String,System.String,System.String)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.DynamicProxy.ModuleScope" /> class, allowing to specify whether the assemblies generated by this instance
              should be saved and what simple names are to be assigned to them.
            </summary>
      <param name="savePhysicalAssembly">If set to <c>true</c> saves the generated module.</param>
      <param name="disableSignedModule">If set to <c>true</c> disables ability to generate signed module. This should be used in cases where ran under constrained permissions.</param>
      <param name="namingScope">Naming scope used to provide unique names to generated types and their members (usually via sub-scopes).</param>
      <param name="strongAssemblyName">The simple name of the strong-named assembly generated by this <see cref="T:Castle.DynamicProxy.ModuleScope" />.</param>
      <param name="strongModulePath">The path and file name of the manifest module of the strong-named assembly generated by this <see cref="T:Castle.DynamicProxy.ModuleScope" />.</param>
      <param name="weakAssemblyName">The simple name of the weak-named assembly generated by this <see cref="T:Castle.DynamicProxy.ModuleScope" />.</param>
      <param name="weakModulePath">The path and file name of the manifest module of the weak-named assembly generated by this <see cref="T:Castle.DynamicProxy.ModuleScope" />.</param>
    </member>
    <member name="M:Castle.DynamicProxy.ModuleScope.GetFromCache(Castle.DynamicProxy.Generators.CacheKey)">
      <summary>
              Returns a type from this scope's type cache, or null if the key cannot be found.
            </summary>
      <param name="key">The key to be looked up in the cache.</param>
      <returns>The type from this scope's type cache matching the key, or null if the key cannot be found</returns>
    </member>
    <member name="M:Castle.DynamicProxy.ModuleScope.RegisterInCache(Castle.DynamicProxy.Generators.CacheKey,System.Type)">
      <summary>
              Registers a type in this scope's type cache.
            </summary>
      <param name="key">The key to be associated with the type.</param>
      <param name="type">The type to be stored in the cache.</param>
    </member>
    <member name="M:Castle.DynamicProxy.ModuleScope.GetKeyPair">
      <summary>
              Gets the key pair used to sign the strong-named assembly generated by this <see cref="T:Castle.DynamicProxy.ModuleScope" />.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.DynamicProxy.ModuleScope.ObtainDynamicModule(System.Boolean)">
      <summary>
              Gets the specified module generated by this scope, creating a new one if none has yet been generated.
            </summary>
      <param name="isStrongNamed">If set to true, a strong-named module is returned; otherwise, a weak-named module is returned.</param>
      <returns>A strong-named or weak-named module generated by this scope, as specified by the <paramref name="isStrongNamed" /> parameter.</returns>
    </member>
    <member name="M:Castle.DynamicProxy.ModuleScope.ObtainDynamicModuleWithStrongName">
      <summary>
              Gets the strong-named module generated by this scope, creating a new one if none has yet been generated.
            </summary>
      <returns>A strong-named module generated by this scope.</returns>
    </member>
    <member name="M:Castle.DynamicProxy.ModuleScope.ObtainDynamicModuleWithWeakName">
      <summary>
              Gets the weak-named module generated by this scope, creating a new one if none has yet been generated.
            </summary>
      <returns>A weak-named module generated by this scope.</returns>
    </member>
    <member name="M:Castle.DynamicProxy.ModuleScope.SaveAssembly">
      <summary>
              Saves the generated assembly with the name and directory information given when this <see cref="T:Castle.DynamicProxy.ModuleScope" /> instance was created (or with
              the <see cref="F:Castle.DynamicProxy.ModuleScope.DEFAULT_FILE_NAME" /> and current directory if none was given).
            </summary>
      <remarks>
        <para>
                This method stores the generated assembly in the directory passed as part of the module information specified when this instance was
                constructed (if any, else the current directory is used). If both a strong-named and a weak-named assembly
                have been generated, it will throw an exception; in this case, use the <see cref="M:Castle.DynamicProxy.ModuleScope.SaveAssembly(System.Boolean)" /> overload.
              </para>
        <para>
                If this <see cref="T:Castle.DynamicProxy.ModuleScope" /> was created without indicating that the assembly should be saved, this method does nothing.
              </para>
      </remarks>
      <exception cref="T:System.InvalidOperationException">Both a strong-named and a weak-named assembly have been generated.</exception>
      <returns>The path of the generated assembly file, or null if no file has been generated.</returns>
    </member>
    <member name="M:Castle.DynamicProxy.ModuleScope.SaveAssembly(System.Boolean)">
      <summary>
              Saves the specified generated assembly with the name and directory information given when this <see cref="T:Castle.DynamicProxy.ModuleScope" /> instance was created
              (or with the <see cref="F:Castle.DynamicProxy.ModuleScope.DEFAULT_FILE_NAME" /> and current directory if none was given).
            </summary>
      <param name="strongNamed">True if the generated assembly with a strong name should be saved (see <see cref="P:Castle.DynamicProxy.ModuleScope.StrongNamedModule" />);
              false if the generated assembly without a strong name should be saved (see <see cref="P:Castle.DynamicProxy.ModuleScope.WeakNamedModule" />.</param>
      <remarks>
        <para>
                This method stores the specified generated assembly in the directory passed as part of the module information specified when this instance was
                constructed (if any, else the current directory is used).
              </para>
        <para>
                If this <see cref="T:Castle.DynamicProxy.ModuleScope" /> was created without indicating that the assembly should be saved, this method does nothing.
              </para>
      </remarks>
      <exception cref="T:System.InvalidOperationException">No assembly has been generated that matches the <paramref name="strongNamed" /> parameter.
            </exception>
      <returns>The path of the generated assembly file, or null if no file has been generated.</returns>
    </member>
    <member name="M:Castle.DynamicProxy.ModuleScope.LoadAssemblyIntoCache(System.Reflection.Assembly)">
      <summary>
              Loads the generated types from the given assembly into this <see cref="T:Castle.DynamicProxy.ModuleScope" />'s cache.
            </summary>
      <param name="assembly">The assembly to load types from. This assembly must have been saved via <see cref="M:Castle.DynamicProxy.ModuleScope.SaveAssembly(System.Boolean)" /> or
              <see cref="M:Castle.DynamicProxy.ModuleScope.SaveAssembly" />, or it must have the <see cref="T:Castle.DynamicProxy.Serialization.CacheMappingsAttribute" /> manually applied.</param>
      <remarks>
              This method can be used to load previously generated and persisted proxy types from disk into this scope's type cache, eg. in order
              to avoid the performance hit associated with proxy generation.
            </remarks>
    </member>
    <member name="P:Castle.DynamicProxy.ModuleScope.Lock">
      <summary>
              Users of this <see cref="T:Castle.DynamicProxy.ModuleScope" /> should use this lock when accessing the cache.
            </summary>
    </member>
    <member name="P:Castle.DynamicProxy.ModuleScope.StrongNamedModule">
      <summary>
              Gets the strong-named module generated by this scope, or <see langword="null" /> if none has yet been generated.
            </summary>
      <value>The strong-named module generated by this scope, or <see langword="null" /> if none has yet been generated.</value>
    </member>
    <member name="P:Castle.DynamicProxy.ModuleScope.StrongNamedModuleName">
      <summary>
              Gets the file name of the strongly named module generated by this scope.
            </summary>
      <value>The file name of the strongly named module generated by this scope.</value>
    </member>
    <member name="P:Castle.DynamicProxy.ModuleScope.StrongNamedModuleDirectory">
      <summary>
              Gets the directory where the strongly named module generated by this scope will be saved, or <see langword="null" /> if the current directory
              is used.
            </summary>
      <value>The directory where the strongly named module generated by this scope will be saved when <see cref="M:Castle.DynamicProxy.ModuleScope.SaveAssembly" /> is called
              (if this scope was created to save modules).</value>
    </member>
    <member name="P:Castle.DynamicProxy.ModuleScope.WeakNamedModule">
      <summary>
              Gets the weak-named module generated by this scope, or <see langword="null" /> if none has yet been generated.
            </summary>
      <value>The weak-named module generated by this scope, or <see langword="null" /> if none has yet been generated.</value>
    </member>
    <member name="P:Castle.DynamicProxy.ModuleScope.WeakNamedModuleName">
      <summary>
              Gets the file name of the weakly named module generated by this scope.
            </summary>
      <value>The file name of the weakly named module generated by this scope.</value>
    </member>
    <member name="P:Castle.DynamicProxy.ModuleScope.WeakNamedModuleDirectory">
      <summary>
              Gets the directory where the weakly named module generated by this scope will be saved, or <see langword="null" /> if the current directory
              is used.
            </summary>
      <value>The directory where the weakly named module generated by this scope will be saved when <see cref="M:Castle.DynamicProxy.ModuleScope.SaveAssembly" /> is called
              (if this scope was created to save modules).</value>
    </member>
    <member name="T:Castle.Core.Smtp.IEmailSender">
      <summary>
            Email sender abstraction.
            </summary>
    </member>
    <member name="M:Castle.Core.Smtp.IEmailSender.Send(System.String,System.String,System.String,System.String)">
      <summary>
            Sends a mail message.
            </summary>
      <param name="from">From field</param>
      <param name="to">To field</param>
      <param name="subject">E-mail's subject</param>
      <param name="messageText">message's body</param>
    </member>
    <member name="M:Castle.Core.Smtp.IEmailSender.Send(System.Net.Mail.MailMessage)">
      <summary>
            Sends a <see cref="T:System.Net.Mail.MailMessage">message</see>. 
            </summary>
      <param name="message">
        <see cref="T:System.Net.Mail.MailMessage">Message</see> instance</param>
    </member>
    <member name="M:Castle.Core.Smtp.IEmailSender.Send(System.Collections.Generic.IEnumerable{System.Net.Mail.MailMessage})">
      <summary>
            Sends multiple <see cref="T:System.Net.Mail.MailMessage">messages</see>. 
            </summary>
      <param name="messages">List of <see cref="T:System.Net.Mail.MailMessage">messages</see></param>
    </member>
    <member name="T:Castle.Core.Smtp.DefaultSmtpSender">
      <summary>
            Default <see cref="T:Castle.Core.Smtp.IEmailSender" /> implementation.
            </summary>
    </member>
    <member name="M:Castle.Core.Smtp.DefaultSmtpSender.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.Smtp.DefaultSmtpSender" /> class based on the <see cref="T:System.Net.Mail.SmtpClient" /> configuration provided in the application configuration file.
            </summary>
      <remarks>
            This constructor is based on the default <see cref="T:System.Net.Mail.SmtpClient" /> configuration in the application configuration file.
            </remarks>
    </member>
    <member name="M:Castle.Core.Smtp.DefaultSmtpSender.#ctor(System.String)">
      <summary>
            This service implementation
            requires a host name in order to work
            </summary>
      <param name="hostname">The smtp server name</param>
    </member>
    <member name="M:Castle.Core.Smtp.DefaultSmtpSender.Send(System.String,System.String,System.String,System.String)">
      <summary>
            Sends a message. 
            </summary>
      <exception cref="T:System.ArgumentNullException">If any of the parameters is null</exception>
      <param name="from">From field</param>
      <param name="to">To field</param>
      <param name="subject">e-mail's subject</param>
      <param name="messageText">message's body</param>
    </member>
    <member name="M:Castle.Core.Smtp.DefaultSmtpSender.Send(System.Net.Mail.MailMessage)">
      <summary>
            Sends a message. 
            </summary>
      <exception cref="T:System.ArgumentNullException">If the message is null</exception>
      <param name="message">Message instance</param>
    </member>
    <member name="M:Castle.Core.Smtp.DefaultSmtpSender.Configure(System.Net.Mail.SmtpClient)">
      <summary>
            Configures the sender
            with port information and eventual credential
            informed
            </summary>
      <param name="smtpClient">Message instance</param>
    </member>
    <member name="P:Castle.Core.Smtp.DefaultSmtpSender.Port">
      <summary>
            Gets or sets the port used to 
            access the SMTP server
            </summary>
    </member>
    <member name="P:Castle.Core.Smtp.DefaultSmtpSender.Hostname">
      <summary>
            Gets the hostname.
            </summary>
      <value>The hostname.</value>
    </member>
    <member name="P:Castle.Core.Smtp.DefaultSmtpSender.AsyncSend">
      <summary>
            Gets or sets a value which is used to 
            configure if emails are going to be sent asynchronously or not.
            </summary>
    </member>
    <member name="P:Castle.Core.Smtp.DefaultSmtpSender.Timeout">
      <summary>
            Gets or sets a value that specifies 
            the amount of time after which a synchronous Send call times out.
            </summary>
    </member>
    <member name="P:Castle.Core.Smtp.DefaultSmtpSender.UseSsl">
      <summary>
            Gets or sets a value indicating whether the email should be sent using 
            a secure communication channel.
            </summary>
      <value>
        <c>true</c> if should use SSL; otherwise, <c>false</c>.</value>
    </member>
    <member name="P:Castle.Core.Smtp.DefaultSmtpSender.Domain">
      <summary>
            Gets or sets the domain.
            </summary>
      <value>The domain.</value>
    </member>
    <member name="P:Castle.Core.Smtp.DefaultSmtpSender.UserName">
      <summary>
            Gets or sets the name of the user.
            </summary>
      <value>The name of the user.</value>
    </member>
    <member name="P:Castle.Core.Smtp.DefaultSmtpSender.Password">
      <summary>
            Gets or sets the password.
            </summary>
      <value>The password.</value>
    </member>
    <member name="P:Castle.Core.Smtp.DefaultSmtpSender.HasCredentials">
      <summary>
            Gets a value indicating whether credentials were informed.
            </summary>
      <value>
        <see langword="true" /> if this instance has credentials; otherwise, <see langword="false" />.
            </value>
    </member>
    <member name="T:Castle.Core.Resource.FileResource">
      <summary>
      </summary>
    </member>
    <member name="T:Castle.Core.ReflectionBasedDictionaryAdapter">
      <summary>
            Readonly implementation of <see cref="T:System.Collections.IDictionary" /> which uses an anonymous object as its source. Uses names of properties as keys, and property values as... well - values. Keys are not case sensitive.
            </summary>
    </member>
    <member name="M:Castle.Core.ReflectionBasedDictionaryAdapter.#ctor(System.Object)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.Core.ReflectionBasedDictionaryAdapter" /> class.
            </summary>
      <param name="target">The target.</param>
    </member>
    <member name="M:Castle.Core.ReflectionBasedDictionaryAdapter.Add(System.Object,System.Object)">
      <summary>
              Adds an element with the provided key and value to the <see cref="T:System.Collections.IDictionary" /> object.
            </summary>
      <param name="key">The <see cref="T:System.Object" /> to use as the key of the element to add.</param>
      <param name="value">The <see cref="T:System.Object" /> to use as the value of the element to add.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> is null. </exception>
      <exception cref="T:System.ArgumentException">An element with the same key already exists in the <see cref="T:System.Collections.IDictionary" /> object. </exception>
      <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.IDictionary" /> is read-only.-or- The <see cref="T:System.Collections.IDictionary" /> has a fixed size. </exception>
    </member>
    <member name="M:Castle.Core.ReflectionBasedDictionaryAdapter.Clear">
      <summary>
              Removes all elements from the <see cref="T:System.Collections.IDictionary" /> object.
            </summary>
      <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.IDictionary" /> object is read-only. </exception>
    </member>
    <member name="M:Castle.Core.ReflectionBasedDictionaryAdapter.Contains(System.Object)">
      <summary>
              Determines whether the <see cref="T:System.Collections.IDictionary" /> object contains an element with the specified key.
            </summary>
      <param name="key">The key to locate in the <see cref="T:System.Collections.IDictionary" /> object.</param>
      <returns>
              true if the <see cref="T:System.Collections.IDictionary" /> contains an element with the key; otherwise, false.
            </returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> is null. </exception>
    </member>
    <member name="M:Castle.Core.ReflectionBasedDictionaryAdapter.Remove(System.Object)">
      <summary>
              Removes the element with the specified key from the <see cref="T:System.Collections.IDictionary" /> object.
            </summary>
      <param name="key">The key of the element to remove.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> is null. </exception>
      <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.IDictionary" /> object is read-only.-or- The <see cref="T:System.Collections.IDictionary" /> has a fixed size. </exception>
    </member>
    <member name="M:Castle.Core.ReflectionBasedDictionaryAdapter.GetEnumerator">
      <summary>
              Returns an enumerator that iterates through a collection.
            </summary>
      <returns>
              An <see cref="T:System.Collections.IEnumerator" /> object that can be used to iterate through the collection.
            </returns>
    </member>
    <member name="M:Castle.Core.ReflectionBasedDictionaryAdapter.Read(System.Collections.IDictionary,System.Object)">
      <summary>
              Reads values of properties from <paramref name="valuesAsAnonymousObject" /> and inserts them into <paramref name="targetDictionary" /> using property names as keys.
            </summary>
      <param name="targetDictionary">
      </param>
      <param name="valuesAsAnonymousObject">
      </param>
    </member>
    <member name="P:Castle.Core.ReflectionBasedDictionaryAdapter.Count">
      <summary>
              Gets the number of elements contained in the <see cref="T:System.Collections.ICollection" />.
            </summary>
      <value>
      </value>
      <returns>The number of elements contained in the <see cref="T:System.Collections.ICollection" />.</returns>
    </member>
    <member name="P:Castle.Core.ReflectionBasedDictionaryAdapter.IsSynchronized">
      <summary>
              Gets a value indicating whether access to the <see cref="T:System.Collections.ICollection" /> is synchronized (thread safe).
            </summary>
      <value>
      </value>
      <returns>true if access to the <see cref="T:System.Collections.ICollection" /> is synchronized (thread safe); otherwise, false.</returns>
    </member>
    <member name="P:Castle.Core.ReflectionBasedDictionaryAdapter.SyncRoot">
      <summary>
              Gets an object that can be used to synchronize access to the <see cref="T:System.Collections.ICollection" />.
            </summary>
      <value>
      </value>
      <returns>An object that can be used to synchronize access to the <see cref="T:System.Collections.ICollection" />.</returns>
    </member>
    <member name="P:Castle.Core.ReflectionBasedDictionaryAdapter.IsReadOnly">
      <summary>
              Gets a value indicating whether the <see cref="T:System.Collections.IDictionary" /> object is read-only.
            </summary>
      <value>
      </value>
      <returns>true if the <see cref="T:System.Collections.IDictionary" /> object is read-only; otherwise, false.</returns>
    </member>
    <member name="P:Castle.Core.ReflectionBasedDictionaryAdapter.Item(System.Object)">
      <summary>
              Gets or sets the <see cref="T:System.Object" /> with the specified key.
            </summary>
      <value>
      </value>
    </member>
    <member name="P:Castle.Core.ReflectionBasedDictionaryAdapter.Keys">
      <summary>
              Gets an <see cref="T:System.Collections.ICollection" /> object containing the keys of the <see cref="T:System.Collections.IDictionary" /> object.
            </summary>
      <value>
      </value>
      <returns>An <see cref="T:System.Collections.ICollection" /> object containing the keys of the <see cref="T:System.Collections.IDictionary" /> object.</returns>
    </member>
    <member name="P:Castle.Core.ReflectionBasedDictionaryAdapter.Values">
      <summary>
              Gets an <see cref="T:System.Collections.ICollection" /> object containing the values in the <see cref="T:System.Collections.IDictionary" /> object.
            </summary>
      <value>
      </value>
      <returns>An <see cref="T:System.Collections.ICollection" /> object containing the values in the <see cref="T:System.Collections.IDictionary" /> object.</returns>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.NameValueCollectionAdapter">
      <summary>
      </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.NameValueCollectionAdapter.#ctor(System.Collections.Specialized.NameValueCollection)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Components.DictionaryAdapter.NameValueCollectionAdapter" /> class.
            </summary>
      <param name="nameValues">The name values.</param>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.NameValueCollectionAdapter.Contains(System.Object)">
      <summary>
            Determines whether the <see cref="T:System.Collections.IDictionary"></see> object contains an element with the specified key.
            </summary>
      <param name="key">The key to locate in the <see cref="T:System.Collections.IDictionary"></see> object.</param>
      <returns>
            true if the <see cref="T:System.Collections.IDictionary"></see> contains an element with the key; otherwise, false.
            </returns>
      <exception cref="T:System.ArgumentNullException">key is null. </exception>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.NameValueCollectionAdapter.Adapt(System.Collections.Specialized.NameValueCollection)">
      <summary>
            Adapts the specified name values.
            </summary>
      <param name="nameValues">The name values.</param>
      <returns>
      </returns>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.NameValueCollectionAdapter.IsReadOnly">
      <summary>
            Gets a value indicating whether the <see cref="T:System.Collections.IDictionary"></see> object is read-only.
            </summary>
      <value>
      </value>
      <returns>true if the <see cref="T:System.Collections.IDictionary"></see> object is read-only; otherwise, false.</returns>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.NameValueCollectionAdapter.Item(System.Object)">
      <summary>
            Gets or sets the <see cref="T:System.Object" /> with the specified key.
            </summary>
      <value>
      </value>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.AbstractDictionaryAdapterVisitor">
      <summary>
            Abstract implementation of <see cref="T:Castle.Components.DictionaryAdapter.IDictionaryAdapterVisitor" />.
            </summary>
    </member>
    <member name="T:Castle.Core.ProxyServices">
      <summary>
            List of utility methods related to dynamic proxy operations
            </summary>
    </member>
    <member name="M:Castle.Core.ProxyServices.IsDynamicProxy(System.Type)">
      <summary>
            Determines whether the specified type is a proxy generated by
            DynamicProxy (1 or 2).
            </summary>
      <param name="type">The type.</param>
      <returns>
        <c>true</c> if it is a proxy; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="T:Castle.Core.Logging.StreamLogger">
      <summary>
            The Stream Logger class.  This class can stream log information
            to any stream, it is suitable for storing a log file to disk,
            or to a <c>MemoryStream</c> for testing your components.
            </summary>
      <remarks>
            This logger is not thread safe.
            </remarks>
    </member>
    <member name="M:Castle.Core.Logging.StreamLogger.#ctor(System.String,System.IO.Stream)">
      <summary>
              Creates a new <c>StreamLogger</c> with default encoding 
              and buffer size. Initial Level is set to Debug.
            </summary>
      <param name="name">
              The name of the log.
            </param>
      <param name="stream">
              The stream that will be used for logging,
              seeking while the logger is alive 
            </param>
    </member>
    <member name="M:Castle.Core.Logging.StreamLogger.#ctor(System.String,System.IO.Stream,System.Text.Encoding)">
      <summary>
              Creates a new <c>StreamLogger</c> with default buffer size.
              Initial Level is set to Debug.
            </summary>
      <param name="name">
              The name of the log.
            </param>
      <param name="stream">
              The stream that will be used for logging,
              seeking while the logger is alive 
            </param>
      <param name="encoding">
              The encoding that will be used for this stream.
              <see cref="T:System.IO.StreamWriter" /></param>
    </member>
    <member name="M:Castle.Core.Logging.StreamLogger.#ctor(System.String,System.IO.Stream,System.Text.Encoding,System.Int32)">
      <summary>
              Creates a new <c>StreamLogger</c>. 
              Initial Level is set to Debug.
            </summary>
      <param name="name">
              The name of the log.
            </param>
      <param name="stream">
              The stream that will be used for logging,
              seeking while the logger is alive 
            </param>
      <param name="encoding">
              The encoding that will be used for this stream.
              <see cref="T:System.IO.StreamWriter" /></param>
      <param name="bufferSize">
              The buffer size that will be used for this stream.
              <see cref="T:System.IO.StreamWriter" /></param>
    </member>
    <member name="M:Castle.Core.Logging.StreamLogger.#ctor(System.String,System.IO.StreamWriter)">
      <summary>
              Creates a new <c>StreamLogger</c> with 
              Debug as default Level.
            </summary>
      <param name="name">The name of the log.</param>
      <param name="writer">The <c>StreamWriter</c> the log will write to.</param>
    </member>
    <member name="T:Castle.DynamicProxy.ProxyGenerator">
      <summary>
              Provides proxy objects for classes and interfaces.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.#ctor(Castle.DynamicProxy.IProxyBuilder)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.DynamicProxy.ProxyGenerator" /> class.
            </summary>
      <param name="builder">Proxy types builder.</param>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.#ctor">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.DynamicProxy.ProxyGenerator" /> class.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.#ctor(System.Boolean)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.DynamicProxy.ProxyGenerator" /> class.
            </summary>
      <param name="disableSignedModule">If <c>true</c> forces all types to be generated into an unsigned module.</param>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTarget``1(``0,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to members of interface <typeparamref name="TInterface" /> on <paramref name="target" /> object with given <paramref name="interceptors" />.
            </summary>
      <typeparam name="TInterface">Type of the interface implemented by <paramref name="target" /> which will be proxied.</typeparam>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>Object proxying calls to members of <typeparamref name="TInterface" /> on <paramref name="target" /> object.</returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="target" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <typeparamref name="TInterface" />is not an interface type.</exception>
      <exception cref="T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref name="target" /> object.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref name="target" /> throws an exception.</exception>
      <remarks>
              This method generates new proxy type for each type of <paramref name="target" />, which affects performance. If you don't want to proxy types differently depending on the type of the target
              use <see cref="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface``1(``0,Castle.DynamicProxy.IInterceptor[])" /> method.
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTarget``1(``0,Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to members of interface <typeparamref name="TInterface" /> on <paramref name="target" /> object with given <paramref name="interceptors" />.
            </summary>
      <typeparam name="TInterface">Type of the interface implemented by <paramref name="target" /> which will be proxied.</typeparam>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              Object proxying calls to members of <typeparamref name="TInterface" /> on <paramref name="target" /> object.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="target" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <typeparamref name="TInterface" />is not an interface type.</exception>
      <exception cref="T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref name="target" /> object.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref name="target" /> throws an exception.</exception>
      <remarks>
              This method generates new proxy type for each type of <paramref name="target" />, which affects performance. If you don't want to proxy types differently depending on the type of the target
              use <see cref="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface``1(``0,Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])" /> method.
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTarget(System.Type,System.Object,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to members of interface <paramref name="interfaceToProxy" /> on <paramref name="target" /> object with given <paramref name="interceptors" />.
            </summary>
      <param name="interfaceToProxy">Type of the interface implemented by <paramref name="target" /> which will be proxied.</param>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              Object proxying calls to members of <paramref name="interfaceToProxy" /> type on <paramref name="target" /> object.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="target" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is not an interface type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="target" /> does not implement <paramref name="interfaceToProxy" /> interface.</exception>
      <exception cref="T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref name="target" /> object.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref name="target" /> throws an exception.</exception>
      <remarks>
              This method generates new proxy type for each type of <paramref name="target" />, which affects performance. If you don't want to proxy types differently depending on the type of the target
              use <see cref="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface(System.Type,System.Object,Castle.DynamicProxy.IInterceptor[])" /> method.
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTarget(System.Type,System.Object,Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to members of interface <paramref name="interfaceToProxy" /> on <paramref name="target" /> object with given <paramref name="interceptors" />.
            </summary>
      <param name="interfaceToProxy">Type of the interface implemented by <paramref name="target" /> which will be proxied.</param>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              Object proxying calls to members of <paramref name="interfaceToProxy" /> type on <paramref name="target" /> object.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="target" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is not an interface type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="target" /> does not implement <paramref name="interfaceToProxy" /> interface.</exception>
      <exception cref="T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref name="target" /> object.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref name="target" /> throws an exception.</exception>
      <remarks>
              This method generates new proxy type for each type of <paramref name="target" />, which affects performance. If you don't want to proxy types differently depending on the type of the target
              use <see cref="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface(System.Type,System.Object,Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])" /> method.
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTarget(System.Type,System.Type[],System.Object,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to members of interface <paramref name="interfaceToProxy" /> on <paramref name="target" /> object with given <paramref name="interceptors" />.
            </summary>
      <param name="interfaceToProxy">Type of the interface implemented by <paramref name="target" /> which will be proxied.</param>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              Object proxying calls to members of <paramref name="interfaceToProxy" /> and <paramref name="additionalInterfacesToProxy" /> types  on <paramref name="target" /> object.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="target" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is not an interface type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="target" /> does not implement <paramref name="interfaceToProxy" /> interface.</exception>
      <exception cref="T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref name="target" /> object.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref name="target" /> throws an exception.</exception>
      <remarks>
              This method generates new proxy type for each type of <paramref name="target" />, which affects performance. If you don't want to proxy types differently depending on the type of the target
              use <see cref="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface(System.Type,System.Type[],System.Object,Castle.DynamicProxy.IInterceptor[])" /> method.
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTarget(System.Type,System.Type[],System.Object,Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to members of interface <paramref name="interfaceToProxy" /> on <paramref name="target" /> object with given <paramref name="interceptors" />.
            </summary>
      <param name="interfaceToProxy">Type of the interface implemented by <paramref name="target" /> which will be proxied.</param>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              Object proxying calls to members of <paramref name="interfaceToProxy" /> and <paramref name="additionalInterfacesToProxy" /> types on <paramref name="target" /> object.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="target" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is not an interface type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="target" /> does not implement <paramref name="interfaceToProxy" /> interface.</exception>
      <exception cref="T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref name="target" /> object.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref name="target" /> throws an exception.</exception>
      <remarks>
              This method generates new proxy type for each type of <paramref name="target" />, which affects performance. If you don't want to proxy types differently depending on the type of the target
              use <see cref="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface(System.Type,System.Type[],System.Object,Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])" /> method.
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface(System.Type,System.Object,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to members of interface <paramref name="interfaceToProxy" /> on <paramref name="target" /> object with given <paramref name="interceptors" />.
              Interceptors can use <see cref="T:Castle.DynamicProxy.IChangeProxyTarget" /> interface to provide other target for method invocation than default <paramref name="target" />.
            </summary>
      <param name="interfaceToProxy">Type of the interface implemented by <paramref name="target" /> which will be proxied.</param>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              Object proxying calls to members of <paramref name="interfaceToProxy" /> type on <paramref name="target" /> object or alternative implementation swapped at runtime by an interceptor.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="target" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is not an interface type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="target" /> does not implement <paramref name="interfaceToProxy" /> interface.</exception>
      <exception cref="T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref name="target" /> object.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref name="target" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface``1(``0,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to members of interface <typeparamref name="TInterface" /> on <paramref name="target" /> object with given <paramref name="interceptors" />.
              Interceptors can use <see cref="T:Castle.DynamicProxy.IChangeProxyTarget" /> interface to provide other target for method invocation than default <paramref name="target" />.
            </summary>
      <typeparam name="TInterface">Type of the interface implemented by <paramref name="target" /> which will be proxied.</typeparam>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              Object proxying calls to members of <typeparamref name="TInterface" /> type on <paramref name="target" /> object or alternative implementation swapped at runtime by an interceptor.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="target" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <typeparamref name="TInterface" /> is not an interface type.</exception>
      <exception cref="T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref name="target" /> object.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref name="target" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface``1(``0,Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to members of interface <typeparamref name="TInterface" /> on <paramref name="target" /> object with given <paramref name="interceptors" />.
              Interceptors can use <see cref="T:Castle.DynamicProxy.IChangeProxyTarget" /> interface to provide other target for method invocation than default <paramref name="target" />.
            </summary>
      <typeparam name="TInterface">Type of the interface implemented by <paramref name="target" /> which will be proxied.</typeparam>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              Object proxying calls to members of <typeparamref name="TInterface" /> type on <paramref name="target" /> object or alternative implementation swapped at runtime by an interceptor.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="target" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <typeparamref name="TInterface" /> is not an interface type.</exception>
      <exception cref="T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref name="target" /> object.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref name="target" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface(System.Type,System.Type[],System.Object,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to members of interface <paramref name="interfaceToProxy" /> on <paramref name="target" /> object with given <paramref name="interceptors" />.
              Interceptors can use <see cref="T:Castle.DynamicProxy.IChangeProxyTarget" /> interface to provide other target for method invocation than default <paramref name="target" />.
            </summary>
      <param name="interfaceToProxy">Type of the interface implemented by <paramref name="target" /> which will be proxied.</param>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              Object proxying calls to members of <paramref name="interfaceToProxy" /> and <paramref name="additionalInterfacesToProxy" /> types on <paramref name="target" /> object or alternative implementation swapped at runtime by an interceptor.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="target" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is not an interface type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="target" /> does not implement <paramref name="interfaceToProxy" /> interface.</exception>
      <exception cref="T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref name="target" /> object.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref name="target" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface(System.Type,System.Object,Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to members of interface <paramref name="interfaceToProxy" /> on <paramref name="target" /> object with given <paramref name="interceptors" />.
              Interceptors can use <see cref="T:Castle.DynamicProxy.IChangeProxyTarget" /> interface to provide other target for method invocation than default <paramref name="target" />.
            </summary>
      <param name="interfaceToProxy">Type of the interface implemented by <paramref name="target" /> which will be proxied.</param>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              Object proxying calls to members of <paramref name="interfaceToProxy" /> type on <paramref name="target" /> object or alternative implementation swapped at runtime by an interceptor.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="target" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is not an interface type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="target" /> does not implement <paramref name="interfaceToProxy" /> interface.</exception>
      <exception cref="T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref name="target" /> object.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref name="target" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface(System.Type,System.Type[],System.Object,Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to members of interface <paramref name="interfaceToProxy" /> on <paramref name="target" /> object with given <paramref name="interceptors" />.
              Interceptors can use <see cref="T:Castle.DynamicProxy.IChangeProxyTarget" /> interface to provide other target for method invocation than default <paramref name="target" />.
            </summary>
      <param name="interfaceToProxy">Type of the interface implemented by <paramref name="target" /> which will be proxied.</param>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              Object proxying calls to members of <paramref name="interfaceToProxy" /> and <paramref name="additionalInterfacesToProxy" /> types on <paramref name="target" /> object or alternative implementation swapped at runtime by an interceptor.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="target" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is not an interface type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="target" /> does not implement <paramref name="interfaceToProxy" /> interface.</exception>
      <exception cref="T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref name="target" /> object.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref name="target" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithoutTarget``1(Castle.DynamicProxy.IInterceptor)">
      <summary>
              Creates proxy object intercepting calls to members of interface <typeparamref name="TInterface" /> on target object generated at runtime with given <paramref name="interceptor" />.
            </summary>
      <typeparam name="TInterface">Type of the interface which will be proxied.</typeparam>
      <param name="interceptor">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              Object proxying calls to members of <typeparamref name="TInterface" /> types on generated target object.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptor" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <typeparamref name="TInterface" /> is not an interface type.</exception>
      <remarks>
              Since this method uses an empty-shell implementation of interfaces to proxy generated at runtime, the actual implementation of proxied methods must be provided by given <see cref="T:Castle.DynamicProxy.IInterceptor" /> implementations.
              They are responsible for setting return value (and out parameters) on proxied methods. It is also illegal for an interceptor to call <see cref="M:Castle.DynamicProxy.IInvocation.Proceed" />, since there's no actual implementation to proceed with.
              As a result of that also at least one <see cref="T:Castle.DynamicProxy.IInterceptor" /> implementation must be provided.
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithoutTarget``1(Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to members of interface <typeparamref name="TInterface" /> on target object generated at runtime with given <paramref name="interceptors" />.
            </summary>
      <typeparam name="TInterface">Type of the interface which will be proxied.</typeparam>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              Object proxying calls to members of <typeparamref name="TInterface" /> types on generated target object.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <typeparamref name="TInterface" /> is not an interface type.</exception>
      <remarks>
              Since this method uses an empty-shell implementation of interfaces to proxy generated at runtime, the actual implementation of proxied methods must be provided by given <see cref="T:Castle.DynamicProxy.IInterceptor" /> implementations.
              They are responsible for setting return value (and out parameters) on proxied methods. It is also illegal for an interceptor to call <see cref="M:Castle.DynamicProxy.IInvocation.Proceed" />, since there's no actual implementation to proceed with.
              As a result of that also at least one <see cref="T:Castle.DynamicProxy.IInterceptor" /> implementation must be provided.
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithoutTarget``1(Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to members of interface <typeparamref name="TInterface" /> on target object generated at runtime with given <paramref name="interceptors" />.
            </summary>
      <typeparam name="TInterface">Type of the interface which will be proxied.</typeparam>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              Object proxying calls to members of <typeparamref name="TInterface" /> types on generated target object.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <typeparamref name="TInterface" /> is not an interface type.</exception>
      <remarks>
              Since this method uses an empty-shell implementation of interfaces to proxy generated at runtime, the actual implementation of proxied methods must be provided by given <see cref="T:Castle.DynamicProxy.IInterceptor" /> implementations.
              They are responsible for setting return value (and out parameters) on proxied methods. It is also illegal for an interceptor to call <see cref="M:Castle.DynamicProxy.IInvocation.Proceed" />, since there's no actual implementation to proceed with.
              As a result of that also at least one <see cref="T:Castle.DynamicProxy.IInterceptor" /> implementation must be provided.
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithoutTarget(System.Type,Castle.DynamicProxy.IInterceptor)">
      <summary>
              Creates proxy object intercepting calls to members of interface <paramref name="interfaceToProxy" /> on target object generated at runtime with given <paramref name="interceptor" />.
            </summary>
      <param name="interfaceToProxy">Type of the interface which will be proxied.</param>
      <param name="interceptor">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              Object proxying calls to members of <paramref name="interfaceToProxy" /> type on generated target object.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptor" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is not an interface type.</exception>
      <remarks>
              Since this method uses an empty-shell implementation of interfaces to proxy generated at runtime, the actual implementation of proxied methods must be provided by given <see cref="T:Castle.DynamicProxy.IInterceptor" /> implementations.
              They are responsible for setting return value (and out parameters) on proxied methods. It is also illegal for an interceptor to call <see cref="M:Castle.DynamicProxy.IInvocation.Proceed" />, since there's no actual implementation to proceed with.
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithoutTarget(System.Type,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to members of interface <paramref name="interfaceToProxy" /> on target object generated at runtime with given <paramref name="interceptors" />.
            </summary>
      <param name="interfaceToProxy">Type of the interface which will be proxied.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              Object proxying calls to members of <paramref name="interfaceToProxy" /> type on generated target object.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is not an interface type.</exception>
      <remarks>
              Since this method uses an empty-shell implementation of interfaces to proxy generated at runtime, the actual implementation of proxied methods must be provided by given <see cref="T:Castle.DynamicProxy.IInterceptor" /> implementations.
              They are responsible for setting return value (and out parameters) on proxied methods. It is also illegal for an interceptor to call <see cref="M:Castle.DynamicProxy.IInvocation.Proceed" />, since there's no actual implementation to proceed with.
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithoutTarget(System.Type,System.Type[],Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to members of interface <paramref name="interfaceToProxy" /> on target object generated at runtime with given <paramref name="interceptors" />.
            </summary>
      <param name="interfaceToProxy">Type of the interface which will be proxied.</param>
      <param name="additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              Object proxying calls to members of <paramref name="interfaceToProxy" /> and <paramref name="additionalInterfacesToProxy" /> types on generated target object.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is not an interface type.</exception>
      <remarks>
              Since this method uses an empty-shell implementation of interfaces to proxy generated at runtime, the actual implementation of proxied methods must be provided by given <see cref="T:Castle.DynamicProxy.IInterceptor" /> implementations.
              They are responsible for setting return value (and out parameters) on proxied methods. It is also illegal for an interceptor to call <see cref="M:Castle.DynamicProxy.IInvocation.Proceed" />, since there's no actual implementation to proceed with.
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithoutTarget(System.Type,Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to members of interface <paramref name="interfaceToProxy" /> on target object generated at runtime with given <paramref name="interceptors" />.
            </summary>
      <param name="interfaceToProxy">Type of the interface which will be proxied.</param>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              Object proxying calls to members of <paramref name="interfaceToProxy" /> on generated target object.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" />  is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is not an interface type.</exception>
      <remarks>
              They are responsible for setting return value (and out parameters) on proxied methods. It is also illegal for an interceptor to call <see cref="M:Castle.DynamicProxy.IInvocation.Proceed" />, since there's no actual implementation to proceed with.
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithoutTarget(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to members of interface <paramref name="interfaceToProxy" /> on target object generated at runtime with given <paramref name="interceptors" />.
            </summary>
      <param name="interfaceToProxy">Type of the interface which will be proxied.</param>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              Object proxying calls to members of <paramref name="interfaceToProxy" /> and <paramref name="additionalInterfacesToProxy" /> types on generated target object.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is not an interface type.</exception>
      <remarks>
              Since this method uses an empty-shell implementation of <paramref name="additionalInterfacesToProxy" /> to proxy generated at runtime, the actual implementation of proxied methods must be provided by given <see cref="T:Castle.DynamicProxy.IInterceptor" /> implementations.
              They are responsible for setting return value (and out parameters) on proxied methods. It is also illegal for an interceptor to call <see cref="M:Castle.DynamicProxy.IInvocation.Proceed" />, since there's no actual implementation to proceed with.
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxyWithTarget``1(``0,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to virtual members of type <typeparamref name="TClass" /> on newly created instance of that type with given <paramref name="interceptors" />.
            </summary>
      <typeparam name="TClass">Type of class which will be proxied.</typeparam>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              New object of type <typeparamref name="TClass" /> proxying calls to virtual members of <typeparamref name="TClass" /> type.
            </returns>
      <exception cref="T:System.ArgumentException">Thrown when given <typeparamref name="TClass" /> is not a class type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when no default constructor exists on type <typeparamref name="TClass" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of type <typeparamref name="TClass" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxyWithTarget``1(``0,Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to virtual members of type <typeparamref name="TClass" /> on newly created instance of that type with given <paramref name="interceptors" />.
            </summary>
      <typeparam name="TClass">Type of class which will be proxied.</typeparam>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              New object of type <typeparamref name="TClass" /> proxying calls to virtual members of <typeparamref name="TClass" /> type.
            </returns>
      <exception cref="T:System.ArgumentException">Thrown when given <typeparamref name="TClass" /> is not a class type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when no default constructor exists on type <typeparamref name="TClass" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of type <typeparamref name="TClass" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxyWithTarget(System.Type,System.Type[],System.Object,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to virtual members of type <paramref name="classToProxy" /> on newly created instance of that type with given <paramref name="interceptors" />.
            </summary>
      <param name="classToProxy">Type of class which will be proxied.</param>
      <param name="additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              New object of type <paramref name="classToProxy" /> proxying calls to virtual members of <paramref name="classToProxy" /> and <paramref name="additionalInterfacesToProxy" /> types.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is not a class type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when no default constructor exists on type <paramref name="classToProxy" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of type <paramref name="classToProxy" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxyWithTarget(System.Type,System.Object,Castle.DynamicProxy.ProxyGenerationOptions,System.Object[],Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to virtual members of type <paramref name="classToProxy" /> on newly created instance of that type with given <paramref name="interceptors" />.
            </summary>
      <param name="classToProxy">Type of class which will be proxied.</param>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="constructorArguments">Arguments of constructor of type <paramref name="classToProxy" /> which should be used to create a new instance of that type.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              New object of type <paramref name="classToProxy" /> proxying calls to virtual members of <paramref name="classToProxy" /> type.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is not a class type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when no constructor exists on type <paramref name="classToProxy" /> with parameters matching <paramref name="constructorArguments" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when constructor of type <paramref name="classToProxy" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxyWithTarget(System.Type,System.Object,System.Object[],Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to virtual members of type <paramref name="classToProxy" /> on newly created instance of that type with given <paramref name="interceptors" />.
            </summary>
      <param name="classToProxy">Type of class which will be proxied.</param>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="constructorArguments">Arguments of constructor of type <paramref name="classToProxy" /> which should be used to create a new instance of that type.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              New object of type <paramref name="classToProxy" /> proxying calls to virtual members of <paramref name="classToProxy" /> type.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is not a class type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when no constructor exists on type <paramref name="classToProxy" /> with parameters matching <paramref name="constructorArguments" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when constructor of type <paramref name="classToProxy" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxyWithTarget(System.Type,System.Object,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to virtual members of type <paramref name="classToProxy" /> on newly created instance of that type with given <paramref name="interceptors" />.
            </summary>
      <param name="classToProxy">Type of class which will be proxied.</param>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              New object of type <paramref name="classToProxy" /> proxying calls to virtual members of <paramref name="classToProxy" /> type.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is not a class type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when no parameterless constructor exists on type <paramref name="classToProxy" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when constructor of type <paramref name="classToProxy" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxyWithTarget(System.Type,System.Object,Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to virtual members of type <paramref name="classToProxy" /> on newly created instance of that type with given <paramref name="interceptors" />.
            </summary>
      <param name="classToProxy">Type of class which will be proxied.</param>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              New object of type <paramref name="classToProxy" /> proxying calls to virtual members of <paramref name="classToProxy" /> type.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="options" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is not a class type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when no default constructor exists on type <paramref name="classToProxy" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of type <paramref name="classToProxy" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxyWithTarget(System.Type,System.Type[],System.Object,Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to virtual members of type <paramref name="classToProxy" /> on newly created instance of that type with given <paramref name="interceptors" />.
            </summary>
      <param name="classToProxy">Type of class which will be proxied.</param>
      <param name="additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              New object of type <paramref name="classToProxy" /> proxying calls to virtual members of <paramref name="classToProxy" /> and <paramref name="additionalInterfacesToProxy" /> types.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="options" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is not a class type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when no default constructor exists on type <paramref name="classToProxy" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of type <paramref name="classToProxy" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxyWithTarget(System.Type,System.Type[],System.Object,Castle.DynamicProxy.ProxyGenerationOptions,System.Object[],Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to virtual members of type <paramref name="classToProxy" /> on newly created instance of that type with given <paramref name="interceptors" />.
            </summary>
      <param name="classToProxy">Type of class which will be proxied.</param>
      <param name="additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="constructorArguments">Arguments of constructor of type <paramref name="classToProxy" /> which should be used to create a new instance of that type.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              New object of type <paramref name="classToProxy" /> proxying calls to virtual members of <paramref name="classToProxy" /> and <paramref name="additionalInterfacesToProxy" /> types.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="options" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is not a class type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when no constructor exists on type <paramref name="classToProxy" /> with parameters matching <paramref name="constructorArguments" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when constructor of type <paramref name="classToProxy" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxy``1(Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to virtual members of type <typeparamref name="TClass" /> on newly created instance of that type with given <paramref name="interceptors" />.
            </summary>
      <typeparam name="TClass">Type of class which will be proxied.</typeparam>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              New object of type <typeparamref name="TClass" /> proxying calls to virtual members of <typeparamref name="TClass" /> type.
            </returns>
      <exception cref="T:System.ArgumentException">Thrown when given <typeparamref name="TClass" /> is not a class type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when no default constructor exists on type <typeparamref name="TClass" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of type <typeparamref name="TClass" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxy``1(Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to virtual members of type <typeparamref name="TClass" /> on newly created instance of that type with given <paramref name="interceptors" />.
            </summary>
      <typeparam name="TClass">Type of class which will be proxied.</typeparam>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              New object of type <typeparamref name="TClass" /> proxying calls to virtual members of <typeparamref name="TClass" /> type.
            </returns>
      <exception cref="T:System.ArgumentException">Thrown when given <typeparamref name="TClass" /> is not a class type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when no default constructor exists on type <typeparamref name="TClass" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of type <typeparamref name="TClass" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxy(System.Type,System.Type[],Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to virtual members of type <paramref name="classToProxy" /> on newly created instance of that type with given <paramref name="interceptors" />.
            </summary>
      <param name="classToProxy">Type of class which will be proxied.</param>
      <param name="additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              New object of type <paramref name="classToProxy" /> proxying calls to virtual members of <paramref name="classToProxy" /> and <paramref name="additionalInterfacesToProxy" /> types.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is not a class type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when no default constructor exists on type <paramref name="classToProxy" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of type <paramref name="classToProxy" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxy(System.Type,Castle.DynamicProxy.ProxyGenerationOptions,System.Object[],Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to virtual members of type <paramref name="classToProxy" /> on newly created instance of that type with given <paramref name="interceptors" />.
            </summary>
      <param name="classToProxy">Type of class which will be proxied.</param>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="constructorArguments">Arguments of constructor of type <paramref name="classToProxy" /> which should be used to create a new instance of that type.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              New object of type <paramref name="classToProxy" /> proxying calls to virtual members of <paramref name="classToProxy" /> type.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is not a class type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when no constructor exists on type <paramref name="classToProxy" /> with parameters matching <paramref name="constructorArguments" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when constructor of type <paramref name="classToProxy" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxy(System.Type,System.Object[],Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to virtual members of type <paramref name="classToProxy" /> on newly created instance of that type with given <paramref name="interceptors" />.
            </summary>
      <param name="classToProxy">Type of class which will be proxied.</param>
      <param name="constructorArguments">Arguments of constructor of type <paramref name="classToProxy" /> which should be used to create a new instance of that type.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              New object of type <paramref name="classToProxy" /> proxying calls to virtual members of <paramref name="classToProxy" /> type.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is not a class type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when no constructor exists on type <paramref name="classToProxy" /> with parameters matching <paramref name="constructorArguments" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when constructor of type <paramref name="classToProxy" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxy(System.Type,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to virtual members of type <paramref name="classToProxy" /> on newly created instance of that type with given <paramref name="interceptors" />.
            </summary>
      <param name="classToProxy">Type of class which will be proxied.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              New object of type <paramref name="classToProxy" /> proxying calls to virtual members of <paramref name="classToProxy" /> type.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is not a class type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when no parameterless constructor exists on type <paramref name="classToProxy" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when constructor of type <paramref name="classToProxy" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxy(System.Type,Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to virtual members of type <paramref name="classToProxy" /> on newly created instance of that type with given <paramref name="interceptors" />.
            </summary>
      <param name="classToProxy">Type of class which will be proxied.</param>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              New object of type <paramref name="classToProxy" /> proxying calls to virtual members of <paramref name="classToProxy" /> type.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="options" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is not a class type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when no default constructor exists on type <paramref name="classToProxy" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of type <paramref name="classToProxy" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxy(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to virtual members of type <paramref name="classToProxy" /> on newly created instance of that type with given <paramref name="interceptors" />.
            </summary>
      <param name="classToProxy">Type of class which will be proxied.</param>
      <param name="additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              New object of type <paramref name="classToProxy" /> proxying calls to virtual members of <paramref name="classToProxy" /> and <paramref name="additionalInterfacesToProxy" /> types.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="options" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is not a class type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when no default constructor exists on type <paramref name="classToProxy" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of type <paramref name="classToProxy" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxy(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions,System.Object[],Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to virtual members of type <paramref name="classToProxy" /> on newly created instance of that type with given <paramref name="interceptors" />.
            </summary>
      <param name="classToProxy">Type of class which will be proxied.</param>
      <param name="additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="constructorArguments">Arguments of constructor of type <paramref name="classToProxy" /> which should be used to create a new instance of that type.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              New object of type <paramref name="classToProxy" /> proxying calls to virtual members of <paramref name="classToProxy" /> and <paramref name="additionalInterfacesToProxy" /> types.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="options" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is not a class type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when no constructor exists on type <paramref name="classToProxy" /> with parameters matching <paramref name="constructorArguments" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when constructor of type <paramref name="classToProxy" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxyType(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)">
      <summary>
              Creates the proxy type for class proxy with given <paramref name="classToProxy" /> class, implementing given <paramref name="additionalInterfacesToProxy" /> and using provided <paramref name="options" />.
            </summary>
      <param name="classToProxy">The base class for proxy type.</param>
      <param name="additionalInterfacesToProxy">The interfaces that proxy type should implement.</param>
      <param name="options">The options for proxy generation process.</param>
      <returns>
        <see cref="T:System.Type" /> of proxy.</returns>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyTypeWithTarget(System.Type,System.Type[],System.Type,Castle.DynamicProxy.ProxyGenerationOptions)">
      <summary>
              Creates the proxy type for interface proxy with target for given <paramref name="interfaceToProxy" /> interface, implementing given <paramref name="additionalInterfacesToProxy" /> on given <paramref name="targetType" /> and using provided <paramref name="options" />.
            </summary>
      <param name="interfaceToProxy">The interface proxy type should implement.</param>
      <param name="additionalInterfacesToProxy">The additional interfaces proxy type should implement.</param>
      <param name="targetType">Actual type that the proxy type will encompass.</param>
      <param name="options">The options for proxy generation process.</param>
      <returns>
        <see cref="T:System.Type" /> of proxy.</returns>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyTypeWithTargetInterface(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)">
      <summary>
              Creates the proxy type for interface proxy with target interface for given <paramref name="interfaceToProxy" /> interface, implementing given <paramref name="additionalInterfacesToProxy" /> on given <paramref name="interfaceToProxy" /> and using provided <paramref name="options" />.
            </summary>
      <param name="interfaceToProxy">The interface proxy type should implement.</param>
      <param name="additionalInterfacesToProxy">The additional interfaces proxy type should implement.</param>
      <param name="options">The options for proxy generation process.</param>
      <returns>
        <see cref="T:System.Type" /> of proxy.</returns>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyTypeWithoutTarget(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)">
      <summary>
              Creates the proxy type for interface proxy without target for given <paramref name="interfaceToProxy" /> interface, implementing given <paramref name="additionalInterfacesToProxy" /> and using provided <paramref name="options" />.
            </summary>
      <param name="interfaceToProxy">The interface proxy type should implement.</param>
      <param name="additionalInterfacesToProxy">The additional interfaces proxy type should implement.</param>
      <param name="options">The options for proxy generation process.</param>
      <returns>
        <see cref="T:System.Type" /> of proxy.</returns>
    </member>
    <member name="P:Castle.DynamicProxy.ProxyGenerator.Logger">
      <summary>
              Gets or sets the <see cref="T:Castle.Core.Logging.ILogger" /> that this <see cref="T:Castle.DynamicProxy.ProxyGenerator" /> log to.
            </summary>
    </member>
    <member name="P:Castle.DynamicProxy.ProxyGenerator.ProxyBuilder">
      <summary>
              Gets the proxy builder instance used to generate proxy types.
            </summary>
      <value>The proxy builder.</value>
    </member>
    <member name="T:Castle.DynamicProxy.Generators.Emitters.LdcOpCodesDictionary">
      <summary>
              s
              Provides appropriate Ldc.X opcode for the type of primitive value to be loaded.
            </summary>
    </member>
    <member name="T:Castle.DynamicProxy.Serialization.CacheMappingsAttribute">
      <summary>
              Applied to the assemblies saved by <see cref="T:Castle.DynamicProxy.ModuleScope" /> in order to persist the cache data included in the persisted assembly.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.TypeKeyPrefixAttribute">
      <summary>
            Assigns a prefix to the keyed properties using the interface name.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.ComponentAttribute">
      <summary>
            Identifies a property should be represented as a nested component.
            </summary>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.ComponentAttribute.NoPrefix">
      <summary>
            Applies no prefix.
            </summary>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.ComponentAttribute.Prefix">
      <summary>
            Gets or sets the prefix.
            </summary>
      <value>The prefix.</value>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.DictionaryAdapterFactory">
      <summary>
            Uses Reflection.Emit to expose the properties of a dictionary
            through a dynamic implementation of a typed interface.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.DictionaryAdapterFactory.GetAdapter``1(System.Collections.IDictionary)">
      <inheritdoc />
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.DictionaryAdapterFactory.GetAdapter(System.Type,System.Collections.IDictionary)">
      <inheritdoc />
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.DictionaryAdapterFactory.GetAdapter(System.Type,System.Collections.IDictionary,Castle.Components.DictionaryAdapter.PropertyDescriptor)">
      <inheritdoc />
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.DictionaryAdapterFactory.GetAdapter``2(System.Collections.Generic.IDictionary{System.String,``1})">
      <inheritdoc />
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.DictionaryAdapterFactory.GetAdapter``1(System.Type,System.Collections.Generic.IDictionary{System.String,``0})">
      <inheritdoc />
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.DictionaryAdapterFactory.GetAdapter``1(System.Collections.Specialized.NameValueCollection)">
      <inheritdoc />
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.DictionaryAdapterFactory.GetAdapter(System.Type,System.Collections.Specialized.NameValueCollection)">
      <inheritdoc />
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.DictionaryAdapterFactory.GetAdapter``1(System.Xml.XmlNode)">
      <inheritdoc />
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.DictionaryAdapterFactory.GetAdapter(System.Type,System.Xml.XmlNode)">
      <inheritdoc />
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.DictionaryAdapterFactory.GetAdapterMeta(System.Type)">
      <inheritdoc />
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.DictionaryAdapterFactory.GetAdapterMeta(System.Type,Castle.Components.DictionaryAdapter.PropertyDescriptor)">
      <inheritdoc />
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.DictionaryAdapterFactory.GetAdapterMeta(System.Type,Castle.Components.DictionaryAdapter.DictionaryAdapterMeta)">
      <inheritdoc />
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.NewGuidAttribute">
      <summary>
            Generates a new GUID on demand.
            </summary>
    </member>
    <member name="T:LinFu.AOP.Cecil.Interfaces.IMethodBodyRewriter">
      <summary>
            Represents a type that can modify method bodies.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.Interfaces.IMethodBodyRewriter.Rewrite(Mono.Cecil.MethodDefinition,Mono.Cecil.Cil.CilWorker,System.Collections.Generic.IEnumerable{Mono.Cecil.Cil.Instruction})">
      <summary>
            Rewrites a target method using the given CilWorker.
            </summary>
      <param name="method">The target method.</param>
      <param name="IL">The CilWorker that will be used to rewrite the target method.</param>
      <param name="oldInstructions">The original instructions from the target method body.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.Interfaces.IHostWeaver`1">
      <summary>
            Represents a weaver class that can modify its host.
            </summary>
      <typeparam name="THost">The host that holds the item to be modified.</typeparam>
    </member>
    <member name="M:LinFu.AOP.Cecil.Interfaces.IHostWeaver`1.ImportReferences(Mono.Cecil.ModuleDefinition)">
      <summary>
            Imports references into the target <see cref="T:Mono.Cecil.ModuleDefinition" /> instance.
            </summary>
      <param name="module">The module that will hold the modified item.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.Interfaces.IHostWeaver`1.AddAdditionalMembers(`0)">
      <summary>
            Adds additional members to the host type.
            </summary>
      <param name="host">The host that holds the current item being modified.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.Interfaces.IMethodRewriter">
      <summary>
            Represents a type that can modify method bodies.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.Interfaces.IMethodRewriter.AddLocals(Mono.Cecil.MethodDefinition)">
      <summary>
            Adds local variables to the <paramref name="hostMethod" />.
            </summary>
      <param name="hostMethod">The target method.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.BaseMethodRewriter">
      <summary>
            Represents the basic implementation of a method rewriter class.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.BaseMethodRewriter.#ctor">
      <summary>
            Initializes a new instance of the MethodRewriter class.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.BaseMethodRewriter.Rewrite(Mono.Cecil.MethodDefinition,Mono.Cecil.Cil.CilWorker,System.Collections.Generic.IEnumerable{Mono.Cecil.Cil.Instruction})">
      <summary>
            Rewrites a target method using the given CilWorker.
            </summary>
      <param name="method">The target method.</param>
      <param name="IL">The CilWorker that will be used to rewrite the target method.</param>
      <param name="oldInstructions">The original instructions from the target method body.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.BaseMethodRewriter.ShouldRewrite(Mono.Cecil.MethodDefinition)">
      <summary>
            Determines whether or not the given method should be modified.
            </summary>
      <param name="targetMethod">The target method.</param>
      <returns>A <see cref="T:System.Boolean" /> indicating whether or not a method should be rewritten.</returns>
    </member>
    <member name="M:LinFu.AOP.Cecil.BaseMethodRewriter.RewriteMethodBody(Mono.Cecil.MethodDefinition,Mono.Cecil.Cil.CilWorker,System.Collections.Generic.IEnumerable{Mono.Cecil.Cil.Instruction})">
      <summary>
            Rewrites the instructions in the target method body.
            </summary>
      <param name="method">The target method.</param>
      <param name="IL">The <see cref="T:Mono.Cecil.Cil.CilWorker" /> instance that represents the method body.</param>
      <param name="oldInstructions">The IL instructions of the original method body.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.BaseMethodRewriter.AddAdditionalMembers(Mono.Cecil.TypeDefinition)">
      <summary>
            Adds additional members to the host type.
            </summary>
      <param name="host">The host type.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.BaseMethodRewriter.ImportReferences(Mono.Cecil.ModuleDefinition)">
      <summary>
            Adds additional references to the target module.
            </summary>
      <param name="module">The host module.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.BaseMethodRewriter.AddLocals(Mono.Cecil.MethodDefinition)">
      <summary>
            Adds local variables to the <paramref name="hostMethod" />.
            </summary>
      <param name="hostMethod">The target method.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.CatchAllThrownExceptions">
      <summary>
            Represents a method rewriter that modifies a method body to support dynamic exception handling.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.CatchAllThrownExceptions.ImportReferences(Mono.Cecil.ModuleDefinition)">
      <summary>
            Adds additional references to the target module.
            </summary>
      <param name="module">The host module.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.CatchAllThrownExceptions.AddLocals(Mono.Cecil.MethodDefinition)">
      <summary>
            Adds local variables to the <paramref name="hostMethod" />.
            </summary>
      <param name="hostMethod">The target method.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.CatchAllThrownExceptions.RewriteMethodBody(Mono.Cecil.MethodDefinition,Mono.Cecil.Cil.CilWorker,System.Collections.Generic.IEnumerable{Mono.Cecil.Cil.Instruction})">
      <summary>
            Rewrites the instructions in the target method body to support dynamic exception handling.
            </summary>
      <param name="targetMethod">The target method.</param>
      <param name="IL">The <see cref="T:Mono.Cecil.Cil.CilWorker" /> instance that represents the method body.</param>
      <param name="oldInstructions">The IL instructions of the original method body.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.CatchAllThrownExceptions.SaveExceptionInfo(Mono.Cecil.MethodDefinition,LinFu.AOP.Cecil.Interfaces.IEmitInvocationInfo)">
      <summary>
            Saves the current <see cref="T:LinFu.AOP.Interfaces.IExceptionHandlerInfo" /> instance.
            </summary>
      <param name="targetMethod">The target method.</param>
      <param name="emitter">The <see cref="T:LinFu.AOP.Cecil.Interfaces.IEmitInvocationInfo" /> instance that will emit the current method context.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.Interfaces.IInstructionEmitter">
      <summary>
            Represents a type that is capable of manipulating instructions within a given method body.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.Interfaces.IInstructionEmitter.Emit(Mono.Cecil.Cil.CilWorker)">
      <summary>
            Emits a set of instructions to the given <paramref name="IL">CilWorker</paramref>.
            </summary>
      <param name="IL">The <see cref="T:Mono.Cecil.Cil.CilWorker" /> responsible for the target method body.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.AddMethodReplacementImplementation">
      <summary>
            Represents an instruction emitter that adds method body replacement support to a given method body.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.AddMethodReplacementImplementation.#ctor(LinFu.AOP.Cecil.IMethodBodyRewriterParameters)">
      <summary>
            Initializes a new instance of the <see cref="T:LinFu.AOP.Cecil.AddMethodReplacementImplementation" /> class.
            </summary>
      <param name="parameters">The set of parameters that describe the target method body.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.AddMethodReplacementImplementation.Emit(Mono.Cecil.Cil.CilWorker)">
      <summary>
            Adds method body interception to the target method.
            </summary>
      <param name="IL">The <see cref="T:Mono.Cecil.Cil.CilWorker" /> pointing to the target method body.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.AddOriginalInstructions">
      <summary>
            Represents an instruction emitter that adds the original method instructions to a given method body.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.AddOriginalInstructions.#ctor(System.Collections.Generic.IEnumerable{Mono.Cecil.Cil.Instruction},Mono.Cecil.Cil.Instruction)">
      <summary>
            Initializes a new instance of the <see cref="T:LinFu.AOP.Cecil.AddOriginalInstructions" /> class.
            </summary>
      <param name="oldInstructions">The original method instructions.</param>
      <param name="endLabel">The instruction label that marks the end of the method body.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.AddOriginalInstructions.Emit(Mono.Cecil.Cil.CilWorker)">
      <summary>
            Adds the original instructions to a given method body.
            </summary>
      <param name="IL">The <see cref="T:Mono.Cecil.Cil.CilWorker" /> responsible for the target method body.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.AssemblyDefinitionExtensions">
      <summary>
            A class that extends <see cref="T:Mono.Cecil.AssemblyDefinition" /> instances.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.AssemblyDefinitionExtensions.RemoveStrongName(Mono.Cecil.AssemblyDefinition)">
      <summary>
            Removes the strong-name signature from the <paramref name="sourceAssembly" />.
            </summary>
      <param name="sourceAssembly">
      </param>
    </member>
    <member name="T:LinFu.AOP.Cecil.Extensions.CecilVisitorExtensions">
      <summary>
            A helper class that extends Cecil to support LinFu's weaver model.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.CecilVisitorExtensions.Accept(Mono.Cecil.IReflectionVisitable,LinFu.AOP.Cecil.Interfaces.ITypeWeaver)">
      <summary>
            Allows a <see cref="T:LinFu.AOP.Cecil.Interfaces.ITypeWeaver" /> instance to traverse any <see cref="T:Mono.Cecil.IReflectionVisitable" />
            instance.
            </summary>
      <param name="visitable">The visitable object.</param>
      <param name="typeWeaver">The type weaver.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.CecilVisitorExtensions.Accept(Mono.Cecil.IReflectionStructureVisitable,LinFu.AOP.Cecil.Interfaces.ITypeWeaver)">
      <summary>
            Allows a <see cref="T:LinFu.AOP.Cecil.Interfaces.ITypeWeaver" /> instance to traverse any <see cref="T:Mono.Cecil.IReflectionStructureVisitable" />
            instance.
            </summary>
      <param name="visitable">The visitable object.</param>
      <param name="typeWeaver">The type weaver.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.CecilVisitorExtensions.Accept(Mono.Cecil.IReflectionStructureVisitable,LinFu.AOP.Cecil.Interfaces.IMethodWeaver)">
      <summary>
            Allows a <see cref="T:LinFu.AOP.Cecil.Interfaces.IMethodWeaver" /> instance to traverse any <see cref="T:Mono.Cecil.IReflectionVisitable" />
            instance.
            </summary>
      <param name="visitable">The visitable object.</param>
      <param name="methodWeaver">The method weaver.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.CecilVisitorExtensions.Accept(Mono.Cecil.IReflectionVisitable,LinFu.AOP.Cecil.Interfaces.IMethodWeaver)">
      <summary>
            Allows a <see cref="T:LinFu.AOP.Cecil.Interfaces.IMethodWeaver" /> instance to traverse any <see cref="T:Mono.Cecil.IReflectionVisitable" />
            instance.
            </summary>
      <param name="visitable">The visitable object.</param>
      <param name="methodWeaver">The method weaver.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.EmitAfterInvoke">
      <summary>
            Represents a type that emits the call to the <see cref="T:LinFu.AOP.Interfaces.IAfterInvoke" /> instance.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.EmitAfterInvoke.#ctor(Mono.Cecil.Cil.VariableDefinition,Mono.Cecil.Cil.VariableDefinition,Mono.Cecil.Cil.VariableDefinition,Mono.Cecil.Cil.VariableDefinition)">
      <summary>
            Initializes a new instance of the <see cref="T:LinFu.AOP.Cecil.EmitAfterInvoke" /> class.
            </summary>
      <param name="surroundingImplementation">The variable that contains the <see cref="T:LinFu.AOP.Interfaces.IAroundInvoke" /> instance.</param>
      <param name="surroundingClassImplementation">The variable that contains the class-level <see cref="T:LinFu.AOP.Interfaces.IAroundInvoke" /> instance.</param>
      <param name="invocationInfo">The variable that contains the <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> instance.</param>
      <param name="returnValue">The local vaiable that contains the return value of the target method.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.EmitAfterInvoke.Emit(Mono.Cecil.Cil.CilWorker)">
      <summary>
            Emits the call to the <see cref="T:LinFu.AOP.Interfaces.IAfterInvoke" /> instance.
            </summary>
      <param name="IL">The <see cref="T:Mono.Cecil.Cil.CilWorker" /> that points to the current method body.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.EmitBeforeInvoke">
      <summary>
            Represents a type that emits the call to the <see cref="T:LinFu.AOP.Interfaces.IBeforeInvoke" /> instance.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.EmitBeforeInvoke.#ctor(Mono.Cecil.Cil.VariableDefinition,Mono.Cecil.Cil.VariableDefinition,Mono.Cecil.Cil.VariableDefinition,System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:LinFu.AOP.Cecil.EmitBeforeInvoke" /> class.
            </summary>
      <param name="invocationInfo">The variable that contains the <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> instance.</param>
      <param name="surroundingClassImplementation">The variable that contains the class-level <see cref="T:LinFu.AOP.Interfaces.IAroundInvoke" /> instance.</param>
      <param name="surroundingImplementation">The variable that contains the instance-level <see cref="T:LinFu.AOP.Interfaces.IAroundInvoke" /> instance.</param>
      <param name="registryType">The interception registry type that will be responsible for handling class-level interception events.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.EmitBeforeInvoke.Emit(Mono.Cecil.Cil.CilWorker)">
      <summary>
            Emits the call to the <see cref="T:LinFu.AOP.Interfaces.IAfterInvoke" /> instance.
            </summary>
      <param name="IL">The <see cref="T:Mono.Cecil.Cil.CilWorker" /> that points to the current method body.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.ExceptionHandlerInfo">
      <summary>
            Represents a class that describes the context of a thrown exception.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.ExceptionHandlerInfo.#ctor(System.Exception,LinFu.AOP.Interfaces.IInvocationInfo)">
      <summary>
            Initializes a new instance of the <see cref="T:LinFu.AOP.Cecil.ExceptionHandlerInfo" /> class.
            </summary>
      <param name="ex">The thrown exception.</param>
      <param name="invocationInfo">The <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> instance that describes the context of the method call.</param>
    </member>
    <member name="P:LinFu.AOP.Cecil.ExceptionHandlerInfo.Exception">
      <summary>
            Gets the value indicating the thrown exception.
            </summary>
      <value>The thrown exception.</value>
    </member>
    <member name="P:LinFu.AOP.Cecil.ExceptionHandlerInfo.InvocationInfo">
      <summary>
            Gets the value indicating the <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> instance that describes the context of the method
            that threw the exception.
            </summary>
      <value>The <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> instance.</value>
    </member>
    <member name="P:LinFu.AOP.Cecil.ExceptionHandlerInfo.ReturnValue">
      <summary>
            Gets or sets the value indicating the return value that will be used in place of the original return value if 
            the exception is intercepted by an <see cref="T:LinFu.AOP.Interfaces.IExceptionHandler" /> instance.
            </summary>
      <value>The method return value.</value>
    </member>
    <member name="P:LinFu.AOP.Cecil.ExceptionHandlerInfo.ShouldSkipRethrow">
      <summary>
            Gets or sets the value indicating whether or not the exception should be rethrown after
            the <see cref="T:LinFu.AOP.Interfaces.IExceptionHandler" /> handles the given exception.
            </summary>
      <value>This should be <c>true</c> if the exception should be rethrown, otherwise, it must be <c>false</c>.</value>
    </member>
    <member name="T:LinFu.AOP.Cecil.Extensions.ExceptionHandlerInterceptionExtensions">
      <summary>
            Represents an extension class that adds support for intercepting exceptions thrown at runtime.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.ExceptionHandlerInterceptionExtensions.InterceptAllExceptions(Mono.Cecil.IReflectionVisitable)">
      <summary>
            Enables exception interception on the given type.
            </summary>
      <param name="visitable">The target type.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.ExceptionHandlerInterceptionExtensions.InterceptAllExceptions(Mono.Cecil.IReflectionStructureVisitable)">
      <summary>
            Enables exception interception on the given type.
            </summary>
      <param name="visitable">The target type.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.ExceptionHandlerInterceptionExtensions.InterceptExceptions(Mono.Cecil.IReflectionVisitable,LinFu.AOP.Cecil.Interfaces.IMethodFilter)">
      <summary>
            Enables exception interception on the given type.
            </summary>
      <param name="visitable">The target type.</param>
      <param name="methodFilter">The <see cref="T:LinFu.AOP.Cecil.Interfaces.IMethodFilter" /> instance that will determine which methods should support exception interception.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.ExceptionHandlerInterceptionExtensions.InterceptExceptions(Mono.Cecil.IReflectionStructureVisitable,LinFu.AOP.Cecil.Interfaces.IMethodFilter)">
      <summary>
            Enables exception interception on the given type.
            </summary>
      <param name="visitable">The target type.</param>
      <param name="methodFilter">The <see cref="T:LinFu.AOP.Cecil.Interfaces.IMethodFilter" /> instance that will determine which methods should support exception interception.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.ExceptionHandlerInterceptionExtensions.InterceptExceptions(Mono.Cecil.IReflectionStructureVisitable,System.Func{Mono.Cecil.MethodReference,System.Boolean})">
      <summary>
            Enables exception interception on the given type.
            </summary>
      <param name="visitable">The target type.</param>
      <param name="methodFilter">The method filter functor that will determine which methods should support exception interception.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.ExceptionHandlerInterceptionExtensions.InterceptExceptions(Mono.Cecil.IReflectionVisitable,System.Func{Mono.Cecil.MethodReference,System.Boolean})">
      <summary>
            Enables exception interception on the given type.
            </summary>
      <param name="visitable">The target type.</param>
      <param name="methodFilter">The method filter functor that will determine which methods should support exception interception.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.Factories.AddInvocationInfoActionFactory">
      <summary>
            A factory instance that creates <see cref="T:System.Action`1" /> delegates
            that emit the necessary <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> information
            and store it in a local variable named '__invocationInfo___'.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.Factories.AddInvocationInfoActionFactory.CreateInstance(LinFu.IoC.Interfaces.IFactoryRequest)">
      <summary>
            Generates the <see cref="T:System.Action`1" /> delegate that will emit
            the necessary <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> information.
            </summary>
      <param name="request">The <see cref="T:LinFu.IoC.Interfaces.IFactoryRequest" /> instance that describes the requested service type.</param>
      <returns>A delegate that can emit the necessary <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> context that will allow other developers to infer information about the method currently being executed.</returns>
    </member>
    <member name="T:LinFu.AOP.Cecil.Factories.AssemblyWeaverActionFactory">
      <summary>
            Represents a class that generates <see cref="T:System.Action`2" /> instances
            that apply a specific method weaver (with the name given in the first delegate parameter)
            to every type in every module of an <see cref="T:Mono.Cecil.AssemblyDefinition" /> instance.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.Factories.AssemblyWeaverActionFactory.CreateInstance(LinFu.IoC.Interfaces.IFactoryRequest)">
      <summary>
            Generates <see cref="T:System.Action`2" /> instances
            that apply a specific method weaver (with the name given in the first delegate parameter)
            to every type in every module of an <see cref="T:Mono.Cecil.AssemblyDefinition" /> instance.
            </summary>
      <param name="request">The <see cref="T:LinFu.IoC.Interfaces.IFactoryRequest" /> that describes the service request.</param>
      <returns>An action delegate that will apply a specific method weaver to all the types in the given assembly.</returns>
    </member>
    <member name="T:LinFu.AOP.Cecil.Factories.TypeWeaverActionFactory">
      <summary>
            Represents a class that generates <see cref="T:System.Action`2" /> instances
            that apply a specific method weaver (with the name given in the first delegate parameter)
            to a specific <see cref="T:Mono.Cecil.TypeDefinition" /> instance.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.Factories.TypeWeaverActionFactory.CreateInstance(LinFu.IoC.Interfaces.IFactoryRequest)">
      <summary>
            Generates the <see cref="T:System.Action`2" /> instance that will
            weave the target type.
            </summary>
      <param name="request">The <see cref="T:LinFu.IoC.Interfaces.IFactoryRequest" /> that describes the service request.</param>
      <returns>The <see cref="T:System.Action`2" /> instance that will weave the target type.</returns>
    </member>
    <member name="T:LinFu.AOP.Cecil.GetMethodReplacementProvider">
      <summary>
            Represents a class that emits the instructions that obtain an instance-level <see cref="T:LinFu.AOP.Interfaces.IMethodReplacementProvider" /> instance.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.GetMethodReplacementProvider.#ctor(Mono.Cecil.Cil.VariableDefinition,Mono.Cecil.MethodDefinition,System.Func{Mono.Cecil.ModuleDefinition,Mono.Cecil.MethodReference})">
      <summary>
            Initializes a new instance of the <see cref="T:LinFu.AOP.Cecil.GetMethodReplacementProvider" /> class.
            </summary>
      <param name="methodReplacementProvider">The local variable that contains the <see cref="T:LinFu.AOP.Interfaces.IMethodReplacementProvider" /> instance.</param>
      <param name="hostMethod">The target method.</param>
      <param name="resolveGetProviderMethod">The functor that will resolve the GetProvider method.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.GetMethodReplacementProvider.Emit(Mono.Cecil.Cil.CilWorker)">
      <summary>
            Emits the instructions that obtain the <see cref="T:LinFu.AOP.Interfaces.IMethodReplacementProvider" /> instance.
            </summary>
      <param name="IL">The <see cref="T:Mono.Cecil.Cil.CilWorker" /> instance.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.GetSurroundingClassImplementation">
      <summary>
            Represents a class that emits the instructions that obtain the <see cref="T:LinFu.AOP.Interfaces.IAroundInvoke" /> instance.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.GetSurroundingClassImplementation.#ctor(Mono.Cecil.Cil.VariableDefinition,Mono.Cecil.Cil.VariableDefinition,System.Reflection.MethodInfo)">
      <summary>
            Initializes a new instance of the <see cref="T:LinFu.AOP.Cecil.GetSurroundingClassImplementation" /> class.
            </summary>
      <param name="invocationInfo">The variable that contains the <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> instance.</param>
      <param name="surroundingClassImplementation">The variable that contains the <see cref="T:LinFu.AOP.Interfaces.IAroundInvoke" /> instance.</param>
      <param name="getSurroundingImplementationMethod">The method that will obtain the <see cref="T:LinFu.AOP.Interfaces.IAroundInvoke" /> instance.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.GetSurroundingClassImplementation.Emit(Mono.Cecil.Cil.CilWorker)">
      <summary>
            Emits the instructions that obtain the <see cref="T:LinFu.AOP.Interfaces.IAroundInvoke" /> instance.
            </summary>
      <param name="IL">The <see cref="T:Mono.Cecil.Cil.CilWorker" /> that points to the current method body.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.GetSurroundingImplementationInstance">
      <summary>
            Represents a class that emits the instructions that obtain the current <see cref="T:LinFu.AOP.Interfaces.IAroundInvoke" /> instance.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.GetSurroundingImplementationInstance.#ctor(Mono.Cecil.Cil.VariableDefinition,Mono.Cecil.Cil.VariableDefinition,Mono.Cecil.Cil.VariableDefinition,Mono.Cecil.Cil.Instruction)">
      <summary>
            Initializes a new instance of the <see cref="T:LinFu.AOP.Cecil.GetSurroundingImplementationInstance" /> class.
            </summary>
      <param name="aroundInvokeProvider">The variable that will hold the <see cref="T:LinFu.AOP.Interfaces.IAroundInvokeProvider" /> instance.</param>
      <param name="invocationInfo">
      </param>
      <param name="surroundingImplementation">
      </param>
      <param name="skipGetSurroundingImplementation">
      </param>
    </member>
    <member name="M:LinFu.AOP.Cecil.GetSurroundingImplementationInstance.Emit(Mono.Cecil.Cil.CilWorker)">
      <summary>
            Emits the instructions that obtain the current <see cref="T:LinFu.AOP.Interfaces.IAroundInvoke" /> instance.
            </summary>
      <param name="IL">
      </param>
    </member>
    <member name="T:LinFu.AOP.Cecil.GetAroundInvokeProvider">
      <summary>
            Represents a class that emits the call to obtain the <see cref="T:LinFu.AOP.Interfaces.IAroundInvokeProvider" /> instance.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.GetAroundInvokeProvider.#ctor(Mono.Cecil.Cil.VariableDefinition,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:LinFu.AOP.Cecil.GetAroundInvokeProvider" /> class.
            </summary>
      <param name="aroundInvokeProvider">The local variable that holds the <see cref="T:LinFu.AOP.Interfaces.IAroundInvokeProvider" /> instance.</param>
      <param name="providerName">The name of the <see cref="T:LinFu.AOP.Interfaces.IAroundInvokeProvider" /> property.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.GetAroundInvokeProvider.Emit(Mono.Cecil.Cil.CilWorker)">
      <summary>
            Emits the call to obtain the <see cref="T:LinFu.AOP.Interfaces.IAroundInvokeProvider" /> instance.
            </summary>
      <param name="IL">The <see cref="T:Mono.Cecil.Cil.CilWorker" /> pointing to the target method body.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.GetInterceptionDisabled">
      <summary>
            Represents a class that emits the instructions that determine whether or not method interception is disabled.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.GetInterceptionDisabled.#ctor(LinFu.AOP.Cecil.IMethodBodyRewriterParameters)">
      <summary>
            Initializes a new instance of the <see cref="T:LinFu.AOP.Cecil.GetInterceptionDisabled" /> class.
            </summary>
      <param name="parameters">The <see cref="T:LinFu.AOP.Cecil.IMethodBodyRewriterParameters" /> instance.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.GetInterceptionDisabled.#ctor(Mono.Cecil.MethodReference,Mono.Cecil.Cil.VariableDefinition)">
      <summary>
            Initializes a new instance of the <see cref="T:LinFu.AOP.Cecil.GetInterceptionDisabled" /> class.
            </summary>
      <param name="hostMethod">The target method.</param>
      <param name="interceptionDisabled">The local variable that determines whether or not method interception is disabled.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.GetInterceptionDisabled.Emit(Mono.Cecil.Cil.CilWorker)">
      <summary>
            Emits the instructions that determine whether or not method interception is disabled.
            </summary>
      <param name="IL">The <see cref="T:Mono.Cecil.Cil.CilWorker" /> instance responsible for adding or removing instructions to the method body.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.GetClassMethodReplacementProvider">
      <summary>
            Represents a class that emits the instructions that obtain a class-level <see cref="T:LinFu.AOP.Interfaces.IMethodReplacementProvider" /> instance.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.GetClassMethodReplacementProvider.#ctor(LinFu.AOP.Cecil.IMethodBodyRewriterParameters,System.Func{Mono.Cecil.ModuleDefinition,Mono.Cecil.MethodReference})">
      <summary>
            Initializes a new instance of the <see cref="T:LinFu.AOP.Cecil.GetClassMethodReplacementProvider" /> class.
            </summary>
      <param name="parameters">The method body rewriter paramters that describe the </param>
      <param name="resolveGetProviderMethod">The functor that resolves the method that obtains the method replacement provider instance.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.GetClassMethodReplacementProvider.#ctor(Mono.Cecil.Cil.VariableDefinition,Mono.Cecil.Cil.VariableDefinition,System.Func{Mono.Cecil.ModuleDefinition,Mono.Cecil.MethodReference})">
      <summary>
            Initializes a new instance of the <see cref="T:LinFu.AOP.Cecil.GetClassMethodReplacementProvider" /> class.
            </summary>
      <param name="invocationInfo">The variable that contains the <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> instance.</param>
      <param name="classMethodReplacementProvider">The variable that contains the class method replacement provider instance.</param>
      <param name="resolveGetProviderMethod">The functor that resolves the method that obtains the method replacement provider instance.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.GetClassMethodReplacementProvider.Emit(Mono.Cecil.Cil.CilWorker)">
      <summary>
            Emits the instructions that obtain a class-level <see cref="T:LinFu.AOP.Interfaces.IMethodReplacementProvider" /> instance.
            </summary>
      <param name="IL">The <see cref="T:Mono.Cecil.Cil.CilWorker" /> instance that points to the instructions in the method body.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.Extensions.FieldInterceptionExtensions">
      <summary>
            Represents an extension class that adds field interception support to a given type.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.FieldInterceptionExtensions.InterceptAllFields(Mono.Cecil.IReflectionStructureVisitable)">
      <summary>
            Adds field interception support to the target type.
            </summary>
      <param name="targetType">The type that will be modified.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.FieldInterceptionExtensions.InterceptAllInstanceFields(Mono.Cecil.IReflectionStructureVisitable)">
      <summary>
            Adds field interception support intercepting all instance fields on the target type.
            </summary>
      <param name="targetType">The type that will be modified.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.FieldInterceptionExtensions.InterceptAllStaticFields(Mono.Cecil.IReflectionStructureVisitable)">
      <summary>
            Adds field interception support intercepting all static fields on the target type.
            </summary>
      <param name="targetType">The type that will be modified.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.FieldInterceptionExtensions.InterceptAllFields(Mono.Cecil.IReflectionVisitable)">
      <summary>
            Adds field interception support to the target type.
            </summary>
      <param name="targetType">The type that will be modified.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.FieldInterceptionExtensions.InterceptAllInstanceFields(Mono.Cecil.IReflectionVisitable)">
      <summary>
            Adds field interception support intercepting all instance fields on the target type.
            </summary>
      <param name="targetType">The type that will be modified.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.FieldInterceptionExtensions.InterceptAllStaticFields(Mono.Cecil.IReflectionVisitable)">
      <summary>
            Adds field interception support intercepting all static fields on the target type.
            </summary>
      <param name="targetType">The type that will be modified.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.FieldInterceptionExtensions.InterceptFields(Mono.Cecil.IReflectionVisitable,System.Func{Mono.Cecil.MethodReference,System.Boolean},System.Func{Mono.Cecil.FieldReference,System.Boolean})">
      <summary>
            Adds field interception support to the target type.
            </summary>
      <param name="targetType">The type that will be modified.</param>
      <param name="methodFilter">The filter that determines which methods on the target type will be modified to support field interception.</param>
      <param name="fieldFilter">The filter that determines which fields should be intercepted.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.FieldInterceptionExtensions.InterceptFields(Mono.Cecil.IReflectionStructureVisitable,LinFu.AOP.Cecil.ITypeFilter,LinFu.AOP.Cecil.Interfaces.IFieldFilter)">
      <summary>
            Adds field interception support to the target type.
            </summary>
      <param name="targetType">The type that will be modified.</param>
      <param name="hostTypeFilter">The filter that determines the host types to be modified.</param>
      <param name="fieldFilter">The field filter that determines the fields that will be intercepted.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.FieldInterceptionExtensions.InterceptFields(Mono.Cecil.IReflectionStructureVisitable,System.Func{Mono.Cecil.MethodReference,System.Boolean},System.Func{Mono.Cecil.FieldReference,System.Boolean})">
      <summary>
            Adds field interception support to the target type.
            </summary>
      <param name="targetType">The type that will be modified.</param>
      <param name="methodFilter">The filter that determines which methods on the target type will be modified to support field interception.</param>
      <param name="fieldFilter">The filter that determines which fields should be intercepted.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.Interfaces.IFieldFilter">
      <summary>
            Represents a type that determines whether or not a particular field get or set should be intercepted.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.Interfaces.IFieldFilter.ShouldWeave(Mono.Cecil.MethodReference,Mono.Cecil.FieldReference)">
      <summary>
            Determines whether or not a particular field get or set should be intercepted.
            </summary>
      <param name="hostMethod">The host method.</param>
      <param name="targetField">The target field.</param>
      <returns>Returns <c>true</c> if the field should be intercepted; otherwise, it will return <c>false</c>.</returns>
    </member>
    <member name="T:LinFu.AOP.Cecil.FieldFilterAdapter">
      <summary>
            Represents an adapter class that maps a functor to an <see cref="T:LinFu.AOP.Cecil.Interfaces.IFieldFilter" /> instance.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.FieldFilterAdapter.#ctor(System.Func{Mono.Cecil.FieldReference,System.Boolean})">
      <summary>
            Initializes a new instance of the <see cref="T:LinFu.AOP.Cecil.FieldFilterAdapter" /> class.
            </summary>
      <param name="filter">The field filter.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.FieldFilterAdapter.ShouldWeave(Mono.Cecil.MethodReference,Mono.Cecil.FieldReference)">
      <summary>
            Determines whether or not a particular field get or set should be intercepted.
            </summary>
      <param name="hostMethod">The host method.</param>
      <param name="targetField">The target field.</param>
      <returns>Returns <c>true</c> if the field should be intercepted; otherwise, it will return <c>false</c>.</returns>
    </member>
    <member name="T:LinFu.AOP.Cecil.IgnoredInstancesRegistry">
      <summary>
            Represents a class that keeps track of the internal object instances that should be ignored
            by the interception routines.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.IgnoredInstancesRegistry.Contains(System.Object)">
      <summary>
            Determines whether or not the registry contains the given ignored object.
            </summary>
      <param name="target">The target object.</param>
      <returns>Returns <c>true</c> if the object should be ignored; otherwise, it will return <c>false</c>.</returns>
    </member>
    <member name="M:LinFu.AOP.Cecil.IgnoredInstancesRegistry.AddInstance(System.Object)">
      <summary>
            Adds an instance to the list of ignored instances.
            </summary>
      <param name="target">The target instance to be ignored by the interception routines.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.Interfaces.IMethodFilter">
      <summary>
            Represents a type that determines which host methods should be modified for method call interception.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.Interfaces.IMethodFilter.ShouldWeave(Mono.Cecil.MethodReference)">
      <summary>
            Determines whether or not a particular method should be modified.
            </summary>
      <param name="targetMethod">The target method to be modified.</param>
      <returns>Returns <c>true</c> if the method should be modified; otherwise, it will return <c>false</c>.</returns>
    </member>
    <member name="T:LinFu.AOP.Cecil.Interfaces.IMethodCallFilter">
      <summary>
            Represents a type that determines the method calls that need to be intercepted.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.Interfaces.IMethodCallFilter.ShouldWeave(Mono.Cecil.TypeReference,Mono.Cecil.MethodReference,Mono.Cecil.MethodReference)">
      <summary>
            Determines whether or not a particular method call should be intercepted.
            </summary>
      <param name="targetType">The host type that contains the method call.</param>
      <param name="hostMethod">The method that contains the current method call.</param>
      <param name="currentMethodCall">The method call to be intercepted.</param>
      <returns>Returns <c>true</c> if the method call should be intercepted; otherwise, it will return <c>false</c>.</returns>
    </member>
    <member name="T:LinFu.AOP.Cecil.IMethodBodyRewriterParameters">
      <summary>
            Represents the parameters used to add interception to a given method body.
            </summary>
    </member>
    <member name="P:LinFu.AOP.Cecil.IMethodBodyRewriterParameters.TargetMethod">
      <summary>
            Gets the value indicating the TargetMethod to be modified.
            </summary>
      <value>The method to be modified.</value>
    </member>
    <member name="P:LinFu.AOP.Cecil.IMethodBodyRewriterParameters.AroundInvokeProvider">
      <summary>
            Gets the value indicating the local variable used to store the <see cref="T:LinFu.AOP.Interfaces.IAroundInvokeProvider" /> instance.
            </summary>
      <value>The <see cref="T:LinFu.AOP.Interfaces.IAroundInvokeProvider" /> instance.</value>
    </member>
    <member name="P:LinFu.AOP.Cecil.IMethodBodyRewriterParameters.MethodReplacementProvider">
      <summary>
            Gets the value indicating the local variable used to store the <see cref="T:LinFu.AOP.Interfaces.IMethodReplacementProvider" /> instance.
            </summary>
      <value>The <see cref="T:LinFu.AOP.Interfaces.IMethodReplacementProvider" /> instance.</value>
    </member>
    <member name="P:LinFu.AOP.Cecil.IMethodBodyRewriterParameters.ClassMethodReplacementProvider">
      <summary>
            Gets the value indicating the class-level<see cref="T:LinFu.AOP.Interfaces.IMethodReplacementProvider" /> instance.
            </summary>
      <value>The class-level<see cref="T:LinFu.AOP.Interfaces.IMethodReplacementProvider" /> instance.</value>
    </member>
    <member name="P:LinFu.AOP.Cecil.IMethodBodyRewriterParameters.InterceptionDisabled">
      <summary>
            Gets the value indicating the local variable that will store the value that determines whether or not
            interception is disabled.
            </summary>
      <value>The value that determines whether or not interception is disabled.</value>
    </member>
    <member name="P:LinFu.AOP.Cecil.IMethodBodyRewriterParameters.InvocationInfo">
      <summary>
            Gets the value indicating the local variable that will store the <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> instance.
            </summary>
      <value>The local variable that will store the <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> instance.</value>
    </member>
    <member name="P:LinFu.AOP.Cecil.IMethodBodyRewriterParameters.ReturnValue">
      <summary>
            Gets the value indicating the local variable that will store the return value.
            </summary>
      <value>The value indicating the local variable that will store the return value.</value>
    </member>
    <member name="P:LinFu.AOP.Cecil.IMethodBodyRewriterParameters.RegistryType">
      <summary>
            Gets the value indicating the interception registry type that will be responsible for handling class-level interception events.
            </summary>
      <value>The interception registry type that will be responsible for handling class-level interception events.</value>
    </member>
    <member name="P:LinFu.AOP.Cecil.IMethodBodyRewriterParameters.GetMethodReplacementProviderMethod">
      <summary>
            Gets the value indicating the functor that resolves the GetMethodReplacementProvider method.
            </summary>
      <value>The functor that resolves the GetMethodReplacementProvider method.</value>
    </member>
    <member name="P:LinFu.AOP.Cecil.IMethodBodyRewriterParameters.OldInstructions">
      <summary>
            Gets the value indicating the list of old instructions in the current method body.
            </summary>
      <value>The value indicating the list of old instructions in the current method body.</value>
    </member>
    <member name="T:LinFu.AOP.Cecil.Interfaces.INewInstanceFilter">
      <summary>
            Represents a type that determines the constructor calls that will be intercepted by the postweaver.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.Interfaces.INewInstanceFilter.ShouldWeave(Mono.Cecil.MethodReference,Mono.Cecil.TypeReference,Mono.Cecil.MethodReference)">
      <summary>
            Determines whether or not a particular constructor call should be intercepted by the postweaver.
            </summary>
      <param name="currentConstructor">The constructor used to instantiate the current instance.</param>
      <param name="concreteType">The concrete type that contains the new instance call.</param>
      <param name="hostMethod">The host method that contains the new operator call.</param>
      <returns>Returns <c>true</c> if the new operator call should be intercepted; otherwise, it should return <c>false</c>.</returns>
    </member>
    <member name="T:LinFu.AOP.Cecil.MethodCallFilterAdapter">
      <summary>
            Represents a type that converts functors into method call filter instances.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.MethodCallFilterAdapter.#ctor(System.Func{Mono.Cecil.MethodReference,System.Boolean},System.Func{Mono.Cecil.MethodReference,System.Boolean})">
      <summary>
            Initializes a new instance of the <see cref="T:LinFu.AOP.Cecil.MethodCallFilterAdapter" /> class.
            </summary>
      <param name="hostMethodFilter">The method filter that will determine the host methods that will be modified for interception.</param>
      <param name="methodCallFilter">The method filter that will determine which method calls will be intercepted.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.MethodCallFilterAdapter.ShouldWeave(Mono.Cecil.TypeReference,Mono.Cecil.MethodReference,Mono.Cecil.MethodReference)">
      <summary>
            Determines whether or not a particular method call should be intercepted.
            </summary>
      <param name="targetType">The host type that contains the method call.</param>
      <param name="hostMethod">The method that contains the current method call.</param>
      <param name="currentMethodCall">The method call to be intercepted.</param>
      <returns>Returns <c>true</c> if the method call should be intercepted; otherwise, it will return <c>false</c>.</returns>
    </member>
    <member name="T:LinFu.AOP.Cecil.NewInstanceInterceptionAdapter">
      <summary>
            Represents an adapter class that maps <see cref="T:LinFu.AOP.Cecil.Interfaces.INewInstanceFilter" /> instances to 
            functors.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.NewInstanceInterceptionAdapter.#ctor(System.Func{Mono.Cecil.MethodReference,Mono.Cecil.TypeReference,Mono.Cecil.MethodReference,System.Boolean})">
      <summary>
            Initializes a new instance of the <see cref="T:LinFu.AOP.Cecil.NewInstanceInterceptionAdapter" /> class.
            </summary>
      <param name="filter">The filter that determines which instances will be intercepted.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.NewInstanceInterceptionAdapter.ShouldWeave(Mono.Cecil.MethodReference,Mono.Cecil.TypeReference,Mono.Cecil.MethodReference)">
      <summary>
            Determines whether or not a particular constructor call should be intercepted by the postweaver.
            </summary>
      <param name="currentConstructor">The constructor used to instantiate the current instance.</param>
      <param name="concreteType">The concrete type that contains the new instance call.</param>
      <param name="hostMethod">The host method that contains the new operator call.</param>
      <returns>Returns <c>true</c> if the new operator call should be intercepted; otherwise, it should return <c>false</c>.</returns>
    </member>
    <member name="T:LinFu.AOP.Cecil.Interfaces.IWeaver`2">
      <summary>
            Represents a class that can weave (or modify) 
            a member embedded in an assembly.
            </summary>
      <typeparam name="T">The type of object to modify.</typeparam>
      <typeparam name="THost">The host that holds the item to be modified.</typeparam>
    </member>
    <member name="M:LinFu.AOP.Cecil.Interfaces.IWeaver`2.ShouldWeave(`0)">
      <summary>
            Determines whether or not the current item should be modified.
            </summary>
      <param name="item">The target item.</param>
      <returns>Returns <c>true</c> if the current item can be modified; otherwise, it should return <c>false.</c></returns>
    </member>
    <member name="M:LinFu.AOP.Cecil.Interfaces.IWeaver`2.Weave(`0)">
      <summary>
            Modifies the target <paramref name="item" />.
            </summary>
      <param name="item">The item to be modified.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.Interfaces.ITypeWeaver">
      <summary>
            Represents a type that can modify an existing <see cref="T:Mono.Cecil.TypeDefinition" />.
            </summary>
    </member>
    <member name="T:LinFu.AOP.Cecil.ImplementFieldInterceptionHostWeaver">
      <summary>
            Represents a type weaver that modifies types to implement the <see cref="T:LinFu.AOP.Interfaces.IFieldInterceptionHost" /> interface.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.ImplementFieldInterceptionHostWeaver.#ctor(System.Func{Mono.Cecil.TypeReference,System.Boolean})">
      <summary>
            Initializes a new instance of the ImplementFieldInterceptionHostWeaver class.
            </summary>
      <param name="filter">The filter that determines which types should be modified.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.ImplementFieldInterceptionHostWeaver.ShouldWeave(Mono.Cecil.TypeDefinition)">
      <summary>
            Determines whether or not a type should be modified.
            </summary>
      <param name="item">
      </param>
      <returns>
        <c>true</c> if the type should be modified; otherwise, it will return <c>false</c>.</returns>
    </member>
    <member name="M:LinFu.AOP.Cecil.ImplementFieldInterceptionHostWeaver.Weave(Mono.Cecil.TypeDefinition)">
      <summary>
            Modifies the target type.
            </summary>
      <param name="type">The type to be modified.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.ImplementFieldInterceptionHostWeaver.AddAdditionalMembers(Mono.Cecil.ModuleDefinition)">
      <summary>
            Adds additional members to the target module.
            </summary>
      <param name="host">The host module.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.ImplementFieldInterceptionHostWeaver.ImportReferences(Mono.Cecil.ModuleDefinition)">
      <summary>
            Imports references into the target module.
            </summary>
      <param name="module">The module containing the type to be modified.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.Interfaces.IInstructionProvider">
      <summary>
            Represents a type that can provide the instructions for a given method.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.Interfaces.IInstructionProvider.GetInstructions(Mono.Cecil.MethodDefinition)">
      <summary>
            Determines the instructions for a given method.
            </summary>
      <param name="method">The source method that contains the instructions.</param>
      <returns>The set of instructions for the given method.</returns>
    </member>
    <member name="T:LinFu.AOP.Cecil.InstructionProvider">
      <summary>
            Represents the default implementation of the <see cref="T:LinFu.AOP.Cecil.Interfaces.IInstructionProvider" /> class.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.InstructionProvider.GetInstructions(Mono.Cecil.MethodDefinition)">
      <summary>
            Determines the instructions for a given method.
            </summary>
      <param name="method">The source method that contains the instructions.</param>
      <returns>The set of instructions for the given method.</returns>
    </member>
    <member name="T:LinFu.AOP.Cecil.InstructionSwapper">
      <summary>
            Provides the basic functionality for the <see cref="T:LinFu.AOP.Cecil.Interfaces.IMethodRewriter" /> interface.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.InstructionSwapper.#ctor">
      <summary>
            Initializes a new instance of the MethodRewriter class.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.InstructionSwapper.RewriteMethodBody(Mono.Cecil.MethodDefinition,Mono.Cecil.Cil.CilWorker,System.Collections.Generic.IEnumerable{Mono.Cecil.Cil.Instruction})">
      <summary>
            Rewrites the instructions in the target method body.
            </summary>
      <param name="method">The target method.</param>
      <param name="IL">The <see cref="T:Mono.Cecil.Cil.CilWorker" /> instance that represents the method body.</param>
      <param name="oldInstructions">The IL instructions of the original method body.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.InstructionSwapper.ShouldReplace(Mono.Cecil.Cil.Instruction,Mono.Cecil.MethodDefinition)">
      <summary>
            Determines whether or not the method rewriter should replace the <paramref name="oldInstruction" />.
            </summary>
      <param name="oldInstruction">The instruction that is currently being evaluated.</param>
      <param name="hostMethod">The method that hosts the current instruction.</param>
      <returns>
        <c>true</c> if the method should be replaced; otherwise, it should return <c>false</c>.</returns>
    </member>
    <member name="M:LinFu.AOP.Cecil.InstructionSwapper.Replace(Mono.Cecil.Cil.Instruction,Mono.Cecil.MethodDefinition,Mono.Cecil.Cil.CilWorker)">
      <summary>
            Replaces the <paramref name="oldInstruction" /> with a new set of <paramref name="IL" /> instructions..
            </summary>
      <param name="oldInstruction">The instruction currently being evaluated.</param>
      <param name="hostMethod">The method that contains the target instruction.</param>
      <param name="IL">The CilWorker for the target method body.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.InterceptAndSurroundMethodBody">
      <summary>
            Represents a method body rewriter that surrounds a method body with the necessary prolog and epilogs
            that enable method body interception.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.InterceptAndSurroundMethodBody.#ctor(LinFu.AOP.Cecil.Interfaces.IEmitInvocationInfo,LinFu.AOP.Cecil.Interfaces.IInstructionEmitter,LinFu.AOP.Cecil.ISurroundMethodBody,LinFu.AOP.Cecil.Interfaces.IInstructionEmitter,LinFu.AOP.Cecil.Interfaces.IInstructionEmitter,LinFu.AOP.Cecil.Interfaces.IInstructionEmitter,LinFu.AOP.Cecil.IMethodBodyRewriterParameters)">
      <summary>
            Initializes a new instance of the <see cref="T:LinFu.AOP.Cecil.InterceptAndSurroundMethodBody" /> class.
            </summary>
      <param name="emitter">The emitter that will instantiate the <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> instance.</param>
      <param name="getInterceptionDisabled">The emitter that will determine whether or not method interception is enabled.</param>
      <param name="surroundMethodBody">The <see cref="T:LinFu.AOP.Cecil.ISurroundMethodBody" /> instance that will add the epilogs and prologs to the method body.</param>
      <param name="getInstanceMethodReplacementProvider">The emitter that will obtain the method replacement provider instance.</param>
      <param name="getClassMethodReplacementProvider">The emitter that will obtain the class-level method replacement provider instance.</param>
      <param name="addMethodReplacement">The instruction emitter that will add the call to obtain the method body replacement instance. </param>
      <param name="parameters">The parameters that describe the context of the method body rewrite.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.InterceptAndSurroundMethodBody.Rewrite(Mono.Cecil.MethodDefinition,Mono.Cecil.Cil.CilWorker,System.Collections.Generic.IEnumerable{Mono.Cecil.Cil.Instruction})">
      <summary>
            Rewrites a target method using the given CilWorker.
            </summary>
      <param name="method">The target method.</param>
      <param name="IL">The CilWorker that will be used to rewrite the target method.</param>
      <param name="oldInstructions">The original instructions from the target method body.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.InterceptFieldAccess">
      <summary>
            Represents a <see cref="T:LinFu.AOP.Cecil.MethodRewriter" /> that intercepts calls to field getters and setters and redirects those calls to
            a <see cref="T:LinFu.AOP.Interfaces.IFieldInterceptor" /> instance.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.InterceptFieldAccess.#ctor(System.Func{Mono.Cecil.FieldReference,System.Boolean})">
      <summary>
            Initializes a new instance of the InterceptFieldAccess class.
            </summary>
      <param name="filter">The filter that determines which fields should be intercepted.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.InterceptFieldAccess.#ctor(LinFu.AOP.Cecil.Interfaces.IFieldFilter)">
      <summary>
            Initializes a new instance of the InterceptFieldAccess class.
            </summary>
      <param name="filter">The filter that determines which fields should be intercepted.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.InterceptFieldAccess.AddLocals(Mono.Cecil.MethodDefinition)">
      <summary>
            Adds locals to the target method.
            </summary>
      <param name="hostMethod">The method to be modified</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.InterceptFieldAccess.ImportReferences(Mono.Cecil.ModuleDefinition)">
      <summary>
            Adds references to the target module.
            </summary>
      <param name="module">The module that will be modified.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.InterceptFieldAccess.ShouldReplace(Mono.Cecil.Cil.Instruction,Mono.Cecil.MethodDefinition)">
      <summary>
            Determines whether or not the method rewriter should replace the <paramref name="oldInstruction" />.
            </summary>
      <remarks>The <see cref="T:LinFu.AOP.Cecil.InterceptFieldAccess" /> class only modifies instructions that get or set the value of static and instance fields.</remarks>
      <param name="oldInstruction">The instruction that is currently being evaluated.</param>
      <param name="hostMethod">The method that hosts the current instruction.</param>
      <returns>
        <c>true</c> if the method should be replaced; otherwise, it should return <c>false</c>.</returns>
    </member>
    <member name="M:LinFu.AOP.Cecil.InterceptFieldAccess.Replace(Mono.Cecil.Cil.Instruction,Mono.Cecil.MethodDefinition,Mono.Cecil.Cil.CilWorker)">
      <summary>
            Replaces the <paramref name="oldInstruction" /> with a set of new instructions.
            </summary>
      <param name="oldInstruction">The instruction currently being evaluated.</param>
      <param name="hostMethod">The method that contains the target instruction.</param>
      <param name="IL">The CilWorker that will be used to emit the method body instructions.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.InterceptMethodBody">
      <summary>
            Represents a method rewriter type that adds interception capabilities to any given method body.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.InterceptMethodBody.#ctor(System.Func{Mono.Cecil.MethodReference,System.Boolean})">
      <summary>
            Initializes a new instance of the <see cref="T:LinFu.AOP.Cecil.InterceptMethodBody" /> class.
            </summary>
      <param name="methodFilter">The method filter that will determine the methods with the method bodies that will be intercepted.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.InterceptMethodBody.ShouldRewrite(Mono.Cecil.MethodDefinition)">
      <summary>
            Determines whether or not the given method should be modified.
            </summary>
      <param name="targetMethod">The target method.</param>
      <returns>A <see cref="T:System.Boolean" /> indicating whether or not a method should be rewritten.</returns>
    </member>
    <member name="M:LinFu.AOP.Cecil.InterceptMethodBody.RewriteMethodBody(Mono.Cecil.MethodDefinition,Mono.Cecil.Cil.CilWorker,System.Collections.Generic.IEnumerable{Mono.Cecil.Cil.Instruction})">
      <summary>
            Rewrites the instructions in the target method body.
            </summary>
      <param name="method">The target method.</param>
      <param name="IL">The <see cref="T:Mono.Cecil.Cil.CilWorker" /> instance that represents the method body.</param>
      <param name="oldInstructions">The IL instructions of the original method body.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.Interfaces.IAroundMethodWeaver">
      <summary>
            Represents a class that adds a method
            epilog and prolog to an existing method instance.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.Interfaces.IAroundMethodWeaver.ShouldWeave(Mono.Cecil.MethodDefinition)">
      <summary>
            Determines whether or not the current item should be modified.
            </summary>
      <param name="method">The target item.</param>
      <returns>Returns <c>true</c> if the current item can be modified; otherwise, it should return <c>false.</c></returns>
    </member>
    <member name="M:LinFu.AOP.Cecil.Interfaces.IAroundMethodWeaver.AddProlog(Mono.Cecil.Cil.Instruction,Mono.Cecil.Cil.MethodBody)">
      <summary>
            Adds an prolog to the target method.
            </summary>
      <param name="firstInstruction">The instruction that marks the start of the <paramref name="methodBody" /></param>
      <param name="methodBody">The method body of the target method.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.Interfaces.IAroundMethodWeaver.AddEpilog(Mono.Cecil.Cil.Instruction,Mono.Cecil.Cil.MethodBody)">
      <summary>
            Adds an epilog to the target method.
            </summary>
      <param name="lastInstruction">The instruction that marks the end of the <paramref name="methodBody" /></param>
      <param name="methodBody">The method body of the target method.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.Interfaces.IEmitInvocationInfo">
      <summary>
            Represents a class that emits
            the IL to save information about
            the method currently being executed.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.Interfaces.IEmitInvocationInfo.Emit(Mono.Cecil.MethodDefinition,Mono.Cecil.MethodReference,Mono.Cecil.Cil.VariableDefinition)">
      <summary>
            Emits the IL to save information about
            the method currently being executed.
            </summary>
      <seealso cref="T:LinFu.AOP.Interfaces.IInvocationInfo" />
      <param name="targetMethod">The target method currently being executed.</param>
      <param name="currentMethod">The method that will be passed to the <paramref name="invocationInfo" /> as the currently executing method.</param>
      <param name="invocationInfo">The local variable that will store the resulting <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> instance.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.Interfaces.IMethodWeaver">
      <summary>
            Represents a type that can modify <see cref="T:Mono.Cecil.MethodDefinition" /> objects.
            </summary>
    </member>
    <member name="T:LinFu.AOP.Cecil.Interfaces.IModuleWeaver">
      <summary>
            Represents a class that can modify existing <see cref="T:Mono.Cecil.ModuleDefinition" /> instances.
            </summary>
    </member>
    <member name="T:LinFu.AOP.Cecil.Interfaces.INewObjectWeaver">
      <summary>
            Represents a type that can emit IL that instantiates an object
            within a given method.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.Interfaces.INewObjectWeaver.AddLocals(Mono.Cecil.MethodDefinition)">
      <summary>
            Adds local variables to the <paramref name="hostMethod" />.
            </summary>
      <param name="hostMethod">The target method.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.Interfaces.INewObjectWeaver.ShouldIntercept(Mono.Cecil.MethodReference,Mono.Cecil.TypeReference,Mono.Cecil.MethodReference)">
      <summary>
            Determines whether or not the object instantiation call to the <paramref name="constructor" />
            should be instrumented.
            </summary>
      <param name="constructor">The constructor that will be used to instantiate the target type.</param>
      <param name="concreteType">The type to be created.</param>
      <param name="hostMethod">The method that contains the instantiation request.</param>
      <returns>
        <c>true</c> if the call to the <c>new</c> operator should be intercepted; otherwise, it should return <c>false</c>.</returns>
    </member>
    <member name="M:LinFu.AOP.Cecil.Interfaces.INewObjectWeaver.EmitNewObject(Mono.Cecil.MethodDefinition,Mono.Cecil.Cil.CilWorker,Mono.Cecil.MethodReference,Mono.Cecil.TypeReference)">
      <summary>
            Emits the necessary <paramref name="IL" /> necessary to instantiate
            the <paramref name="concreteType" />.
            </summary>
      <param name="hostMethod">The method that contains the activation request.</param>
      <param name="IL">The CilWorker that will be used to replace the existing instructions in the method body.</param>
      <param name="targetConstructor">The constructor that is currently being used to instantiate the concrete type.</param>
      <param name="concreteType">The <see cref="T:System.Type" /> that describes the object type that needs to be instantiated.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.Interfaces.IPdbLoader">
      <summary>
            Represents a type that can load PDB files from disk.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.Interfaces.IPdbLoader.LoadAssembly(System.Byte[],System.Byte[])">
      <summary>
            Loads an assembly into memory.
            </summary>
      <param name="assemblyArray">The bytes that represent the target assembly.</param>
      <param name="pdbBytes">The bytes that represent the PDB file.</param>
      <returns>A <see cref="T:System.Reflection.Assembly" /> that represents the loaded assembly.</returns>
    </member>
    <member name="M:LinFu.AOP.Cecil.Interfaces.IPdbLoader.LoadSymbols(Mono.Cecil.AssemblyDefinition)">
      <summary>
            Loads the debug symbols from the target <paramref name="assembly" />.
            </summary>
      <param name="assembly">The assembly that contains the symbols to be loaded.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.Interfaces.IPdbLoader.SaveSymbols(Mono.Cecil.AssemblyDefinition)">
      <summary>
            Saves the debug symbols for the  target<paramref name="assembly" />.
            </summary>
      <param name="targetAssembly">The assembly that contains the symbols to be saved.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.InvocationInfo">
      <summary>
            Represents the information associated with 
            a single method call.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.InvocationInfo.#ctor(System.Object,System.Reflection.MethodBase,System.Diagnostics.StackTrace,System.Type[],System.Type[],System.Type,System.Object[])">
      <summary>
            Initializes the <see cref="T:LinFu.AOP.Cecil.InvocationInfo" /> instance.
            </summary>
      <param name="target">The target instance currently being called.</param>
      <param name="targetMethod">The method currently being called.</param>
      <param name="stackTrace"> The <see cref="P:LinFu.AOP.Cecil.InvocationInfo.StackTrace" /> associated with the method call when the call was made.</param>
      <param name="parameterTypes">The parameter types for the current target method.</param>
      <param name="typeArguments">
            If the <see cref="P:LinFu.AOP.Cecil.InvocationInfo.TargetMethod" /> method is a generic method, 
            this will hold the generic type arguments used to construct the
            method.
            </param>
      <param name="returnType">The return type of the target method.</param>
      <param name="arguments">The arguments used in the method call.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.InvocationInfo.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="P:LinFu.AOP.Cecil.InvocationInfo.Target">
      <summary>
            The target instance currently being called.
            </summary>
      <remarks>This typically is a reference to a proxy object.</remarks>
    </member>
    <member name="P:LinFu.AOP.Cecil.InvocationInfo.TargetMethod">
      <summary>
            The method currently being called.
            </summary>
    </member>
    <member name="P:LinFu.AOP.Cecil.InvocationInfo.StackTrace">
      <summary>
            The <see cref="P:LinFu.AOP.Cecil.InvocationInfo.StackTrace" /> associated
            with the method call when the call was made.
            </summary>
    </member>
    <member name="P:LinFu.AOP.Cecil.InvocationInfo.CallingMethod">
      <summary>
            This is the actual calling method that invoked the <see cref="P:LinFu.AOP.Cecil.InvocationInfo.TargetMethod" />.
            </summary>
    </member>
    <member name="P:LinFu.AOP.Cecil.InvocationInfo.ReturnType">
      <summary>
            The return type of the <see cref="P:LinFu.AOP.Cecil.InvocationInfo.TargetMethod" />.
            </summary>
    </member>
    <member name="P:LinFu.AOP.Cecil.InvocationInfo.ParameterTypes">
      <summary>
            The parameter types for the current target method.
            </summary>
      <remarks>
        <para>
            This could be very useful in cases where the actual target method
            is based on a generic type definition. In such cases, 
            the <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> instance needs to be able
            to describe the actual parameter types being used by the
            current generic type instantiation. This property helps
            users determine which parameter types are actually being used
            at the time of the method call.
            </para>
      </remarks>
    </member>
    <member name="P:LinFu.AOP.Cecil.InvocationInfo.TypeArguments">
      <summary>
            If the <see cref="P:LinFu.AOP.Cecil.InvocationInfo.TargetMethod" /> method is a generic method, 
            this will hold the generic type arguments used to construct the
            method.
            </summary>
    </member>
    <member name="P:LinFu.AOP.Cecil.InvocationInfo.Arguments">
      <summary>
            The arguments used in the method call.
            </summary>
    </member>
    <member name="T:LinFu.AOP.Cecil.InvocationInfoEmitter">
      <summary>
            Represents the default implementation for the
            <see cref="T:LinFu.AOP.Cecil.Interfaces.IEmitInvocationInfo" /> class.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.InvocationInfoEmitter.#ctor">
      <summary>
            Initializes a new instance of the InvocationInfoEmitter class.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.InvocationInfoEmitter.#ctor(System.Boolean)">
      <summary>
            Initializes a new instance of the InvocationInfoEmitter class.
            </summary>
      <param name="pushStackTrace">Determines whether or not stack trace information will be available at runtime.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.InvocationInfoEmitter.Emit(Mono.Cecil.MethodDefinition,Mono.Cecil.MethodReference,Mono.Cecil.Cil.VariableDefinition)">
      <summary>
            Emits the IL to save information about
            the method currently being executed.
            </summary>
      <seealso cref="T:LinFu.AOP.Interfaces.IInvocationInfo" />
      <param name="targetMethod">The target method currently being executed.</param>
      <param name="interceptedMethod">The method that will be passed to the <paramref name="invocationInfo" /> as the currently executing method.</param>
      <param name="invocationInfo">The local variable that will store the resulting <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> instance.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.Extensions.InvocationInfoExtensions">
      <summary>
            Adds helper methods classes that implement the <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> 
            interface.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.InvocationInfoExtensions.Emit(LinFu.AOP.Cecil.Interfaces.IEmitInvocationInfo,System.Reflection.MethodInfo,Mono.Cecil.MethodDefinition,Mono.Cecil.Cil.VariableDefinition)">
      <summary>
            Emits the IL instructions that will store information about the method <paramref name="targetMethod">currently being executed</paramref>
            and stores the results into the <paramref name="invocationInfo">variable.</paramref></summary>
      <param name="emitter">The <see cref="T:LinFu.AOP.Cecil.Interfaces.IEmitInvocationInfo" /> instance.</param>
      <param name="method">The method whose implementation will be intercepted.</param>
      <param name="targetMethod">The actual method that will contain the resulting instructions.</param>
      <param name="invocationInfo">The <see cref="T:Mono.Cecil.Cil.VariableDefinition">local variable</see> that will store the current <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> instance.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.InvocationInfoExtensions.Proceed(LinFu.AOP.Interfaces.IInvocationInfo)">
      <summary>
            Invokes the currently executing method by using the <see cref="P:LinFu.AOP.Interfaces.IInvocationInfo.Target" />
            as the target instance, the <see cref="P:LinFu.AOP.Interfaces.IInvocationInfo.TargetMethod" /> as the method, 
            and uses the <see cref="P:LinFu.AOP.Interfaces.IInvocationInfo.Arguments" /> for the method
            arguments.
            </summary>
      <param name="info">The <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> instance that contains information about the method call itself.</param>
      <returns>The return value of the method call.</returns>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.InvocationInfoExtensions.Proceed(LinFu.AOP.Interfaces.IInvocationInfo,System.Object)">
      <summary>
            Invokes the currently executing method by using the <paramref name="target" />
            as the target instance, the <see cref="P:LinFu.AOP.Interfaces.IInvocationInfo.TargetMethod" /> as the method, 
            and uses the <see cref="P:LinFu.AOP.Interfaces.IInvocationInfo.Arguments" /> for the method
            arguments.
            </summary>
      <param name="info">The <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> instance that contains information about the method call itself.</param>
      <param name="target">The target instance that will handle the method call.</param>
      <returns>The return value of the method call.</returns>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.InvocationInfoExtensions.Proceed(LinFu.AOP.Interfaces.IInvocationInfo,System.Object,System.Object[])">
      <summary>
            Invokes the currently executing method by using the <paramref name="target" />
            as the target instance, the <see cref="P:LinFu.AOP.Interfaces.IInvocationInfo.TargetMethod" /> as the method, 
            and uses the <paramref name="arguments" /> for the method
            arguments.
            </summary>
      <param name="info">The <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> instance that contains information about the method call itself.</param>
      <param name="target">The target instance that will handle the method call.</param>
      <param name="arguments">The arguments that will be used for the actual method call.</param>
      <returns>The return value of the method call.</returns>
    </member>
    <member name="T:LinFu.AOP.Cecil.Interfaces.IVerifier">
      <summary>
            A class that verifies a given <see cref="T:Mono.Cecil.AssemblyDefinition" /> instance.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.Interfaces.IVerifier.Verify(Mono.Cecil.AssemblyDefinition)">
      <summary>
            Verifies the given <paramref name="assembly" /> instance.
            </summary>
      <param name="assembly">The assembly definition that needs to be verified.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.InvokeMethodReplacement">
      <summary>
            Represents a class that emits the instructions that call the method replacement instead of the original method body.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.InvokeMethodReplacement.#ctor(Mono.Cecil.Cil.Instruction,Mono.Cecil.Cil.VariableDefinition,Mono.Cecil.Cil.VariableDefinition,Mono.Cecil.Cil.VariableDefinition)">
      <summary>
            Initializes a new instance of the <see cref="T:LinFu.AOP.Cecil.InvokeMethodReplacement" /> class.
            </summary>
      <param name="executeOriginalInstructions">The instruction label that will be used if the original instructions should be executed.</param>
      <param name="methodReplacementProvider">The variable that contains the <see cref="T:LinFu.AOP.Interfaces.IMethodReplacementProvider" /> instance.</param>
      <param name="classMethodReplacementProvider">The variable that contains the class-level <see cref="T:LinFu.AOP.Interfaces.IMethodReplacementProvider" /> instance.</param>
      <param name="invocationInfo">The variable that contains the <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> instance.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.InvokeMethodReplacement.Emit(Mono.Cecil.Cil.CilWorker)">
      <summary>
            Emits the instructions that call the method replacement instead of the original method body.
            </summary>
      <param name="IL">The <see cref="T:Mono.Cecil.Cil.CilWorker" /> that points to the current method body.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.ISurroundMethodBody">
      <summary>
            Represents a type that can add a prolog and epilog instructions to a particular method body.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.ISurroundMethodBody.AddProlog(Mono.Cecil.Cil.CilWorker)">
      <summary>
            Adds a prolog to the given method body.
            </summary>
      <param name="IL">The <see cref="T:Mono.Cecil.Cil.CilWorker" /> that points to the given method body.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.ISurroundMethodBody.AddEpilog(Mono.Cecil.Cil.CilWorker)">
      <summary>
            Adds an epilog to the given method body.
            </summary>
      <param name="IL">The <see cref="T:Mono.Cecil.Cil.CilWorker" /> that points to the given method body.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.ITypeFilter">
      <summary>
            Represents a type that determines whether or not a particular type should be modified.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.ITypeFilter.ShouldWeave(Mono.Cecil.TypeReference)">
      <summary>
            Determines whether or not a type should be modified.
            </summary>
      <param name="type">The target type.</param>
      <returns>Returns <c>true</c> if the type should be modified.</returns>
    </member>
    <member name="T:LinFu.AOP.Cecil.Loaders.AssemblyLoaderWithPdbSupport">
      <summary>
            Represents an <see cref="P:LinFu.AOP.Cecil.Loaders.AssemblyLoaderWithPdbSupport.AssemblyLoader" /> class that adds support for loading PDB files into memory every time an assembly is loaded into memory.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.Loaders.AssemblyLoaderWithPdbSupport.#ctor(LinFu.Reflection.IAssemblyLoader)">
      <summary>
            Initializes a new instance of the AssemblyLoaderWithPdbSupport class.
            </summary>
      <param name="loader">The <see cref="T:LinFu.Reflection.IAssemblyLoader" /> that will perform the actual load operation.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.Loaders.AssemblyLoaderWithPdbSupport.Load(System.String)">
      <summary>
            Loads the target assembly (and its corresponding PDB file) into memory.
            </summary>
      <param name="assemblyFile">The full path and filename of the assembly to load.</param>
      <returns>A loaded <see cref="T:System.Reflection.Assembly" /> instance.</returns>
    </member>
    <member name="M:LinFu.AOP.Cecil.Loaders.AssemblyLoaderWithPdbSupport.RemoveTemporaryFiles(System.String,System.String,System.String,System.String)">
      <summary>
            Removes the temporary backup files that were created during the load operation.
            </summary>
      <param name="assemblyFile">The full path and location of the original assembly file.</param>
      <param name="pdbFile">The full path and location of the original PDB file.</param>
      <param name="pdbTempFileName">The full path and location of the temporary pdb file.</param>
      <param name="assemblyBackupFile">The full path and location of the backup assembly file.</param>
    </member>
    <member name="P:LinFu.AOP.Cecil.Loaders.AssemblyLoaderWithPdbSupport.AssemblyLoader">
      <summary>
            Gets or sets the value indicating the <see cref="T:LinFu.Reflection.IAssemblyLoader" /> instance that will be used to load assemblies into memory.
            </summary>
    </member>
    <member name="T:LinFu.AOP.Cecil.Loaders.JITWeaver">
      <summary>
            Represents a loader that modifies a given assembly prior to being loaded from disk.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.Loaders.JITWeaver.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:LinFu.AOP.Cecil.Loaders.JITWeaver" /> class.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.Loaders.JITWeaver.#ctor(LinFu.AOP.Cecil.Interfaces.IPdbLoader)">
      <summary>
            Initializes a new instance of the <see cref="T:LinFu.AOP.Cecil.Loaders.JITWeaver" /> class.
            </summary>
      <param name="pdbLoader">The loader that will be responsible for loading the program debugging information into memory.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.Loaders.JITWeaver.Load(System.String)">
      <summary>
            Modifies a given assembly prior to being loaded from disk.
            </summary>
      <param name="assemblyFile">The filename of the target assembly.</param>
      <returns>A valid assembly.</returns>
    </member>
    <member name="P:LinFu.AOP.Cecil.Loaders.JITWeaver.PdbLoader">
      <summary>
            Gets or sets the value indicating the <see cref="T:LinFu.AOP.Cecil.Interfaces.IPdbLoader" /> that will be used to load debug symbols into memory.
            </summary>
    </member>
    <member name="P:LinFu.AOP.Cecil.Loaders.JITWeaver.AssemblyWeavers">
      <summary>
            Gets the value indicating the list of <see cref="T:System.Action`1" /> delegates
            that will be used to modify the assemblies loaded into memory.
            </summary>
    </member>
    <member name="P:LinFu.AOP.Cecil.Loaders.JITWeaver.AssemblyVerifier">
      <summary>
            Gets or sets the value indicating the <see cref="T:LinFu.AOP.Cecil.Interfaces.IVerifier" />
            instance that will be used to ensure that the modified assemblies are valid.
            </summary>
    </member>
    <member name="T:LinFu.AOP.Cecil.Loaders.PdbLoader">
      <summary>
            Represents the default implementation of the <see cref="T:LinFu.AOP.Cecil.Interfaces.IPdbLoader" /> interface.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.Loaders.PdbLoader.LoadAssembly(System.Byte[],System.Byte[])">
      <summary>
            Loads an assembly into memory.
            </summary>
      <param name="assemblyArray">The bytes that represent the target assembly.</param>
      <param name="pdbBytes">The bytes that represent the PDB file.</param>
      <returns>A <see cref="T:System.Reflection.Assembly" /> that represents the loaded assembly.</returns>
    </member>
    <member name="M:LinFu.AOP.Cecil.Loaders.PdbLoader.LoadSymbols(Mono.Cecil.AssemblyDefinition)">
      <summary>
            Loads the debug symbols from the target <paramref name="assembly" />.
            </summary>
      <param name="assembly">The assembly that contains the symbols to be loaded.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.Loaders.PdbLoader.SaveSymbols(Mono.Cecil.AssemblyDefinition)">
      <summary>
            Saves the debug symbols for the  target<paramref name="assembly" />.
            </summary>
      <param name="targetAssembly">The assembly that contains the symbols to be saved.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.MethodBodyRewriterParameters">
      <summary>
            Represents the parameters used to add interception to a given method body.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.MethodBodyRewriterParameters.#ctor(Mono.Cecil.Cil.CilWorker,System.Collections.Generic.IEnumerable{Mono.Cecil.Cil.Instruction},Mono.Cecil.Cil.VariableDefinition,Mono.Cecil.Cil.VariableDefinition,Mono.Cecil.Cil.VariableDefinition,Mono.Cecil.Cil.VariableDefinition,Mono.Cecil.Cil.VariableDefinition,Mono.Cecil.Cil.VariableDefinition,System.Func{Mono.Cecil.ModuleDefinition,Mono.Cecil.MethodReference},System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:LinFu.AOP.Cecil.MethodBodyRewriterParameters" /> class.
            </summary>
      <param name="IL">The CilWorker that is responsible for the current method body.</param>
      <param name="oldInstructions">The value indicating the list of old instructions in the current method body.</param>
      <param name="interceptionDisabled">The value that determines whether or not interception is disabled.</param>
      <param name="invocationInfo">The local variable that will store the <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> instance.</param>
      <param name="returnValue">The value indicating the local variable that will store the return value.</param>
      <param name="methodReplacementProvider">The <see cref="T:LinFu.AOP.Interfaces.IMethodReplacementProvider" /> instance.</param>
      <param name="aroundInvokeProvider">The <see cref="T:LinFu.AOP.Interfaces.IAroundInvokeProvider" /> instance.</param>
      <param name="classMethodReplacementProvider">The class-level<see cref="T:LinFu.AOP.Interfaces.IMethodReplacementProvider" /> instance.</param>
      <param name="getMethodReplacementProviderMethod">The functor that resolves the GetMethodReplacementProvider method.</param>
      <param name="registryType">The interception registry type that will be responsible for handling class-level interception events.</param>
    </member>
    <member name="P:LinFu.AOP.Cecil.MethodBodyRewriterParameters.OldInstructions">
      <summary>
            Gets the value indicating the list of old instructions in the current method body.
            </summary>
      <value>The value indicating the list of old instructions in the current method body.</value>
    </member>
    <member name="P:LinFu.AOP.Cecil.MethodBodyRewriterParameters.ClassMethodReplacementProvider">
      <summary>
            Gets the value indicating the class-level<see cref="T:LinFu.AOP.Interfaces.IMethodReplacementProvider" /> instance.
            </summary>
      <value>The class-level<see cref="T:LinFu.AOP.Interfaces.IMethodReplacementProvider" /> instance.</value>
    </member>
    <member name="P:LinFu.AOP.Cecil.MethodBodyRewriterParameters.AroundInvokeProvider">
      <summary>
            Gets the value indicating the local variable used to store the <see cref="T:LinFu.AOP.Interfaces.IAroundInvokeProvider" /> instance.
            </summary>
      <value>The <see cref="T:LinFu.AOP.Interfaces.IAroundInvokeProvider" /> instance.</value>
    </member>
    <member name="P:LinFu.AOP.Cecil.MethodBodyRewriterParameters.MethodReplacementProvider">
      <summary>
            Gets the value indicating the local variable used to store the <see cref="T:LinFu.AOP.Interfaces.IMethodReplacementProvider" /> instance.
            </summary>
      <value>The <see cref="T:LinFu.AOP.Interfaces.IMethodReplacementProvider" /> instance.</value>
    </member>
    <member name="P:LinFu.AOP.Cecil.MethodBodyRewriterParameters.TargetMethod">
      <summary>
            Gets the value indicating the TargetMethod to be modified.
            </summary>
      <value>The method to be modified.</value>
    </member>
    <member name="P:LinFu.AOP.Cecil.MethodBodyRewriterParameters.InterceptionDisabled">
      <summary>
            Gets the value indicating the local variable that will store the value that determines whether or not
            interception is disabled.
            </summary>
      <value>The value that determines whether or not interception is disabled.</value>
    </member>
    <member name="P:LinFu.AOP.Cecil.MethodBodyRewriterParameters.InvocationInfo">
      <summary>
            Gets the value indicating the local variable that will store the <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> instance.
            </summary>
      <value>The local variable that will store the <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> instance.</value>
    </member>
    <member name="P:LinFu.AOP.Cecil.MethodBodyRewriterParameters.ReturnValue">
      <summary>
            Gets the value indicating the local variable that will store the return value.
            </summary>
      <value>The value indicating the local variable that will store the return value.</value>
    </member>
    <member name="P:LinFu.AOP.Cecil.MethodBodyRewriterParameters.RegistryType">
      <summary>
            Gets the value indicating the interception registry type that will be responsible for handling class-level interception events.
            </summary>
      <value>The interception registry type that will be responsible for handling class-level interception events.</value>
    </member>
    <member name="P:LinFu.AOP.Cecil.MethodBodyRewriterParameters.GetMethodReplacementProviderMethod">
      <summary>
            Gets the value indicating the functor that resolves the GetMethodReplacementProvider method.
            </summary>
      <value>The functor that resolves the GetMethodReplacementProvider method.</value>
    </member>
    <member name="T:LinFu.AOP.Cecil.Extensions.MethodDefinitionExtensions">
      <summary>
            Represents an extension class that adds helper methods to the <see cref="T:Mono.Cecil.MethodDefinition" /> type.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.MethodDefinitionExtensions.AddLocal(Mono.Cecil.MethodDefinition,System.Type)">
      <summary>
            Adds a local variable to the given method.
            </summary>
      <param name="methodDef">The target method.</param>
      <param name="localType">The variable type.</param>
      <returns>A local variable definition.</returns>
    </member>
    <member name="T:LinFu.AOP.Cecil.Extensions.MethodBodyInterceptionExtensions">
      <summary>
            Represents an extension class that adds method body interception support to the Mono.Cecil object model.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.MethodBodyInterceptionExtensions.InterceptAllMethodBodies(Mono.Cecil.IReflectionStructureVisitable)">
      <summary>
            Intercepts all method bodies on the target item.
            </summary>
      <param name="target">The target to be modified.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.MethodBodyInterceptionExtensions.InterceptAllMethodBodies(Mono.Cecil.IReflectionVisitable)">
      <summary>
            Intercepts all method bodies on the target item.
            </summary>
      <param name="target">The target to be modified.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.MethodBodyInterceptionExtensions.InterceptMethodBody(Mono.Cecil.IReflectionVisitable,LinFu.AOP.Cecil.Interfaces.IMethodFilter)">
      <summary>
            Intercepts all method bodies on the target item.
            </summary>
      <param name="target">The target to be modified.</param>
      <param name="methodFilter">The method filter that will determine the methods that will be modified.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.MethodBodyInterceptionExtensions.InterceptMethodBody(Mono.Cecil.IReflectionStructureVisitable,LinFu.AOP.Cecil.Interfaces.IMethodFilter)">
      <summary>
            Intercepts all method bodies on the target item.
            </summary>
      <param name="target">The target to be modified.</param>
      <param name="methodFilter">The method filter that will determine the methods that will be modified.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.MethodBodyInterceptionExtensions.InterceptMethodBody(Mono.Cecil.IReflectionStructureVisitable,System.Func{Mono.Cecil.MethodReference,System.Boolean})">
      <summary>
            Intercepts all method bodies on the target item.
            </summary>
      <param name="target">The target to be modified.</param>
      <param name="methodFilter">The method filter that will determine the methods that will be modified.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.MethodBodyInterceptionExtensions.InterceptMethodBody(Mono.Cecil.IReflectionVisitable,System.Func{Mono.Cecil.MethodReference,System.Boolean})">
      <summary>
            Intercepts all method bodies on the target item.
            </summary>
      <param name="target">The target to be modified.</param>
      <param name="methodFilter">The method filter that will determine the methods that will be modified.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.Extensions.MethodCallInterceptionExtensions">
      <summary>
            Represents an extension class that adds method call interception support to the Mono.Cecil object model.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.MethodCallInterceptionExtensions.InterceptAllMethodCalls(Mono.Cecil.IReflectionStructureVisitable)">
      <summary>
            Modifies the current <paramref name="target" /> to support third-party method call interception for all method calls made inside the target.
            </summary>
      <param name="target">The target object.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.MethodCallInterceptionExtensions.InterceptAllMethodCalls(Mono.Cecil.IReflectionVisitable)">
      <summary>
            Modifies the current <paramref name="target" /> to support third-party method call interception for all method calls made inside the target.
            </summary>
      <param name="target">The target object.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.MethodCallInterceptionExtensions.InterceptMethodCalls(Mono.Cecil.IReflectionStructureVisitable,System.Func{Mono.Cecil.TypeReference,System.Boolean})">
      <summary>
            Modifies the current <paramref name="target" /> to support third-party method call interception for all method calls made inside the target.
            </summary>
      <param name="target">The target object.</param>
      <param name="typeFilter">The type filter that determines which types will be modified for interception.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.MethodCallInterceptionExtensions.InterceptMethodCalls(Mono.Cecil.IReflectionVisitable,System.Func{Mono.Cecil.TypeReference,System.Boolean})">
      <summary>
            Modifies the current <paramref name="target" /> to support third-party method call interception for all method calls made inside the target.
            </summary>
      <param name="target">The target object.</param>
      <param name="typeFilter">The type filter that determines the types that will be modified.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.MethodCallInterceptionExtensions.InterceptMethodCalls(Mono.Cecil.IReflectionVisitable,LinFu.AOP.Cecil.Interfaces.IMethodCallFilter,LinFu.AOP.Cecil.Interfaces.IMethodFilter)">
      <summary>
            Modifies the current <paramref name="target" /> to support third-party method call interception for all method calls made inside the target.
            </summary>
      <param name="target">The target object.</param>
      <param name="methodCallFilter">The <see cref="T:LinFu.AOP.Cecil.Interfaces.IMethodCallFilter" /> instance that determines the method calls that will be intercepted.</param>
      <param name="hostMethodFilter">The <see cref="T:LinFu.AOP.Cecil.Interfaces.IMethodFilter" /> instance that determines the host method calls that will be modified</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.MethodCallInterceptionExtensions.InterceptMethodCalls(Mono.Cecil.IReflectionStructureVisitable,LinFu.AOP.Cecil.Interfaces.IMethodCallFilter,LinFu.AOP.Cecil.Interfaces.IMethodFilter)">
      <summary>
            Modifies the current <paramref name="target" /> to support third-party method call interception for all method calls made inside the target.
            </summary>
      <param name="target">The target object.</param>
      <param name="methodCallFilter">The <see cref="T:LinFu.AOP.Cecil.Interfaces.IMethodCallFilter" /> instance that determines the method calls that will be intercepted.</param>
      <param name="hostMethodFilter">The <see cref="T:LinFu.AOP.Cecil.Interfaces.IMethodFilter" /> instance that determines the host method calls that will be modified</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.MethodCallInterceptionExtensions.InterceptMethodCalls(Mono.Cecil.IReflectionStructureVisitable,System.Func{Mono.Cecil.TypeReference,System.Boolean},System.Func{Mono.Cecil.MethodReference,System.Boolean},System.Func{Mono.Cecil.MethodReference,System.Boolean})">
      <summary>
            Modifies the current <paramref name="target" /> to support third-party method call interception.
            </summary>
      <param name="target">The target object.</param>
      <param name="typeFilter">The filter that will determine the target types that will be modified.</param>
      <param name="hostMethodFilter">The filter that will determine the methods that will be modified on the target type.</param>
      <param name="methodCallFilter">The filter that will determine which third-party methods will be intercepted on the target type.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.MethodCallInterceptionExtensions.InterceptMethodCalls(Mono.Cecil.IReflectionVisitable,System.Func{Mono.Cecil.TypeReference,System.Boolean},System.Func{Mono.Cecil.MethodReference,System.Boolean},System.Func{Mono.Cecil.MethodReference,System.Boolean})">
      <summary>
            Modifies the current <paramref name="target" /> to support third-party method call interception.
            </summary>
      <param name="target">The target object.</param>
      <param name="typeFilter">The filter that will determine the target types that will be modified.</param>
      <param name="hostMethodFilter">The filter that will determine the methods that will be modified on the target type.</param>
      <param name="methodCallFilter">The filter that will determine which third-party methods will be intercepted on the target type.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.MethodRewriter">
      <summary>
            Provides the basic functionality for the <see cref="T:LinFu.AOP.Cecil.Interfaces.IMethodRewriter" /> interface.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.MethodRewriter.#ctor">
      <summary>
            Initializes a new instance of the MethodRewriter class.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.MethodRewriter.Rewrite(Mono.Cecil.MethodDefinition,Mono.Cecil.Cil.CilWorker,System.Collections.Generic.IEnumerable{Mono.Cecil.Cil.Instruction})">
      <summary>
            Rewrites a target method using the given CilWorker.
            </summary>
      <param name="method">The target method.</param>
      <param name="IL">The CilWorker that will be used to rewrite the target method.</param>
      <param name="oldInstructions">The original instructions from the target method body.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.MethodRewriter.AddAdditionalMembers(Mono.Cecil.TypeDefinition)">
      <summary>
            Adds additional members to the host type.
            </summary>
      <param name="host">The host type.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.MethodRewriter.ImportReferences(Mono.Cecil.ModuleDefinition)">
      <summary>
            Adds additional references to the target module.
            </summary>
      <param name="module">The host module.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.MethodRewriter.AddLocals(Mono.Cecil.MethodDefinition)">
      <summary>
            Adds local variables to the <paramref name="hostMethod" />.
            </summary>
      <param name="hostMethod">The target method.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.MethodRewriter.ShouldReplace(Mono.Cecil.Cil.Instruction,Mono.Cecil.MethodDefinition)">
      <summary>
            Determines whether or not the method rewriter should replace the <paramref name="oldInstruction" />.
            </summary>
      <param name="oldInstruction">The instruction that is currently being evaluated.</param>
      <param name="hostMethod">The method that hosts the current instruction.</param>
      <returns>
        <c>true</c> if the method should be replaced; otherwise, it should return <c>false</c>.</returns>
    </member>
    <member name="M:LinFu.AOP.Cecil.MethodRewriter.Replace(Mono.Cecil.Cil.Instruction,Mono.Cecil.MethodDefinition,Mono.Cecil.Cil.CilWorker)">
      <summary>
            Replaces the <paramref name="oldInstruction" /> with a new set of <paramref name="IL" /> instructions..
            </summary>
      <param name="oldInstruction">The instruction currently being evaluated.</param>
      <param name="hostMethod">The method that contains the target instruction.</param>
      <param name="IL">The CilWorker for the target method body.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.Extensions.MethodRewriterExtensions">
      <summary>
            A helper class that extends Cecil to support the <see cref="T:LinFu.AOP.Cecil.Interfaces.IMethodRewriter" /> interface.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.MethodRewriterExtensions.WeaveWith(Mono.Cecil.IReflectionStructureVisitable,LinFu.AOP.Cecil.Interfaces.IMethodRewriter,System.Func{Mono.Cecil.MethodReference,System.Boolean})">
      <summary>
            Transforms the methods in the <paramref name="target" /> using the given method rewriter.
            </summary>
      <param name="target">The transformation target.</param>
      <param name="rewriter">The method rewriter.</param>
      <param name="filter">The method filter that determines which methods will be rewritten.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.MethodRewriterExtensions.WeaveWith(Mono.Cecil.IReflectionVisitable,LinFu.AOP.Cecil.Interfaces.IMethodRewriter,System.Func{Mono.Cecil.MethodReference,System.Boolean})">
      <summary>
            Transforms the methods in the <paramref name="target" /> using the given method rewriter.
            </summary>
      <param name="target">The transformation target.</param>
      <param name="rewriter">The method rewriter.</param>
      <param name="filter">The method filter that determines which methods will be rewritten.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.MethodWeaver">
      <summary>
            Represents the default implementation of the <see cref="T:LinFu.AOP.Cecil.Interfaces.IMethodWeaver" /> interface.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.MethodWeaver.#ctor(LinFu.AOP.Cecil.Interfaces.IMethodRewriter,System.Func{Mono.Cecil.MethodReference,System.Boolean})">
      <summary>
            Initializes a new instance of the MethodWeaver class.
            </summary>
      <param name="rewriter">The <see cref="T:LinFu.AOP.Cecil.Interfaces.IMethodRewriter" /> instance that will modify the existing method.</param>
      <param name="filter">The filter that determines which methods should be modified.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.MethodWeaver.#ctor(LinFu.AOP.Cecil.Interfaces.IMethodRewriter,LinFu.AOP.Cecil.Interfaces.IInstructionProvider,System.Func{Mono.Cecil.MethodReference,System.Boolean})">
      <summary>
            Initializes a new instance of the MethodWeaver class.
            </summary>
      <param name="rewriter">The <see cref="T:LinFu.AOP.Cecil.Interfaces.IMethodRewriter" /> instance that will modify the existing method.</param>
      <param name="instructionProvider">The provider that will obtain the original instructions for the target method.</param>
      <param name="filter">The filter that determines which methods should be modified.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.MethodWeaver.ShouldWeave(Mono.Cecil.MethodDefinition)">
      <summary>
            Determines whether or not a method should be modified.
            </summary>
      <param name="item">The target method.</param>
      <returns>
        <c>true</c> if the method should be modified; otherwise, it returns <c>false</c>.</returns>
    </member>
    <member name="M:LinFu.AOP.Cecil.MethodWeaver.Weave(Mono.Cecil.MethodDefinition)">
      <summary>
            Modifies a target method.
            </summary>
      <param name="method">The target method.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.MethodWeaver.Rewrite(Mono.Cecil.MethodDefinition)">
      <summary>
            Rewrites an existing method.
            </summary>
      <param name="method">The method that needs to be modified.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.MethodWeaver.AddAdditionalMembers(Mono.Cecil.TypeDefinition)">
      <summary>
            Adds additional members to the target type.
            </summary>
      <param name="host">The target type to be modified.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.MethodWeaver.ImportReferences(Mono.Cecil.ModuleDefinition)">
      <summary>
            Imports additional references into the given module.
            </summary>
      <param name="module">The module that will store the additional references.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.MethodWeaverVisitor">
      <summary>
            Represents a visitor class that can iterate over <see cref="T:Mono.Cecil.MethodDefinition" />
            instances.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.MethodWeaverVisitor.#ctor(LinFu.AOP.Cecil.Interfaces.IMethodWeaver)">
      <summary>
            Initializes a new instance of the MethodWeaverVisitor class.
            </summary>
      <param name="methodWeaver">The <see cref="T:LinFu.AOP.Cecil.Interfaces.IMethodWeaver" /> that will be used to modify a given type.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.MethodWeaverVisitor.VisitConstructor(Mono.Cecil.MethodDefinition)">
      <summary>
            Visits a <see cref="T:Mono.Cecil.MethodDefinition" /> instance.
            </summary>
      <param name="ctor">The <see cref="T:Mono.Cecil.MethodDefinition" /> instance that will be modified.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.MethodWeaverVisitor.VisitMethodDefinition(Mono.Cecil.MethodDefinition)">
      <summary>
            Visits a <see cref="T:Mono.Cecil.MethodDefinition" /> instance.
            </summary>
      <param name="method">The <see cref="T:Mono.Cecil.MethodDefinition" /> instance that will be modified.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.MethodWeaverVisitor.VisitModuleDefinition(Mono.Cecil.ModuleDefinition)">
      <summary>
            Visits a <see cref="T:Mono.Cecil.ModuleDefinition" /> instance.
            </summary>
      <param name="module">A <see cref="T:Mono.Cecil.ModuleDefinition" /> object.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.MethodWeaverVisitor.VisitTypeDefinition(Mono.Cecil.TypeDefinition)">
      <summary>
            Visits a <see cref="T:Mono.Cecil.TypeDefinition" /> instance.
            </summary>
      <param name="type">A <see cref="T:Mono.Cecil.TypeDefinition" /> object.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.Extensions.NewOperatorInterceptionExtensions">
      <summary>
            An extension class that adds support for intercepting the 'new' operator with LinFu.AOP.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.NewOperatorInterceptionExtensions.InterceptAllNewInstances(Mono.Cecil.IReflectionStructureVisitable)">
      <summary>
            Modifies a <paramref name="target" /> to support intercepting all calls to the 'new' operator.
            </summary>
      <param name="target">The assembly to be modified.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.NewOperatorInterceptionExtensions.InterceptAllNewInstances(Mono.Cecil.IReflectionVisitable)">
      <summary>
            Modifies a <paramref name="target" /> to support intercepting all calls to the 'new' operator.
            </summary>
      <param name="target">The assembly to be modified.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.NewOperatorInterceptionExtensions.InterceptNewInstances(Mono.Cecil.IReflectionVisitable,System.Func{Mono.Cecil.TypeReference,System.Boolean},System.Func{Mono.Cecil.MethodReference,System.Boolean})">
      <summary>
            Modifies a <paramref name="target" /> to support intercepting calls to the 'new' operator.
            </summary>
      <param name="target">The assembly to be modified.</param>
      <param name="typeFilter">The functor that determines which type instantiations should be intercepted.</param>
      <param name="methodFilter">The filter that determines which host methods will be modified</param>
      <remarks>
            The type filter determines the concrete types that should be intercepted at runtime.
            For example, the following functor code intercepts types named "Foo":
            <code>
                Func&lt;TypeReference, bool&gt; filter = 
                concreteType =&gt; concreteType.Name == "Foo";
            </code></remarks>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.NewOperatorInterceptionExtensions.InterceptNewInstances(Mono.Cecil.IReflectionStructureVisitable,System.Func{Mono.Cecil.MethodReference,Mono.Cecil.TypeReference,System.Boolean},System.Func{Mono.Cecil.MethodReference,System.Boolean})">
      <summary>
            Modifies a <paramref name="target" /> assembly to support intercepting calls to the 'new' operator.
            </summary>
      <param name="target">The assembly to be modified.</param>
      <param name="constructorFilter">The functor that determines which type instantiations should be intercepted.</param>
      <param name="methodFilter">The filter that determines which host methods will be modified</param>
      <remarks>
            The type filter determines which concrete types and constructors should be intercepted at runtime.
            For example, the following functor code intercepts types named "Foo":
            <code>
                Func&lt;MethodReference, TypeReference, bool&gt; filter = 
                (constructor, concreteType, hostMethod) =&gt; concreteType.Name == "Foo";
            </code></remarks>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.NewOperatorInterceptionExtensions.InterceptNewInstances(Mono.Cecil.IReflectionStructureVisitable,System.Func{Mono.Cecil.TypeReference,System.Boolean})">
      <summary>
            Modifies a <paramref name="target" /> assembly to support intercepting calls to the 'new' operator.
            </summary>
      <param name="target">The assembly to be modified.</param>
      <param name="typeFilter">The functor that determines which type instantiations should be intercepted.</param>
      <remarks>
            The type filter determines the concrete types that should be intercepted at runtime.
            For example, the following functor code intercepts types named "Foo":
            <code>
                Func&lt;TypeReference, bool&gt; filter = 
                concreteType =&gt; concreteType.Name == "Foo";
            </code></remarks>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.NewOperatorInterceptionExtensions.InterceptNewInstances(Mono.Cecil.IReflectionVisitable,System.Func{Mono.Cecil.TypeReference,System.Boolean})">
      <summary>
            Modifies a <paramref name="target" /> assembly to support intercepting calls to the 'new' operator.
            </summary>
      <param name="target">The assembly to be modified.</param>
      <param name="typeFilter">The functor that determines which type instantiations should be intercepted.</param>
      <remarks>
            The type filter determines the concrete types that should be intercepted at runtime.
            For example, the following functor code intercepts types named "Foo":
            <code>
                Func&lt;TypeReference, bool&gt; filter = 
                concreteType =&gt; concreteType.Name == "Foo";
            </code></remarks>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.NewOperatorInterceptionExtensions.InterceptNewInstances(Mono.Cecil.IReflectionStructureVisitable,System.Func{Mono.Cecil.TypeReference,System.Boolean},System.Func{Mono.Cecil.MethodReference,System.Boolean})">
      <summary>
            Modifies the <paramref name="target" /> to support intercepting calls to the 'new' operator.
            </summary>
      <param name="target">The item to be modified.</param>
      <param name="methodFilter">The filter that determines which host methods will be modified</param>
      <param name="typeFilter">The filter that determines which types will be modified.</param>
      <remarks>
            The type filter determines which concrete types and constructors should be intercepted at runtime.
            For example, the following functor code intercepts types named "Foo":
            <code>
                Func&lt;MethodReference, TypeReference, bool&gt; filter = 
                (constructor, concreteType, hostMethod) =&gt; concreteType.Name == "Foo";
            </code></remarks>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.NewOperatorInterceptionExtensions.InterceptNewInstances(Mono.Cecil.IReflectionVisitable,System.Func{Mono.Cecil.MethodReference,Mono.Cecil.TypeReference,System.Boolean},System.Func{Mono.Cecil.MethodReference,System.Boolean})">
      <summary>
            Modifies the <paramref name="target" /> to support intercepting calls to the 'new' operator.
            </summary>
      <param name="target">The item to be modified.</param>
      <param name="constructorFilter">The functor that determines which type instantiations should be intercepted.</param>
      <param name="methodFilter">The filter that determines which host methods will be modified</param>
      <remarks>
            The type filter determines which concrete types and constructors should be intercepted at runtime.
            For example, the following functor code intercepts types named "Foo":
            <code>
                Func&lt;MethodReference, TypeReference, bool&gt; filter = 
                (constructor, concreteType, hostMethod) =&gt; concreteType.Name == "Foo";
            </code></remarks>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.NewOperatorInterceptionExtensions.InterceptNewInstances(Mono.Cecil.IReflectionStructureVisitable,LinFu.AOP.Cecil.Interfaces.INewInstanceFilter,LinFu.AOP.Cecil.Interfaces.IMethodFilter)">
      <summary>
            Modifies the <paramref name="target" /> to support intercepting calls to the 'new' operator.
            </summary>
      <param name="target">The item to be modified.</param>
      <param name="newInstanceFilter">The filter that will determine which constructor calls should be intercepted.</param>
      <param name="methodFilter">The filter that will determine which host methods should be modified to support new instance interception.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.NewOperatorInterceptionExtensions.InterceptNewInstances(Mono.Cecil.IReflectionVisitable,LinFu.AOP.Cecil.Interfaces.INewInstanceFilter,LinFu.AOP.Cecil.Interfaces.IMethodFilter)">
      <summary>
            Modifies the <paramref name="target" /> to support intercepting calls to the 'new' operator.
            </summary>
      <param name="target">The item to be modified.</param>
      <param name="newInstanceFilter">The filter that will determine which constructor calls should be intercepted.</param>
      <param name="methodFilter">The filter that will determine which host methods should be modified to support new instance interception.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.NewOperatorInterceptionExtensions.InterceptNewInstancesWith(Mono.Cecil.IReflectionStructureVisitable,LinFu.AOP.Cecil.Interfaces.INewObjectWeaver,System.Func{Mono.Cecil.MethodReference,System.Boolean})">
      <summary>
            Modifies the methods in the given <paramref name="target" /> using the custom <see cref="T:LinFu.AOP.Cecil.Interfaces.INewObjectWeaver" /> instance.
            </summary>
      <param name="target">The host that contains the methods that will be modified.</param>
      <param name="weaver">The custom <see cref="T:LinFu.AOP.Cecil.Interfaces.INewObjectWeaver" /> that will replace all calls to the new operator with the custom code emitted by the given weaver.</param>
      <param name="filter">The method filter that will determine which methods should be modified.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.NewOperatorInterceptionExtensions.InterceptNewInstancesWith(Mono.Cecil.IReflectionVisitable,LinFu.AOP.Cecil.Interfaces.INewObjectWeaver,System.Func{Mono.Cecil.MethodReference,System.Boolean})">
      <summary>
            Modifies the methods in the given <paramref name="target" /> using the custom <see cref="T:LinFu.AOP.Cecil.Interfaces.INewObjectWeaver" /> instance.
            </summary>
      <param name="target">The host that contains the methods that will be modified.</param>
      <param name="weaver">The custom <see cref="T:LinFu.AOP.Cecil.Interfaces.INewObjectWeaver" /> that will replace all calls to the new operator with the custom code emitted by the given weaver.</param>
      <param name="filter">The method filter that will determine which methods should be modified.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.SaveReturnValue">
      <summary>
            Represents an instruction emitter that saves the return value from a given method call.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.SaveReturnValue.#ctor(Mono.Cecil.TypeReference,Mono.Cecil.Cil.VariableDefinition)">
      <summary>
            Initializes a new instance of the <see cref="T:LinFu.AOP.Cecil.SaveReturnValue" /> class.
            </summary>
      <param name="returnType">The return type.</param>
      <param name="returnValue">The return value.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.SaveReturnValue.Emit(Mono.Cecil.Cil.CilWorker)">
      <summary>
            Saves the return value from a given method call.
            </summary>
      <param name="IL">The <see cref="T:Mono.Cecil.Cil.CilWorker" /> pointing to the target method body.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.SurroundMethodBody">
      <summary>
            Represents a class that surrounds a call site with calls to an <see cref="T:LinFu.AOP.Interfaces.IAroundInvoke" /> instance.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.SurroundMethodBody.#ctor(LinFu.AOP.Cecil.IMethodBodyRewriterParameters,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:LinFu.AOP.Cecil.IMethodBodyRewriterParameters" /> class.
            </summary>
      <param name="parameters">The parameters that describe the context of the emitter call.</param>
      <param name="providerName">The name of the <see cref="T:LinFu.AOP.Interfaces.IAroundInvokeProvider" /> property.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.SurroundMethodBody.#ctor(Mono.Cecil.Cil.VariableDefinition,Mono.Cecil.Cil.VariableDefinition,Mono.Cecil.Cil.VariableDefinition,Mono.Cecil.Cil.VariableDefinition,Mono.Cecil.Cil.VariableDefinition,System.Type,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:LinFu.AOP.Cecil.IMethodBodyRewriterParameters" /> class.
            </summary>
      <param name="methodReplacementProvider">The variable that contains the <see cref="T:LinFu.AOP.Interfaces.IMethodReplacementProvider" /> instance.</param>
      <param name="aroundInvokeProvider">The variable that contains the <see cref="T:LinFu.AOP.Interfaces.IAroundInvokeProvider" /> instance</param>
      <param name="invocationInfo">The variable that contains the <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> instance.</param>
      <param name="interceptionDisabled">The variable that determines whether or not interception is disabled</param>
      <param name="returnValue">The variable that contains the method return value.</param>
      <param name="registryType">The interception registry type that will be responsible for handling class-level interception events.</param>
      <param name="providerName">The name of the <see cref="T:LinFu.AOP.Interfaces.IAroundInvokeProvider" /> property.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.SurroundMethodBody.AddProlog(Mono.Cecil.Cil.CilWorker)">
      <summary>
            Adds a prolog to the given method body.
            </summary>
      <param name="IL">The <see cref="T:Mono.Cecil.Cil.CilWorker" /> that points to the given method body.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.SurroundMethodBody.AddEpilog(Mono.Cecil.Cil.CilWorker)">
      <summary>
            Adds an epilog to the given method body.
            </summary>
      <param name="IL">The <see cref="T:Mono.Cecil.Cil.CilWorker" /> that points to the given method body.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.Extensions.TypeDefinitionExtensions">
      <summary>
            Adds helper methods to the <see cref="T:Mono.Cecil.TypeDefinition" /> class.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.Extensions.TypeDefinitionExtensions.WeaveWith(Mono.Cecil.TypeDefinition,LinFu.AOP.Cecil.Interfaces.IMethodWeaver)">
      <summary>
            Applies a <see cref="T:LinFu.AOP.Cecil.Interfaces.IMethodWeaver" /> instance to all methods
            within the given <paramref name="targetType" />.
            </summary>
      <param name="targetType">The target module.</param>
      <param name="weaver">The <see cref="T:LinFu.AOP.Cecil.Interfaces.ITypeWeaver" /> instance that will modify the methods in the given target type.</param>
    </member>
    <member name="T:LinFu.AOP.Cecil.TypeWeaverVisitor">
      <summary>
            Represents a visitor class that can iterate over <see cref="T:Mono.Cecil.TypeDefinition" />
            instances.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Cecil.TypeWeaverVisitor.#ctor(LinFu.AOP.Cecil.Interfaces.ITypeWeaver)">
      <summary>
            Initializes a new instance of the TypeWeaverVisitor class.
            </summary>
      <param name="weaver">The <see cref="T:LinFu.AOP.Cecil.Interfaces.ITypeWeaver" /> that will be used to modify a given type.</param>
    </member>
    <member name="M:LinFu.AOP.Cecil.TypeWeaverVisitor.VisitTypeDefinition(Mono.Cecil.TypeDefinition)">
      <summary>
            Visits a <see cref="T:Mono.Cecil.TypeDefinition" /> instance.
            </summary>
      <param name="type">A <see cref="T:Mono.Cecil.TypeDefinition" /> object.</param>
    </member>
    <member name="T:LinFu.AOP.Interfaces.IActivationContext">
      <summary>
            Represents a class that describes a request to instantiate a particular object type.
            </summary>
    </member>
    <member name="P:LinFu.AOP.Interfaces.IActivationContext.TargetType">
      <summary>
            Gets the value indicating the type to be instantiated.
            </summary>
    </member>
    <member name="P:LinFu.AOP.Interfaces.IActivationContext.AdditionalArguments">
      <summary>
            Gets the value indicating the arguments that will be passed to the constructor during instantiation.
            </summary>
    </member>
    <member name="T:LinFu.AOP.Interfaces.ActivationContext">
      <summary>
            Represents a class that describes a request to instantiate a particular object type.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Interfaces.ActivationContext.#ctor(System.Type,System.Object[])">
      <summary>
            Initializes the context with the given parameters.
            </summary>
      <param name="concreteType">The type to be instantiated.</param>
      <param name="additionalArguments">The additional arguments that must be passed to the constructor.</param>
    </member>
    <member name="P:LinFu.AOP.Interfaces.ActivationContext.TargetType">
      <summary>
            Gets the value indicating the type to be instantiated.
            </summary>
    </member>
    <member name="P:LinFu.AOP.Interfaces.ActivationContext.AdditionalArguments">
      <summary>
            Gets the value indicating the arguments that will be passed to the constructor during instantiation.
            </summary>
    </member>
    <member name="T:LinFu.AOP.Interfaces.ActivatorExtensions">
      <summary>
            An extension class that adds helper methods to the <see cref="T:LinFu.AOP.Interfaces.IActivator`1" /> interface.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Interfaces.ActivatorExtensions.CreateInstance(LinFu.AOP.Interfaces.IActivator{LinFu.AOP.Interfaces.IActivationContext},System.Type,System.Object[])">
      <summary>
            Instantiates the <paramref name="targetType" /> with the given <paramref name="activator" /> and <paramref name="constructorArguments" />.
            </summary>
      <param name="activator">The <see cref="T:LinFu.AOP.Interfaces.IActivator`1" /> instance that will be responsible for creating the <paramref name="targetType" />.</param>
      <param name="targetType">The type to be created.</param>
      <param name="constructorArguments">The arguments that will be passed to the constructor.</param>
      <returns>An object reference that matches the given <paramref name="targetType" />.</returns>
    </member>
    <member name="M:LinFu.AOP.Interfaces.ActivatorExtensions.CreateInstance``1(LinFu.AOP.Interfaces.IActivator{LinFu.AOP.Interfaces.IActivationContext},System.Object[])">
      <summary>
            Instantiates the <paramref name="targetType" /> with the given <paramref name="activator" /> and <paramref name="constructorArguments" />.
            </summary>
      <param name="activator">The <see cref="T:LinFu.AOP.Interfaces.IActivator`1" /> instance that will be responsible for creating the target type.</param>
      <param name="constructorArguments">The arguments that will be passed to the constructor.</param>
      <typeparam name="T">The target type that will be instantiated by the activator.</typeparam>
      <returns>An object reference that matches the given <paramref name="targetType" />.</returns>
    </member>
    <member name="T:LinFu.AOP.Interfaces.AroundInvokeMethodCallRegistry">
      <summary>
            Represents a registry class that handles all class-level method call interception operations for all modified types.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Interfaces.AroundInvokeMethodCallRegistry.GetSurroundingImplementation(LinFu.AOP.Interfaces.IInvocationInfo)">
      <summary>
            Obtains the <see cref="T:LinFu.AOP.Interfaces.IAroundInvoke" /> instance for the given <paramref name="context" />.
            </summary>
      <param name="context">The <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> instance that describes the current method call.</param>
      <returns>An <see cref="T:LinFu.AOP.Interfaces.IAroundInvoke" /> instance that will be used to wrap a method call or method body.</returns>
    </member>
    <member name="M:LinFu.AOP.Interfaces.AroundInvokeMethodCallRegistry.AddProvider(LinFu.AOP.Interfaces.IAroundInvokeProvider)">
      <summary>
            Adds an <see cref="T:LinFu.AOP.Interfaces.IAroundInvokeProvider" /> to the list of provider instances.
            </summary>
      <param name="provider">The <see cref="T:LinFu.AOP.Interfaces.IAroundInvokeProvider" /> instance.</param>
    </member>
    <member name="M:LinFu.AOP.Interfaces.AroundInvokeMethodCallRegistry.Clear">
      <summary>
            Clears the list of <see cref="T:LinFu.AOP.Interfaces.IAroundInvokeProvider" /> instances.
            </summary>
    </member>
    <member name="T:LinFu.AOP.Interfaces.AroundMethodBodyRegistry">
      <summary>
            Represents a registry class that handles all class-level interception operations for all modified types.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Interfaces.AroundMethodBodyRegistry.GetSurroundingImplementation(LinFu.AOP.Interfaces.IInvocationInfo)">
      <summary>
            Obtains the <see cref="T:LinFu.AOP.Interfaces.IAroundInvoke" /> instance for the given <paramref name="context" />.
            </summary>
      <param name="context">The <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> instance that describes the current method call.</param>
      <returns>An <see cref="T:LinFu.AOP.Interfaces.IAroundInvoke" /> instance that will be used to wrap a method call or method body.</returns>
    </member>
    <member name="M:LinFu.AOP.Interfaces.AroundMethodBodyRegistry.AddProvider(LinFu.AOP.Interfaces.IAroundInvokeProvider)">
      <summary>
            Adds an <see cref="T:LinFu.AOP.Interfaces.IAroundInvokeProvider" /> to the list of provider instances.
            </summary>
      <param name="provider">The <see cref="T:LinFu.AOP.Interfaces.IAroundInvokeProvider" /> instance.</param>
    </member>
    <member name="M:LinFu.AOP.Interfaces.AroundMethodBodyRegistry.Clear">
      <summary>
            Clears the list of <see cref="T:LinFu.AOP.Interfaces.IAroundInvokeProvider" /> instances.
            </summary>
    </member>
    <member name="T:LinFu.AOP.Interfaces.BootstrapException">
      <summary>
            Represents an exception thrown when LinFu.AOP is unable to bootstrap itself.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Interfaces.BootstrapException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:LinFu.AOP.Interfaces.BootstrapException" /> class.
            </summary>
      <param name="message">The exception message.</param>
      <param name="ex">The exception itself.</param>
    </member>
    <member name="T:LinFu.AOP.Interfaces.BootStrapRegistry">
      <summary>
            Represents a registry class that bootstraps components into memory when the application starts.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Interfaces.BootStrapRegistry.Initialize">
      <summary>
            Initializes the BootStrapRegistry.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Interfaces.BootStrapRegistry.GetComponents">
      <summary>
            Returns the list of components that have been initialized by the bootstrapper.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:LinFu.AOP.Interfaces.BootStrapRegistry.Instance">
      <summary>
            Gets the value indicating the BootStrapRegistry instance.
            </summary>
    </member>
    <member name="T:LinFu.AOP.Interfaces.IBeforeInvoke">
      <summary>
            Represents a class that is invoked before a method call.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Interfaces.IBeforeInvoke.BeforeInvoke(LinFu.AOP.Interfaces.IInvocationInfo)">
      <summary>
            This method will be called just before the actual
            method call is executed.
            </summary>
      <param name="info">The <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> associated with the method call.</param>
      <seealso cref="T:LinFu.AOP.Interfaces.IInvocationInfo" />
    </member>
    <member name="T:LinFu.AOP.Interfaces.IAfterInvoke">
      <summary>
            Represents a class that is invoked after a method call.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Interfaces.IAfterInvoke.AfterInvoke(LinFu.AOP.Interfaces.IInvocationInfo,System.Object)">
      <summary>
            This method will be called immediately after the actual
            method call is executed.
            </summary>
      <param name="info">The <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> associated with the method call.</param>
      <param name="returnValue">The value returned from the actual method call.</param>
    </member>
    <member name="T:LinFu.AOP.Interfaces.IAroundInvoke">
      <summary>
            Represents a class that can wrap itself around any given method call.
            </summary>
    </member>
    <member name="T:LinFu.AOP.Interfaces.ExceptionHandlerRegistry">
      <summary>
            Represents a class that stores <see cref="T:LinFu.AOP.Interfaces.IExceptionHandler" /> instances in a central location.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Interfaces.ExceptionHandlerRegistry.GetHandler(LinFu.AOP.Interfaces.IExceptionHandlerInfo)">
      <summary>
            Gets the <see cref="T:LinFu.AOP.Interfaces.IExceptionHandler" /> instance that can handle the current exception.
            </summary>
      <param name="info">The <see cref="T:LinFu.AOP.Interfaces.IExceptionHandlerInfo" /> instance that describes the context of the thrown exception.</param>
      <returns>An exception handler.</returns>
    </member>
    <member name="M:LinFu.AOP.Interfaces.ExceptionHandlerRegistry.SetHandler(LinFu.AOP.Interfaces.IExceptionHandler)">
      <summary>
            Sets the <see cref="T:LinFu.AOP.Interfaces.IExceptionHandler" /> instance that can handle all thrown exceptions.
            </summary>
      <param name="handler">The exception handler.</param>
    </member>
    <member name="T:LinFu.AOP.Interfaces.IFieldInterceptionContext">
      <summary>
            Represents a class that describes the state of a field just as it is being intercepted.
            </summary>
    </member>
    <member name="P:LinFu.AOP.Interfaces.IFieldInterceptionContext.Target">
      <summary>
            Gets a value indicating the target instance that is attached to the target field.
            </summary>
    </member>
    <member name="P:LinFu.AOP.Interfaces.IFieldInterceptionContext.TargetMethod">
      <summary>
            Gets a value indicating the host method that is currently accessing the target field.
            </summary>
    </member>
    <member name="P:LinFu.AOP.Interfaces.IFieldInterceptionContext.TargetField">
      <summary>
            Gets a value indicating the field that is currently being accessed by the target method.
            </summary>
    </member>
    <member name="P:LinFu.AOP.Interfaces.IFieldInterceptionContext.HostType">
      <summary>
            Gets a value indicating the <see cref="T:System.Type" /> that holds the target field.
            </summary>
    </member>
    <member name="T:LinFu.AOP.Interfaces.FieldInterceptionContext">
      <summary>
            Represents a class that describes the state of a field just as it is being intercepted by a <see cref="T:LinFu.AOP.Interfaces.IFieldInterceptor" />.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Interfaces.FieldInterceptionContext.#ctor(System.Object,System.Reflection.MethodBase,System.Reflection.FieldInfo,System.Type)">
      <summary>
            Initializes a new instance of the FieldInterceptionContext class.
            </summary>
      <param name="target">The target that hosts the given field.</param>
      <param name="targetMethod">The method that accessed the target field.</param>
      <param name="targetField">The field currently being accessed by the target method.</param>
      <param name="hostType">The type that hosts the target field.</param>
    </member>
    <member name="P:LinFu.AOP.Interfaces.FieldInterceptionContext.Target">
      <summary>
            Gets a value indicating the target instance that is attached to the target field.
            </summary>
    </member>
    <member name="P:LinFu.AOP.Interfaces.FieldInterceptionContext.TargetMethod">
      <summary>
            Gets a value indicating the host method that is currently accessing the target field.
            </summary>
    </member>
    <member name="P:LinFu.AOP.Interfaces.FieldInterceptionContext.TargetField">
      <summary>
            Gets a value indicating the field that is currently being accessed by the target method.
            </summary>
    </member>
    <member name="P:LinFu.AOP.Interfaces.FieldInterceptionContext.HostType">
      <summary>
            Gets a value indicating the <see cref="T:System.Type" /> that holds the target field.
            </summary>
    </member>
    <member name="T:LinFu.AOP.Interfaces.FieldInterceptorRegistry">
      <summary>
            Represents a registry class that allows users to intercept fields from a single location.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Interfaces.FieldInterceptorRegistry.GetInterceptor(LinFu.AOP.Interfaces.IFieldInterceptionContext)">
      <summary>
            Gets current the <see cref="T:LinFu.AOP.Interfaces.IFieldInterceptionContext" /> associated with the <see cref="T:LinFu.AOP.Interfaces.FieldInterceptorRegistry" />.
            </summary>
      <param name="context">The <see cref="T:LinFu.AOP.Interfaces.IFieldInterceptionContext" /> instance that describes the state of the method call when the field getter or setter is called.</param>
      <returns>The field interceptor that will be used to preempt field getter and setter calls.</returns>
    </member>
    <member name="M:LinFu.AOP.Interfaces.FieldInterceptorRegistry.SetInterceptor(LinFu.AOP.Interfaces.IFieldInterceptor)">
      <summary>
            Sets current the <see cref="T:LinFu.AOP.Interfaces.IFieldInterceptionContext" /> that will be associated with the <see cref="T:LinFu.AOP.Interfaces.FieldInterceptorRegistry" />.
            </summary>
      <param name="interceptor">The field interceptor that will be used to preempt field getter and setter calls.</param>
    </member>
    <member name="T:LinFu.AOP.Interfaces.IActivator`1">
      <summary>
            Represents a class that can instantiate object instances.
            </summary>
      <typeparam name="TContext">
            The type that describes the context of the object instantiation.
            </typeparam>
    </member>
    <member name="M:LinFu.AOP.Interfaces.IActivator`1.CreateInstance(`0)">
      <summary>
            Creates an object instance.
            </summary>
      <param name="context">The context that describes the request to instantiate the target type.</param>
      <returns>A valid object instance.</returns>
    </member>
    <member name="T:LinFu.AOP.Interfaces.IActivatorHost">
      <summary>
            Represents a type that can intercept activation requests.
            </summary>
    </member>
    <member name="P:LinFu.AOP.Interfaces.IActivatorHost.Activator">
      <summary>
            Gets or sets the value indicating the <see cref="T:LinFu.AOP.Interfaces.ITypeActivator" /> that
            will be used to instantiate object types.
            </summary>
    </member>
    <member name="T:LinFu.AOP.Interfaces.IAroundInvokeHost">
      <summary>
            Represents a type that supports injecting code around a method body or method call.
            </summary>
    </member>
    <member name="P:LinFu.AOP.Interfaces.IAroundInvokeHost.AroundMethodBodyProvider">
      <summary>
            Gets or sets the value indicating the <see cref="T:LinFu.AOP.Interfaces.IAroundInvokeProvider" />
            that will be used to inject code "around" a particular method body
            implementation.
            </summary>
    </member>
    <member name="P:LinFu.AOP.Interfaces.IAroundInvokeHost.AroundMethodCallProvider">
      <summary>
            Gets or sets the value indicating the <see cref="T:LinFu.AOP.Interfaces.IAroundInvokeProvider" />
            that will be used to inject code "around" a particular method call
            implementation.
            </summary>
    </member>
    <member name="T:LinFu.AOP.Interfaces.IAroundInvokeProvider">
      <summary>
            Represents a class that injects code around a method implementation.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Interfaces.IAroundInvokeProvider.GetSurroundingImplementation(LinFu.AOP.Interfaces.IInvocationInfo)">
      <summary>
            Gets the <see cref="T:LinFu.AOP.Interfaces.IAroundInvoke" /> instance that will be executed
            before and after the target method (specified in the <paramref name="context" /> parameter)
            is called.
            </summary>
      <param name="context">The <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> that describes the context of the method call at the call site.</param>        /// <returns>An <see cref="T:LinFu.AOP.Interfaces.IAroundInvoke" /> instance if the surrounding behavior can be found; otherwise, it should return <c>null</c>.</returns></member>
    <member name="T:LinFu.AOP.Interfaces.IBootStrappedComponent">
      <summary>
            Represents a type that will be automatically initialized once the LinFu.AOP assembly is loaded into memory.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Interfaces.IBootStrappedComponent.Initialize">
      <summary>
            Initializes the bootstrapped component.
            </summary>
    </member>
    <member name="T:LinFu.AOP.Interfaces.IExceptionHandler">
      <summary>
            Represents a type that can catch thrown exceptions.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Interfaces.IExceptionHandler.CanCatch(LinFu.AOP.Interfaces.IExceptionHandlerInfo)">
      <summary>
            Determines whether or not an exception can be handled.
            </summary>
      <param name="exceptionHandlerInfo">The object that describes the exception being thrown.</param>
      <returns>
        <c>True</c> if the exception can be handled by the current handler.</returns>
    </member>
    <member name="M:LinFu.AOP.Interfaces.IExceptionHandler.Catch(LinFu.AOP.Interfaces.IExceptionHandlerInfo)">
      <summary>
            Handles the exception specified in the <paramref name="exceptionHandlerInfo" /> instance.
            </summary>
      <param name="exceptionHandlerInfo">The object that describes the exception being thrown.</param>
    </member>
    <member name="T:LinFu.AOP.Interfaces.IExceptionHandlerInfo">
      <summary>
            Represents a type that describes the context of a thrown exception.
            </summary>
    </member>
    <member name="P:LinFu.AOP.Interfaces.IExceptionHandlerInfo.Exception">
      <summary>
            Gets the value indicating the thrown exception.
            </summary>
      <value>The thrown exception.</value>
    </member>
    <member name="P:LinFu.AOP.Interfaces.IExceptionHandlerInfo.InvocationInfo">
      <summary>
            Gets the value indicating the <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> instance that describes the context of the method
            that threw the exception.
            </summary>
      <value>The <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> instance.</value>
    </member>
    <member name="P:LinFu.AOP.Interfaces.IExceptionHandlerInfo.ReturnValue">
      <summary>
            Gets or sets the value indicating the return value that will be used in place of the original return value if 
            the exception is intercepted by an <see cref="T:LinFu.AOP.Interfaces.IExceptionHandler" /> instance.
            </summary>
      <value>The method return value.</value>
    </member>
    <member name="P:LinFu.AOP.Interfaces.IExceptionHandlerInfo.ShouldSkipRethrow">
      <summary>
            Gets or sets the value indicating whether or not the exception should be rethrown after
            the <see cref="T:LinFu.AOP.Interfaces.IExceptionHandler" /> handles the given exception.
            </summary>
      <value>This should be <c>true</c> if the exception should be rethrown, otherwise, it must be <c>false</c>.</value>
    </member>
    <member name="T:LinFu.AOP.Interfaces.IFieldInterceptionHost">
      <summary>
            Represents a type that has been modified to intercept field getters and setters.
            </summary>
    </member>
    <member name="P:LinFu.AOP.Interfaces.IFieldInterceptionHost.FieldInterceptor">
      <summary>
            Gets or sets the value indicating the interceptor that will handle field getters and setters.
            </summary>
    </member>
    <member name="T:LinFu.AOP.Interfaces.IFieldInterceptor">
      <summary>
            Represents a type that can intercept field getter and setter calls.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Interfaces.IFieldInterceptor.CanIntercept(LinFu.AOP.Interfaces.IFieldInterceptionContext)">
      <summary>
            Determines whether or not a field can be intercepted.
            </summary>
      <param name="context">The context that describes the field to be intercepted.</param>
      <returns>
        <c>true</c> if it can be intercepted; otherwise, it will return <c>false</c>.</returns>
    </member>
    <member name="M:LinFu.AOP.Interfaces.IFieldInterceptor.GetValue(LinFu.AOP.Interfaces.IFieldInterceptionContext)">
      <summary>
            Gets the value of a field.
            </summary>
      <param name="context">The context that describes the field to be intercepted.</param>
      <returns>The value of the target field.</returns>
    </member>
    <member name="M:LinFu.AOP.Interfaces.IFieldInterceptor.SetValue(LinFu.AOP.Interfaces.IFieldInterceptionContext,System.Object)">
      <summary>
            Sets the value of a field.
            </summary>
      <param name="context">The context that describes the field to be intercepted.</param>
      <param name="value">The original value that will be assigned to the target field.</param>
      <returns>The value that will be assigned to the target field.</returns>
    </member>
    <member name="T:LinFu.AOP.Interfaces.IInterceptor">
      <summary>
            Represents a class that can dynamically intercept method calls.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Interfaces.IInterceptor.Intercept(LinFu.AOP.Interfaces.IInvocationInfo)">
      <summary>
            Intercepts a method call using the given
            <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> instance.
            </summary>
      <param name="info">The <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> instance that will 
            contain all the necessary information associated with a 
            particular method call.</param>
      <returns>The return value of the target method. If the return type of the target
            method is <see cref="T:System.Void" />, then the return value will be ignored.</returns>
    </member>
    <member name="T:LinFu.AOP.Interfaces.IInvocationInfo">
      <summary>
            Represents the information associated with 
            a single method call.
            </summary>
    </member>
    <member name="P:LinFu.AOP.Interfaces.IInvocationInfo.Target">
      <summary>
            The target instance currently being called.
            </summary>
      <remarks>This typically is a reference to a proxy object.</remarks>
    </member>
    <member name="P:LinFu.AOP.Interfaces.IInvocationInfo.TargetMethod">
      <summary>
            The method currently being called.
            </summary>
    </member>
    <member name="P:LinFu.AOP.Interfaces.IInvocationInfo.ReturnType">
      <summary>
            The return type of the <see cref="P:LinFu.AOP.Interfaces.IInvocationInfo.TargetMethod" />.
            </summary>
    </member>
    <member name="P:LinFu.AOP.Interfaces.IInvocationInfo.StackTrace">
      <summary>
            The <see cref="P:LinFu.AOP.Interfaces.IInvocationInfo.StackTrace" /> associated
            with the method call when the call was made.
            </summary>
    </member>
    <member name="P:LinFu.AOP.Interfaces.IInvocationInfo.ParameterTypes">
      <summary>
            The parameter types for the current target method.
            </summary>
      <remarks>
        <para>
            This could be very useful in cases where the actual target method
            is based on a generic type definition. In such cases, 
            the <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> instance needs to be able
            to describe the actual parameter types being used by the
            current generic type instantiation. This property helps
            users determine which parameter types are actually being used
            at the time of the method call.
            </para>
      </remarks>
    </member>
    <member name="P:LinFu.AOP.Interfaces.IInvocationInfo.TypeArguments">
      <summary>
            If the <see cref="P:LinFu.AOP.Interfaces.IInvocationInfo.TargetMethod" /> method is a generic method, 
            this will hold the generic type arguments used to construct the
            method.
            </summary>
    </member>
    <member name="P:LinFu.AOP.Interfaces.IInvocationInfo.Arguments">
      <summary>
            The arguments used in the method call.
            </summary>
    </member>
    <member name="T:LinFu.AOP.Interfaces.IInvokeWrapper">
      <summary>
            Represents a special type of interceptor that can
            wrap itself around a method call.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Interfaces.IInvokeWrapper.DoInvoke(LinFu.AOP.Interfaces.IInvocationInfo)">
      <summary>
            This method will provide the actual implementation
            for the <see cref="P:LinFu.AOP.Interfaces.IInvocationInfo.TargetMethod">target method</see>
            instance.
            </summary>
      <param name="info">The <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> associated with the method call.</param>
      <returns>The actual return value from the <see cref="P:LinFu.AOP.Interfaces.IInvocationInfo.TargetMethod" />.</returns>
    </member>
    <member name="T:LinFu.AOP.Interfaces.ITypeActivationContext">
      <summary>
            Represents a special type of <see cref="T:LinFu.AOP.Interfaces.IActivationContext" /> that can be used to instantiate a given type
            and can be used to describe the method that invoked the instantiation operation as well as specify the object
            instance that invoked the instantiation itself.
            </summary>
    </member>
    <member name="P:LinFu.AOP.Interfaces.ITypeActivationContext.Target">
      <summary>
            Gets the value indicating the object instance that initiated the object instantiation operation.
            </summary>
    </member>
    <member name="P:LinFu.AOP.Interfaces.ITypeActivationContext.TargetMethod">
      <summary>
            Gets the value indiating the <see cref="T:System.Reflection.MethodBase" /> instance that initiated the object instantiation operation.
            </summary>
    </member>
    <member name="T:LinFu.AOP.Interfaces.ITypeActivator">
      <summary>
            Represents an <see cref="T:LinFu.AOP.Interfaces.IActivator`1" /> that can instantiate objects from within a particular method.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Interfaces.ITypeActivator.CanActivate(LinFu.AOP.Interfaces.ITypeActivationContext)">
      <summary>
            Determines whether or not a type can be instantiated using the 
            <paramref name="context" />.
            </summary>
      <param name="context">The <see cref="T:LinFu.AOP.Interfaces.ITypeActivationContext" /> instance that describes the type to be created.</param>
      <returns>
        <c>true</c> if the type can be created; otherwise, it will return <c>false</c>.</returns>
    </member>
    <member name="T:LinFu.AOP.Interfaces.IMethodReplacementHost">
      <summary>
            Represents a type that can have its method body  implementations replaced at runtime.
            </summary>
    </member>
    <member name="P:LinFu.AOP.Interfaces.IMethodReplacementHost.MethodBodyReplacementProvider">
      <summary>
            Gets or sets a value indicating the <see cref="T:LinFu.AOP.Interfaces.IMethodReplacementProvider" /> that will be used to swap method body implementations at runtime.
            </summary>
    </member>
    <member name="P:LinFu.AOP.Interfaces.IMethodReplacementHost.MethodCallReplacementProvider">
      <summary>
            Gets or sets a value indicating the <see cref="T:LinFu.AOP.Interfaces.IMethodReplacementProvider" /> that will be used to swap method body implementations at runtime.
            </summary>
    </member>
    <member name="T:LinFu.AOP.Interfaces.IMethodReplacementProvider">
      <summary>
            Represents a type that can swap method body implementations at runtime.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Interfaces.IMethodReplacementProvider.CanReplace(System.Object,LinFu.AOP.Interfaces.IInvocationInfo)">
      <summary>
            Determines whether or not the current method implementation can be replaced.
            </summary>
      <param name="host">The target instance of the method call.</param>
      <param name="info">The <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> that describes the context of the method call.</param>
      <returns>
        <c>true</c> if the method can be intercepted; otherwise, it will return <c>false</c>.</returns>
    </member>
    <member name="M:LinFu.AOP.Interfaces.IMethodReplacementProvider.GetMethodReplacement(System.Object,LinFu.AOP.Interfaces.IInvocationInfo)">
      <summary>
            Obtains the <see cref="T:LinFu.AOP.Interfaces.IInterceptor" /> instance that will be used to replace the current method call.
            </summary>
      <param name="host">The target instance of the method call.</param>
      <param name="info">The <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> that describes the context of the method call.</param>
      <returns>The interceptor that will intercept the method call itself.</returns>
    </member>
    <member name="T:LinFu.AOP.Interfaces.IModifiableType">
      <summary>
            Represents a type that has been modified to support
            pervasive method interception.
            </summary>
    </member>
    <member name="P:LinFu.AOP.Interfaces.IModifiableType.IsInterceptionDisabled">
      <summary>
            Gets or sets the value indicating whether or not 
            method interception should be disabled.
            </summary>
    </member>
    <member name="T:LinFu.AOP.Interfaces.MethodBodyReplacementProviderRegistry">
      <summary>
            Represents a static type that allows users to register a method replacement provider from a single location.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Interfaces.MethodBodyReplacementProviderRegistry.GetProvider(System.Object,LinFu.AOP.Interfaces.IInvocationInfo)">
      <summary>
            Returns the provider that is currently attached to the registry.
            </summary>
      <param name="host">The type that is currently being intercepted.</param>
      <param name="info">The <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> object that describes the invocation context.</param>
      <returns>A <see cref="T:LinFu.AOP.Interfaces.IMethodReplacementProvider" /> that will determine the code that will be executed once a target method is called.</returns>
    </member>
    <member name="M:LinFu.AOP.Interfaces.MethodBodyReplacementProviderRegistry.SetProvider(LinFu.AOP.Interfaces.IMethodReplacementProvider)">
      <summary>
            Assigns the <paramref name="provider" /> to the MethodReplacementProvider registry.
            </summary>
      <returns>A <see cref="T:LinFu.AOP.Interfaces.IMethodReplacementProvider" /> that will determine the code that will be executed once a target method is called.</returns>
    </member>
    <member name="T:LinFu.AOP.Interfaces.MethodCallReplacementProviderRegistry">
      <summary>
            Represents a static type that allows users to register a method replacement provider from a single location.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Interfaces.MethodCallReplacementProviderRegistry.GetProvider(System.Object,LinFu.AOP.Interfaces.IInvocationInfo)">
      <summary>
            Returns the provider that is currently attached to the registry.
            </summary>
      <param name="host">The type that is currently being intercepted.</param>
      <param name="info">The <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> object that describes the invocation context.</param>
      <returns>A <see cref="T:LinFu.AOP.Interfaces.IMethodReplacementProvider" /> that will determine the code that will be executed once a target method is called.</returns>
    </member>
    <member name="M:LinFu.AOP.Interfaces.MethodCallReplacementProviderRegistry.SetProvider(LinFu.AOP.Interfaces.IMethodReplacementProvider)">
      <summary>
            Assigns the <paramref name="provider" /> to the MethodReplacementProvider registry.
            </summary>
      <returns>A <see cref="T:LinFu.AOP.Interfaces.IMethodReplacementProvider" /> that will determine the code that will be executed once a target method is called.</returns>
    </member>
    <member name="T:LinFu.AOP.Interfaces.TypeActivationContext">
      <summary>
            Represents an <see cref="T:LinFu.AOP.Interfaces.ActivationContext" /> that can be used to instantiate a given type
            and be used to describe the method that invoked the instantiation operation as well as specify the object
            instance that invoked the instantiation itself.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Interfaces.TypeActivationContext.#ctor(System.Object,System.Reflection.MethodBase,System.Type,System.Object[])">
      <summary>
            Initializes a new instance of the MethodActivationContext class.
            </summary>
      <param name="target">The object instance that initiated the activation request.</param>
      <param name="targetMethod">The method where the activation was invoked.</param>
      <param name="concreteType">The type to be constructed.</param>
      <param name="additionalArguments">The additional arguments that will be passed to the constructor.</param>
    </member>
    <member name="P:LinFu.AOP.Interfaces.TypeActivationContext.Target">
      <summary>
            Gets the value indicating the object instance that initiated the object instantiation operation.
            </summary>
    </member>
    <member name="P:LinFu.AOP.Interfaces.TypeActivationContext.TargetMethod">
      <summary>
            Gets the value indiating the <see cref="T:System.Reflection.MethodBase" /> instance that initiated the object instantiation operation.
            </summary>
    </member>
    <member name="T:LinFu.AOP.Interfaces.TypeActivatorRegistry">
      <summary>
            Represents a registry that allows users to statically register <see cref="T:LinFu.AOP.Interfaces.ITypeActivator" />
            instances.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Interfaces.TypeActivatorRegistry.GetActivator(LinFu.AOP.Interfaces.ITypeActivationContext)">
      <summary>
            Obtains an activator for the given <paramref name="context" />.
            </summary>
      <param name="context">The <see cref="T:LinFu.AOP.Interfaces.ITypeActivationContext" /> instance that describes the object to be created.</param>
      <returns>A method activator.</returns>
    </member>
    <member name="M:LinFu.AOP.Interfaces.TypeActivatorRegistry.SetActivator(LinFu.AOP.Interfaces.ITypeActivator)">
      <summary>
            Sets the <see cref="T:LinFu.AOP.Interfaces.ITypeActivator" /> that will be used to 
            instantiate object instances.
            </summary>
      <param name="activator">The <see cref="T:LinFu.AOP.Interfaces.ITypeActivator" /> that will instantiate types.</param>
    </member>
    <member name="T:LinFu.AOP.Tasks.PostWeaveTask">
      <summary>
            Represents an MSBuild task for LinFu.AOP that allows users to inject an aspect framework into their applications
            at postbuild time.
            </summary>
    </member>
    <member name="M:LinFu.AOP.Tasks.PostWeaveTask.Execute">
      <summary>
            Executes the postweaver.
            </summary>
      <returns>Returns <c>true</c> if the operation succeeded. Otherwise, it will return <c>false</c>.</returns>
    </member>
    <member name="P:LinFu.AOP.Tasks.PostWeaveTask.TargetFile">
      <summary>
            Gets or sets the value indicating the full path and filename of the target assembly.
            </summary>
      <value>The target assembly filename.</value>
    </member>
    <member name="P:LinFu.AOP.Tasks.PostWeaveTask.OutputFile">
      <summary>
            Gets or sets the value indicating the full path and filename of the output assembly.
            </summary>
      <value>The output assembly filename.</value>
      <remarks>This field is optional; if blank, the default value will be the same value as the <see cref="P:LinFu.AOP.Tasks.PostWeaveTask.TargetFile" /> property.</remarks>
    </member>
    <member name="P:LinFu.AOP.Tasks.PostWeaveTask.InterceptAllMethodCalls">
      <summary>
            Gets or sets the value indicating whether or not third party method calls should be intercepted in the target assembly.
            </summary>
      <value>A boolean value indicating whether or not third party method call interception should be enabled.</value>
    </member>
    <member name="P:LinFu.AOP.Tasks.PostWeaveTask.InterceptAllMethodBodies">
      <summary>
            Gets or sets the value indicating whether or not method bodies should be intercepted in the target assembly.
            </summary>
      <value>A boolean value indicating whether or not method body interception should be enabled.</value>
    </member>
    <member name="P:LinFu.AOP.Tasks.PostWeaveTask.InterceptAllNewInstances">
      <summary>
            Gets or sets the value indicating whether or not new instances should be intercepted in the target assembly.
            </summary>
      <value>A boolean value indicating whether or not new instance interception should be enabled.</value>
    </member>
    <member name="P:LinFu.AOP.Tasks.PostWeaveTask.InterceptAllFields">
      <summary>
            Gets or sets the value indicating whether or not field reads and writes should be intercepted in the target assembly.
            </summary>
      <value>A boolean value indicating whether or not field reads and writes should be enabled.</value>
    </member>
    <member name="P:LinFu.AOP.Tasks.PostWeaveTask.InterceptAllExceptions">
      <summary>
            Gets or sets the value indicating whether or not thrown exceptions should be intercepted in the target assembly.
            </summary>
      <value>A boolean value indicating whether or not exception interception should be enabled.</value>
    </member>
    <member name="T:LinFu.Finders.Interfaces.ICriteria`1">
      <summary>
            Represents a class that describes the search criteria
            for a given item <typeparamref name="T">type</typeparamref>.
            </summary>
      <typeparam name="T">The target item type.</typeparam>
    </member>
    <member name="P:LinFu.Finders.Interfaces.ICriteria`1.Type">
      <summary>
            Gets or sets a value indicating the <see cref="T:LinFu.Finders.Interfaces.CriteriaType" />
            of the current <see cref="T:LinFu.Finders.Interfaces.ICriteria`1" />.
            </summary>
    </member>
    <member name="P:LinFu.Finders.Interfaces.ICriteria`1.Predicate">
      <summary>
            The condition that will determine whether or not
            the target item matches the criteria.
            </summary>
    </member>
    <member name="P:LinFu.Finders.Interfaces.ICriteria`1.Weight">
      <summary>
            Gets or sets a value indicating the weight of the given <see cref="P:LinFu.Finders.Interfaces.ICriteria`1.Predicate" />.
            </summary>
    </member>
    <member name="T:LinFu.Finders.Criteria`1">
      <summary>
            Represents the default implementation of the <see cref="T:LinFu.Finders.Interfaces.ICriteria`1" /> interface.
            </summary>
      <typeparam name="T">The type of item to test.</typeparam>
    </member>
    <member name="P:LinFu.Finders.Criteria`1.Type">
      <summary>
            Gets or sets a value indicating the <see cref="T:LinFu.Finders.Interfaces.CriteriaType" />
            of the current <see cref="T:LinFu.Finders.Criteria`1" />.
            </summary>
    </member>
    <member name="P:LinFu.Finders.Criteria`1.Predicate">
      <summary>
            The condition that will determine whether or not
            the target item matches the criteria.
            </summary>
    </member>
    <member name="P:LinFu.Finders.Criteria`1.Weight">
      <summary>
            The weight of the given <see cref="P:LinFu.Finders.Criteria`1.Predicate" />.
            </summary>
    </member>
    <member name="T:LinFu.Finders.FinderExtensions">
      <summary>
            A class that adds fuzzy search support to <see cref="T:System.Collections.Generic.IList`1" /> instances.
            </summary>
    </member>
    <member name="M:LinFu.Finders.FinderExtensions.AddCriteria``1(System.Collections.Generic.IList{LinFu.Finders.Interfaces.IFuzzyItem{``0}},LinFu.Finders.Interfaces.ICriteria{``0})">
      <summary>
            Applies a criteria to the <paramref name="list" /> of 
            fuzzy items.
            </summary>
      <typeparam name="TItem">The type of item to test.</typeparam>
      <param name="list">The list of <see cref="T:LinFu.Finders.Interfaces.IFuzzyItem`1" /> instances that represent a single test case in a fuzzy search.</param>
      <param name="criteria">The criteria to test against each item in the list.</param>
    </member>
    <member name="M:LinFu.Finders.FinderExtensions.AddCriteria``1(System.Collections.Generic.IList{LinFu.Finders.Interfaces.IFuzzyItem{``0}},System.Func{``0,System.Boolean})">
      <summary>
            Applies a criteria to the <paramref name="list" /> of 
            fuzzy items using the given <paramref name="predicate" />.
            </summary>
      <typeparam name="TItem">The type of item to test.</typeparam>
      <param name="list">The list of <see cref="T:LinFu.Finders.Interfaces.IFuzzyItem`1" /> instances that represent a single test case in a fuzzy search.</param>
      <param name="predicate">The condition that will be used to test the target item.</param>
    </member>
    <member name="M:LinFu.Finders.FinderExtensions.AddCriteria``1(System.Collections.Generic.IList{LinFu.Finders.Interfaces.IFuzzyItem{``0}},System.Func{``0,System.Boolean},LinFu.Finders.Interfaces.CriteriaType)">
      <summary>
            Applies a criteria to the <paramref name="list" /> of 
            fuzzy items using the given <paramref name="predicate" />.
            </summary>
      <typeparam name="TItem">The type of item to test.</typeparam>
      <param name="list">The list of <see cref="T:LinFu.Finders.Interfaces.IFuzzyItem`1" /> instances that represent a single test case in a fuzzy search.</param>
      <param name="predicate">The condition that will be used to test the target item.</param>
      <param name="criteriaType">The <see cref="T:LinFu.Finders.Interfaces.CriteriaType" /> to associate with the predicate.</param>
    </member>
    <member name="M:LinFu.Finders.FinderExtensions.AddCriteria``1(System.Collections.Generic.IList{LinFu.Finders.Interfaces.IFuzzyItem{``0}},System.Func{``0,System.Boolean},LinFu.Finders.Interfaces.CriteriaType,System.Int32)">
      <summary>
            Applies a criteria to the <paramref name="list" /> of 
            fuzzy items using the given <paramref name="predicate" />.
            </summary>
      <typeparam name="TItem">The type of item to test.</typeparam>
      <param name="list">The list of <see cref="T:LinFu.Finders.Interfaces.IFuzzyItem`1" /> instances that represent a single test case in a fuzzy search.</param>
      <param name="predicate">The condition that will be used to test the target item.</param>
      <param name="criteriaType">The <see cref="T:LinFu.Finders.Interfaces.CriteriaType" /> to associate with the predicate.</param>
      <param name="weight">The weight of the predicate value expressed in the number of tests that will be counted for/against the target item as a result of the predicate.</param>
    </member>
    <member name="M:LinFu.Finders.FinderExtensions.Add``1(System.Collections.Generic.IList{LinFu.Finders.Interfaces.IFuzzyItem{``0}},``0)">
      <summary>
            Adds an item to a fuzzy list.
            </summary>
      <typeparam name="T">The type of the item being added.</typeparam>
      <param name="list">The fuzzy list that will contain the new item.</param>
      <param name="item">The item being added.</param>
    </member>
    <member name="M:LinFu.Finders.FinderExtensions.BestMatch``1(System.Collections.Generic.IList{LinFu.Finders.Interfaces.IFuzzyItem{``0}})">
      <summary>
            Returns the FuzzyItem with the highest confidence score in a given
            <see cref="T:LinFu.Finders.Interfaces.IFuzzyItem`1" /> list.
            </summary>
      <typeparam name="TItem">The type of item being compared.</typeparam>
      <param name="list">The fuzzy list that contains the list of possible matches.</param>
      <returns>The item with the highest match.</returns>
    </member>
    <member name="M:LinFu.Finders.FinderExtensions.Reset``1(System.Collections.Generic.IList{LinFu.Finders.Interfaces.IFuzzyItem{``0}})">
      <summary>
            Resets the scores of all fuzzy items in the current list.
            </summary>
      <typeparam name="TItem">The target item type.</typeparam>
      <param name="list">The fuzzy list itself.</param>
    </member>
    <member name="M:LinFu.Finders.FinderExtensions.AsFuzzyList``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Converts a list into a list of <see cref="T:LinFu.Finders.Interfaces.IFuzzyItem`1" /> objects.
            </summary>
      <typeparam name="TItem">The item type will be used in the fuzzy search.</typeparam>
      <param name="items">The target list to be converted.</param>
      <returns>A fuzzy list containing the elements from the given list.</returns>
    </member>
    <member name="T:LinFu.Finders.Interfaces.IFuzzyItem`1">
      <summary>
            Represents a search item in a fuzzy search list.
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="M:LinFu.Finders.Interfaces.IFuzzyItem`1.Test(LinFu.Finders.Interfaces.ICriteria{`0})">
      <summary>
            Tests if the current item matches the given
            <paramref name="criteria" />.
            </summary>
      <param name="criteria">The <see cref="T:LinFu.Finders.Interfaces.ICriteria`1" /> that determines whether or not the <see cref="P:LinFu.Finders.Interfaces.IFuzzyItem`1.Item" /> meets a particular description.</param>
    </member>
    <member name="M:LinFu.Finders.Interfaces.IFuzzyItem`1.Reset">
      <summary>
            Resets the item back to its initial state.
            </summary>
    </member>
    <member name="P:LinFu.Finders.Interfaces.IFuzzyItem`1.Confidence">
      <summary>
            Reports the probability of a match
            based on the <see cref="T:LinFu.Finders.Interfaces.ICriteria`1" />
            that has been tested so far. 
            
            A value of 1.0 indicates a 100% match;
            A value of 0.0 equals a zero percent match.
            </summary>
    </member>
    <member name="P:LinFu.Finders.Interfaces.IFuzzyItem`1.Item">
      <summary>
            Gets the target item.
            </summary>
    </member>
    <member name="T:LinFu.Finders.FuzzyItem`1">
      <summary>
            Represents the default implementation of a weighted item in
            a fuzzy list.
            </summary>
      <typeparam name="T">The item type to be tested.</typeparam>
    </member>
    <member name="M:LinFu.Finders.FuzzyItem`1.#ctor(`0)">
      <summary>
            Initializes the <see cref="T:LinFu.Finders.FuzzyItem`1" /> class with the given <paramref name="item" />.
            </summary>
      <param name="item">An instance of the <typeparamref name="T">item type</typeparamref> that will be tested.</param>
    </member>
    <member name="M:LinFu.Finders.FuzzyItem`1.Test(LinFu.Finders.Interfaces.ICriteria{`0})">
      <summary>
            Tests if the current item matches the given
            <paramref name="criteria" />.
            </summary>
      <param name="criteria">The <see cref="T:LinFu.Finders.Interfaces.ICriteria`1" /> that determines whether or not the <see cref="P:LinFu.Finders.FuzzyItem`1.Item" /> meets a particular description.</param>
    </member>
    <member name="M:LinFu.Finders.FuzzyItem`1.Reset">
      <summary>
            Resets the item back to its initial state.
            </summary>
    </member>
    <member name="P:LinFu.Finders.FuzzyItem`1.Confidence">
      <summary>
            Reports the probability of a match
            based on the <see cref="T:LinFu.Finders.Interfaces.ICriteria`1" />
            that has been tested so far. 
            
            A value of 1.0 indicates a 100% match;
            A value of 0.0 equals a zero percent match.
            </summary>
    </member>
    <member name="P:LinFu.Finders.FuzzyItem`1.Item">
      <summary>
            Gets the target item.
            </summary>
    </member>
    <member name="T:LinFu.Finders.Interfaces.CriteriaType">
      <summary>
            The enumeration that determines how a <see cref="T:LinFu.Finders.Interfaces.ICriteria`1" /> instance should
            be handled if the criteria test fails.
            </summary>
    </member>
    <member name="F:LinFu.Finders.Interfaces.CriteriaType.Standard">
      <summary>
            A failure in a criteria test will result in a lower weighted
            score for a target item.
            </summary>
    </member>
    <member name="F:LinFu.Finders.Interfaces.CriteriaType.Optional">
      <summary>
            A failure in a criteria test will be ignored, and hence,
            the criteria will be optional.
            </summary>
    </member>
    <member name="F:LinFu.Finders.Interfaces.CriteriaType.Critical">
      <summary>
            A failure in a criteria test will cause all previous and remaining
            tests against the criteria to fail.
            </summary>
    </member>
    <member name="T:LinFu.Finders.PredicateExtensions">
      <summary>
            A class that adds logical extensions to the <see cref="T:System.Func`2" /> predicate
            class.
            </summary>
    </member>
    <member name="M:LinFu.Finders.PredicateExtensions.Or``1(System.Func{``0,System.Boolean},System.Func{``0,System.Boolean})">
      <summary>
            Logically ORs two <see cref="T:System.Func`2" /> predicates together.
            </summary>
      <typeparam name="TItem">The type of item being compared.</typeparam>
      <param name="left">The left hand predicate.</param>
      <param name="right">The right hand predicate.</param>
      <returns>A predicate that will return <c>true</c> if and only if one of the given predicates is <c>true</c>; otherwise, it will return <c>false</c>.</returns>
    </member>
    <member name="M:LinFu.Finders.PredicateExtensions.And``1(System.Func{``0,System.Boolean},System.Func{``0,System.Boolean})">
      <summary>
            Logically ANDs two <see cref="T:System.Func`2" /> predicates together.
            </summary>
      <typeparam name="TItem">The type of item being compared.</typeparam>
      <param name="left">The left hand predicate.</param>
      <param name="right">The right hand predicate.</param>
      <returns>A predicate that will return <c>true</c> if and only if both of the given predicates are <c>true</c>; otherwise, it will return <c>false</c>.</returns>
    </member>
    <member name="M:LinFu.Finders.PredicateExtensions.Inverse``1(System.Func{``0,System.Boolean})">
      <summary>
            Logically negates a single predicate.
            </summary>
      <typeparam name="TItem">The type of item being compared.</typeparam>
      <param name="predicate">The predicate to negate.</param>
      <returns>Returns <c>true</c> if the given predicate is <c>false</c>.</returns>
    </member>
    <member name="T:LinFu.IoC.Configuration.FactoryAttribute">
      <summary>
            An attribute that marks a type as a custom factory.
            </summary>
    </member>
    <member name="F:LinFu.IoC.Configuration.FactoryAttribute.ServiceName">
      <summary>
            The service name that will be associated
            with the service type.
            </summary>
    </member>
    <member name="F:LinFu.IoC.Configuration.FactoryAttribute.ArgumentTypes">
      <summary>
            The additional parameters supported by the custom factory.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.FactoryAttribute.#ctor(System.Type)">
      <summary>
            Marks a target type as a custom factory
            that can create object instances that
            can implement the <paramref name="serviceType" />.
            </summary>
      <param name="serviceType">The service type to create.</param>
    </member>
    <member name="P:LinFu.IoC.Configuration.FactoryAttribute.ServiceType">
      <summary>
            Gets the service type that can be created
            using the factory instance.
            </summary>
    </member>
    <member name="T:LinFu.IoC.Interfaces.IContainer">
      <summary>
            An inversion of control container interface.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Interfaces.IContainer.AddFactory(System.Type,System.Collections.Generic.IEnumerable{System.Type},LinFu.IoC.Interfaces.IFactory)">
      <summary>
            Adds an <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance and associates it
            with the given <paramref name="serviceType">service type</paramref>.
            </summary>
      <param name="serviceType">The service type to associate with the factory</param>
      <param name="additionalParameterTypes">The list of additional parameters that this factory type will support.</param>
      <param name="factory">The <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance that will be responsible for creating the service instance</param>
    </member>
    <member name="M:LinFu.IoC.Interfaces.IContainer.Contains(System.Type,System.Collections.Generic.IEnumerable{System.Type})">
      <summary>
            Determines whether or not the container can create
            the given <paramref name="serviceType">service type</paramref>.
            </summary>
      <param name="serviceType">The type of service used to determine whether or not the given service can actually be created</param>
      <param name="additionalParameterTypes">The list of additional parameters that this factory type will support.</param>
      <returns>A <see cref="T:System.Boolean">boolean</see> value that indicates whether or not the service exists.</returns>
    </member>
    <member name="M:LinFu.IoC.Interfaces.IContainer.GetService(System.Type,System.Object[])">
      <summary>
            Causes the container to instantiate the service with the given
            <paramref name="serviceType">service type</paramref>. If the service type cannot be created, then an
            exception will be thrown if the <see cref="P:LinFu.IoC.Interfaces.IContainer.SuppressErrors" /> property
            is set to false. Otherwise, it will simply return null.
            </summary>
      <param name="serviceType">The service type to instantiate.</param>
      <param name="additionalArguments">The additional arguments that will be used to instantiate the service type.</param>
      <returns>If successful, it will return a service instance that is compatible with the given type;
            otherwise, it will just return a null value.</returns>
    </member>
    <member name="P:LinFu.IoC.Interfaces.IContainer.AvailableServices">
      <summary>
            The list of services currently available inside the container.
            </summary>
    </member>
    <member name="P:LinFu.IoC.Interfaces.IContainer.SuppressErrors">
      <summary>
            Determines whether or not a container will throw an exception
            if the requested service is not found.
            </summary>
    </member>
    <member name="T:LinFu.IoC.Interfaces.IFactory">
      <summary>
            Allows an object to create its own service instances.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Interfaces.IFactory.CreateInstance(LinFu.IoC.Interfaces.IFactoryRequest)">
      <summary>
            Creates a service instance using the given <see cref="T:LinFu.IoC.Interfaces.IFactoryRequest" /> instance.
            </summary>
      <param name="request">The <see cref="T:LinFu.IoC.Interfaces.IFactoryRequest" /> instance that describes the requested service.</param>
      <returns>An object instance that represents the service to be created. This cannot be <c>null</c>.</returns>
    </member>
    <member name="T:LinFu.IoC.Interfaces.IFactoryRequest">
      <summary>
            Represents the parameters made to a <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance during
            a <see cref="M:LinFu.IoC.Interfaces.IFactory.CreateInstance(LinFu.IoC.Interfaces.IFactoryRequest)" /> method call.
            </summary>
    </member>
    <member name="P:LinFu.IoC.Interfaces.IFactoryRequest.Container">
      <summary>
            Gets or sets the value indicating the service container that made the service request.
            </summary>
    </member>
    <member name="P:LinFu.IoC.Interfaces.IFactoryRequest.ServiceName">
      <summary>
            Gets the value indicating the service name.
            </summary>
      <remarks>A null service name indicates that no service name was given during the request.</remarks>
    </member>
    <member name="P:LinFu.IoC.Interfaces.IFactoryRequest.ServiceType">
      <summary>
            Gets the value indicating the requested service type.
            </summary>
    </member>
    <member name="P:LinFu.IoC.Interfaces.IFactoryRequest.Arguments">
      <summary>
            Gets the value indicating the additional arguments given in the factory request.
            </summary>
    </member>
    <member name="T:LinFu.IoC.Configuration.IInitialize">
      <summary>
            Represents service classes that need to be initialized
            every time a particular <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" />
            instance creates that type.
            </summary>
    </member>
    <member name="T:LinFu.IoC.Configuration.ImplementsAttribute">
      <summary>
            The attribute used to specify how a service should be implemented
            in addition to its instancing behavior.
            </summary>
    </member>
    <member name="F:LinFu.IoC.Configuration.ImplementsAttribute.ServiceName">
      <summary>
            The name to associate with the given service.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.ImplementsAttribute.#ctor(System.Type)">
      <summary>
            Allows users to add services to a container using a 
            given <paramref name="serviceType">service type</paramref>.
            </summary>
      <remarks>By default, each service will be created once per request.</remarks>
      <param name="serviceType">The <see cref="T:System.Type" /> of service to implement.</param>
    </member>
    <member name="M:LinFu.IoC.Configuration.ImplementsAttribute.#ctor(System.Type,LinFu.IoC.Configuration.LifecycleType)">
      <summary>
            Allows users to add services to a container using a 
            given <paramref name="serviceType">service type</paramref> and 
            <paramref name="lifeCycleType">lifecycle type</paramref>.
            </summary>
      <param name="serviceType">The <see cref="T:System.Type" /> of service to implement.</param>
      <param name="lifeCycleType">The instancing behavior to use with this implementation.</param>
    </member>
    <member name="P:LinFu.IoC.Configuration.ImplementsAttribute.ServiceType">
      <summary>
            The type of service that will be implemented.
            </summary>
    </member>
    <member name="P:LinFu.IoC.Configuration.ImplementsAttribute.LifecycleType">
      <summary>
            The instancing behavior of the service instance.        
            </summary>
      <seealso cref="P:LinFu.IoC.Configuration.ImplementsAttribute.LifecycleType" />
    </member>
    <member name="T:LinFu.IoC.Interfaces.IPostProcessor">
      <summary>
            Represents a class that can inspect or modify service requests
            from a given container once a service is created.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Interfaces.IPostProcessor.PostProcess(LinFu.IoC.Interfaces.IServiceRequestResult)">
      <summary>
            Allows a <see cref="T:LinFu.IoC.Interfaces.IPostProcessor" /> instance
            to inspect or modify the result of a service request.
            </summary>
      <seealso cref="T:LinFu.IoC.Interfaces.IServiceRequestResult" />
      <param name="result">The <see cref="T:LinFu.IoC.Interfaces.IServiceRequestResult" /> created as a result of the container operation.</param>
    </member>
    <member name="T:LinFu.IoC.Interfaces.IPreProcessor">
      <summary>
            Represents a class that can inspect or modify service requests
            from a given container before a service is created.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Interfaces.IPreProcessor.Preprocess(LinFu.IoC.Interfaces.IServiceRequest)">
      <summary>
            Allows a <see cref="T:LinFu.IoC.Interfaces.IPostProcessor" /> instance
            to inspect or modify the result of a service request
            just before the service is instantiated.
            </summary>
      <seealso cref="T:LinFu.IoC.Interfaces.IServiceRequestResult" />
      <param name="request">The <see cref="T:LinFu.IoC.Interfaces.IServiceRequest" /> instance that describes the nature of the service that needs to be created. </param>
    </member>
    <member name="T:LinFu.IoC.Interfaces.IServiceContainer">
      <summary>
            An inversion of control container that supports
            named services.
            </summary>
      <seealso name="IContainer" />
    </member>
    <member name="M:LinFu.IoC.Interfaces.IServiceContainer.AddFactory(System.String,System.Type,System.Collections.Generic.IEnumerable{System.Type},LinFu.IoC.Interfaces.IFactory)">
      <summary>
            Adds an <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance and associates it
            with the given <paramref name="serviceType">service type</paramref> and
            <paramref name="serviceName">service name</paramref>.
            </summary>
      <param name="serviceName">The name of the service to associate with the given <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance.</param>
      <param name="serviceType">The type of service that the factory will be able to create.</param>
      <param name="additionalParameterTypes">The list of additional parameters that this factory type will support.</param>
      <param name="factory">The <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance that will create the object instance.</param>
    </member>
    <member name="M:LinFu.IoC.Interfaces.IServiceContainer.Contains(System.String,System.Type,System.Collections.Generic.IEnumerable{System.Type})">
      <summary>
            Determines whether or not a service can be created using
            the given <paramref name="serviceName">service name</paramref>
            and <paramref name="serviceType">service type</paramref>.
            </summary>
      <param name="serviceName">The name of the service to associate with the given <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance.</param>
      <param name="serviceType">The type of service that the factory will be able to create.</param>
      <param name="additionalParameterTypes">The list of additional parameters that the factory type must support.</param>
      <returns>Returns <c>true</c> if the service exists; otherwise, it will return <c>false</c>.</returns>
    </member>
    <member name="M:LinFu.IoC.Interfaces.IServiceContainer.GetService(System.String,System.Type,System.Object[])">
      <summary>
            Causes the container to instantiate the service with the given
            <paramref name="serviceType">service type</paramref>. If the service type cannot be created, then an
            exception will be thrown if the <see cref="P:LinFu.IoC.Interfaces.IContainer.SuppressErrors" /> property
            is set to false. Otherwise, it will simply return null.
            </summary>
      <param name="serviceName">The name of the service to instantiate.</param>
      <param name="serviceType">The service type to instantiate.</param>
      <param name="additionalArguments">The additional arguments that will be used to instantiate the service type.</param>
      <returns>If successful, it will return a service instance that is compatible with the given type;
            otherwise, it will just return a <c>null</c> value.</returns>
    </member>
    <member name="P:LinFu.IoC.Interfaces.IServiceContainer.PreProcessors">
      <summary>
            The list of preprocessors that will handle
            every service request before each actual service is created.
            </summary>
    </member>
    <member name="P:LinFu.IoC.Interfaces.IServiceContainer.PostProcessors">
      <summary>
            The list of postprocessors that will handle every
            service request result.
            </summary>
    </member>
    <member name="T:LinFu.IoC.Interfaces.IServiceInfo">
      <summary>
            A class that describes a single service
            provided by a container.
            </summary>
    </member>
    <member name="P:LinFu.IoC.Interfaces.IServiceInfo.ServiceName">
      <summary>
            The name of the service being created. By default, this property is blank.
            </summary>
    </member>
    <member name="P:LinFu.IoC.Interfaces.IServiceInfo.ServiceType">
      <summary>
            The type of service being requested.
            </summary>
    </member>
    <member name="P:LinFu.IoC.Interfaces.IServiceInfo.ArgumentTypes">
      <summary>
            Gets a value indicating the list of arguments required by this particular service.
            </summary>
    </member>
    <member name="T:LinFu.IoC.Interfaces.IServiceRequest">
      <summary>
            Represents a class that describes the context of a service request made to a service container.
            </summary>
    </member>
    <member name="P:LinFu.IoC.Interfaces.IServiceRequest.Container">
      <summary>
            The container that will handle the service request.
            </summary>
    </member>
    <member name="P:LinFu.IoC.Interfaces.IServiceRequest.ActualArguments">
      <summary>
            Gets or sets the value indicating the actual arguments that
            will be used for the service request.
            </summary>
    </member>
    <member name="P:LinFu.IoC.Interfaces.IServiceRequest.ProposedArguments">
      <summary>
            Gets the value indicating the original arguments that
            were given during the service request.
            </summary>
    </member>
    <member name="P:LinFu.IoC.Interfaces.IServiceRequest.ProposedFactory">
      <summary>
            Gets the value indicating the original <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance
            that will be used to handle the service request.
            </summary>
    </member>
    <member name="P:LinFu.IoC.Interfaces.IServiceRequest.ActualFactory">
      <summary>
            Gets or sets the value indicating the actual <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance
            that will be used to handle the service request.
            </summary>
    </member>
    <member name="T:LinFu.IoC.Interfaces.IServiceRequestResult">
      <summary>
            Represents the results returned when a service request
            is made against an <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" /> instance.
            </summary>
    </member>
    <member name="P:LinFu.IoC.Interfaces.IServiceRequestResult.ServiceName">
      <summary>
            The name of the service being created. By default, this property is blank.
            </summary>
    </member>
    <member name="P:LinFu.IoC.Interfaces.IServiceRequestResult.ServiceType">
      <summary>
            The type of service being requested.
            </summary>
    </member>
    <member name="P:LinFu.IoC.Interfaces.IServiceRequestResult.OriginalResult">
      <summary>
            The raw object reference created by the container itself.
            </summary>
    </member>
    <member name="P:LinFu.IoC.Interfaces.IServiceRequestResult.ActualResult">
      <summary>
            The result that will be returned from the container
            instead of the <see cref="P:LinFu.IoC.Interfaces.IServiceRequestResult.OriginalResult" />. 
            
            If this property is null, then the original result will be used.
            </summary>
    </member>
    <member name="P:LinFu.IoC.Interfaces.IServiceRequestResult.Container">
      <summary>
            The container that will handle the service request.
            </summary>
    </member>
    <member name="P:LinFu.IoC.Interfaces.IServiceRequestResult.AdditionalArguments">
      <summary>
            Gets the value indicating the additional arguments that
            were used during the service request.
            </summary>
    </member>
    <member name="T:LinFu.IoC.Configuration.LifecycleType">
      <summary>
            An enumeration that denotes the instance behavior
            of a particular object reference.
            </summary>
    </member>
    <member name="F:LinFu.IoC.Configuration.LifecycleType.OncePerRequest">
      <summary>
            This means that a new object instance 
            will be created on each call.
            </summary>
    </member>
    <member name="F:LinFu.IoC.Configuration.LifecycleType.OncePerThread">
      <summary>
            This means that a new object instance 
            will be created only once per thread.
            </summary>
    </member>
    <member name="F:LinFu.IoC.Configuration.LifecycleType.Singleton">
      <summary>
            This means that only a single object instance
            will ever be created in spite of the number of
            subsequent requests for a new object instance.
            </summary>
    </member>
    <member name="T:LinFu.IoC.CompositePostProcessor">
      <summary>
            Represents an <see cref="T:LinFu.IoC.Interfaces.IPostProcessor" /> type that processes multiple <see cref="T:LinFu.IoC.Interfaces.IPostProcessor" /> instances at once.
            </summary>
    </member>
    <member name="M:LinFu.IoC.CompositePostProcessor.#ctor(System.Collections.Generic.IEnumerable{LinFu.IoC.Interfaces.IPostProcessor})">
      <summary>
            Initializes the type using the given <paramref name="postProcessors" />.
            </summary>
      <param name="postProcessors">The list of <see cref="T:LinFu.IoC.Interfaces.IPostProcessor" /> instances that will be handled by this type.</param>
    </member>
    <member name="M:LinFu.IoC.CompositePostProcessor.PostProcess(LinFu.IoC.Interfaces.IServiceRequestResult)">
      <summary>
            A method that passes every request result made
            to the list of postprocessors.
            </summary>
      <param name="result">The <see cref="T:LinFu.IoC.Interfaces.IServiceRequestResult" /> instance that describes the result of the service request.</param>
      <returns>A <see cref="T:LinFu.IoC.Interfaces.IServiceRequestResult" /> representing the results returned as a result of the postprocessors.</returns>
    </member>
    <member name="T:LinFu.IoC.CompositePreProcessor">
      <summary>
            Represents an <see cref="T:LinFu.IoC.Interfaces.IPreProcessor" /> type that processes multiple <see cref="T:LinFu.IoC.Interfaces.IPreProcessor" /> instances at once.
            </summary>
    </member>
    <member name="M:LinFu.IoC.CompositePreProcessor.#ctor(System.Collections.Generic.IEnumerable{LinFu.IoC.Interfaces.IPreProcessor})">
      <summary>
            Initializes the type using the given <paramref name="preProcessors" />.
            </summary>
      <param name="preProcessors">The list of <see cref="T:LinFu.IoC.Interfaces.IPreProcessor" /> instances that will be handled by this type.</param>
    </member>
    <member name="M:LinFu.IoC.CompositePreProcessor.Preprocess(LinFu.IoC.Interfaces.IServiceRequest)">
      <summary>
            A method that passes every request result made
            to the list of preprocessors.
            </summary>
      <param name="request">The parameter that describes the context of the service request.</param>
    </member>
    <member name="T:LinFu.IoC.Configuration.Interfaces.IContainerActivationContext">
      <summary>
            Represents a class that describes a request to instantiate a particular object type using a given
            <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" /> instance.
            </summary>
    </member>
    <member name="P:LinFu.IoC.Configuration.Interfaces.IContainerActivationContext.Container">
      <summary>
            Gets the value indicating the <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" /> instance
            that will instantiate the <see cref="P:LinFu.AOP.Interfaces.IActivationContext.TargetType" />.
            </summary>
    </member>
    <member name="T:LinFu.IoC.Configuration.ContainerActivationContext">
      <summary>
            Represents a class that describes a request to instantiate a particular object type using a given
            <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" /> instance.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.ContainerActivationContext.#ctor(System.Type,LinFu.IoC.Interfaces.IServiceContainer,System.Object[])">
      <summary>
            Initializes the class with the given parameters.
            </summary>
      <param name="concreteType">The type to be instantiated.</param>
      <param name="container">The container that will be used to instantiate the target type.</param>
      <param name="additionalArguments">The additional arguments that must be passed to the constructor.</param>
    </member>
    <member name="P:LinFu.IoC.Configuration.ContainerActivationContext.Container">
      <summary>
            Gets the value indicating the <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" /> instance
            that will instantiate the <see cref="P:LinFu.AOP.Interfaces.IActivationContext.TargetType" />.
            </summary>
    </member>
    <member name="T:LinFu.IoC.Configuration.DefaultActivator">
      <summary>
            Represents a class that can instantiate object instances.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.DefaultActivator.CreateInstance(LinFu.IoC.Configuration.Interfaces.IContainerActivationContext)">
      <summary>
            Creates an object instance.
            </summary>
      <returns>A valid object instance.</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.DefaultActivator.GetMissingParameterTypes(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Object})">
      <summary>
            Determines which parameter types need to be supplied to invoke a particular
            <paramref name="constructor" />  instance.
            </summary>
      <param name="constructor">The target constructor.</param>
      <param name="additionalArguments">The additional arguments that will be used to invoke the constructor.</param>
      <returns>The list of parameter types that are still missing parameter values.</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.DefaultActivator.Initialize(LinFu.IoC.Interfaces.IServiceContainer)">
      <summary>
            Initializes the class with the default services.
            </summary>
      <param name="container">The target service container.</param>
    </member>
    <member name="T:LinFu.IoC.Configuration.InjectAttribute">
      <summary>
            The attribute used to mark a property for autoinjection.
            </summary>
    </member>
    <member name="T:LinFu.IoC.Configuration.PostProcessorAttribute">
      <summary>
            Marks a target type as an <see cref="T:LinFu.IoC.Interfaces.IPostProcessor" />
            instance that can be injected into a
            <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" /> instance.
            </summary>
    </member>
    <member name="T:LinFu.IoC.Configuration.PreprocessorAttribute">
      <summary>
            Marks a target type as an <see cref="T:LinFu.IoC.Interfaces.IPreProcessor" />
            instance that can be injected into a
            <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" /> instance.
            </summary>
    </member>
    <member name="T:LinFu.IoC.Configuration.Interfaces.IMethodBuilder`1">
      <summary>
            Represents a class that is responsible for generating methods
            from other existing methods.
            </summary>
      <typeparam name="TMethod">The method type to generate.</typeparam>
    </member>
    <member name="M:LinFu.IoC.Configuration.Interfaces.IMethodBuilder`1.CreateMethod(`0)">
      <summary>
            Creates a method from the <paramref name="existingMethod" />.
            </summary>
      <param name="existingMethod">The method that will be used to define the new method.</param>
      <returns>A method based on the old method.</returns>
    </member>
    <member name="T:LinFu.IoC.Configuration.BaseMethodBuilder`1">
      <summary>
            Represents the default implementation of the <see cref="T:LinFu.IoC.Configuration.Interfaces.IMethodBuilder`1" /> interface.
            </summary>
      <typeparam name="TMethod">The method type to generate.</typeparam>
    </member>
    <member name="M:LinFu.IoC.Configuration.BaseMethodBuilder`1.CreateMethod(`0)">
      <summary>
            Creates a method from the <paramref name="existingMethod" />.
            </summary>
      <param name="existingMethod">The method that will be used to define the new method.</param>
      <returns>A method based on the old method.</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.BaseMethodBuilder`1.PushMethodArguments(System.Reflection.Emit.ILGenerator,System.Reflection.MethodBase)">
      <summary>
            Pushes the method arguments onto the stack.
            </summary>
      <param name="IL">The <see cref="T:System.Reflection.Emit.ILGenerator" /> of the target method body.</param>
      <param name="targetMethod">The target method that will be invoked.</param>
    </member>
    <member name="M:LinFu.IoC.Configuration.BaseMethodBuilder`1.GetParameterList(`0,System.Type[])">
      <summary>
            Determines the parameter types of the dynamically generated method.
            </summary>
      <param name="existingMethod">The target method.</param>
      <param name="parameterTypes">The target method argument types.</param>
      <returns>The list of <see cref="T:System.Type" /> objects that describe the signature of the method to generate.</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.BaseMethodBuilder`1.PushInstance(System.Reflection.Emit.ILGenerator,`0)">
      <summary>
            Pushes the method target onto the stack.
            </summary>
      <param name="IL">The <see cref="T:System.Reflection.Emit.ILGenerator" /> that belongs to the method body.</param>
      <param name="method">The current method.</param>
    </member>
    <member name="M:LinFu.IoC.Configuration.BaseMethodBuilder`1.GetReturnType(`0)">
      <summary>
            Determines the return type from the target <paramref name="method" />.
            </summary>
      <param name="method">The target method itself.</param>
      <returns>The method return type.</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.BaseMethodBuilder`1.EmitCall(System.Reflection.Emit.ILGenerator,`0)">
      <summary>
            Emits the instruction to call the target <paramref name="method" /></summary>
      <param name="IL">The <see cref="T:System.Reflection.Emit.ILGenerator" /> of the target method body.</param>
      <param name="method">The method that will be invoked.</param>
    </member>
    <member name="T:LinFu.IoC.Configuration.Interfaces.IMethodInvoke`1">
      <summary>
            Represents a type that can invoke a method
            using a given set of method arguments.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.Interfaces.IMethodInvoke`1.Invoke(System.Object,`0,System.Object[])">
      <summary>
            Invokes the <paramref name="targetMethod" />
            using the given <paramref name="arguments" />.
            </summary>
      <param name="target">The target object instance.</param>
      <param name="targetMethod">The target method to invoke.</param>
      <param name="arguments">The arguments to be used with the method.</param>
      <returns>The method return value.</returns>
    </member>
    <member name="T:LinFu.IoC.Configuration.BaseMethodInvoke`1">
      <summary>
            Represents the default implementation of the <see cref="T:LinFu.IoC.Configuration.Interfaces.IMethodInvoke`1" /> interface.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.BaseMethodInvoke`1.#ctor">
      <summary>
            Initializes the class with the default values.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.BaseMethodInvoke`1.Invoke(System.Object,`0,System.Object[])">
      <summary>
            Instantiates an object instance with the <paramref name="targetMethod" />
            and <paramref name="arguments" />.
            </summary>
      <param name="target">The target object reference. In this particular case, this parameter will be ignored.</param>
      <param name="targetMethod">The target method.</param>
      <param name="arguments">The arguments to be used with the method.</param>
      <returns>An object reference that represents the method return value.</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.BaseMethodInvoke`1.DoInvoke(System.Object,`0,System.Reflection.MethodBase,System.Object[])">
      <summary>
            Invokes the <paramref name="targetMethod" /> with the given <paramref name="arguments" />.
            </summary>
      <param name="target">The target instance.</param>
      <param name="originalMethod">The original method that describes the target method.</param>
      <param name="targetMethod">The actual method that will be invoked.</param>
      <param name="arguments">The method arguments.</param>
      <returns>The return value from the target method.</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.BaseMethodInvoke`1.GenerateTargetMethod(`0)">
      <summary>
            Creates a <see cref="T:System.Reflection.Emit.DynamicMethod" /> that will be used as the 
            factory method and stores it in the method cache.
            </summary>
      <param name="targetMethod">The constructor that will be used to instantiate the target type.</param>
    </member>
    <member name="M:LinFu.IoC.Configuration.BaseMethodInvoke`1.Initialize(LinFu.IoC.Interfaces.IServiceContainer)">
      <summary>
            Initializes the class with the <paramref name="source">source service container.</paramref></summary>
      <param name="source">The <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" /> instance that will initialize this class.</param>
    </member>
    <member name="P:LinFu.IoC.Configuration.BaseMethodInvoke`1.MethodBuilder">
      <summary>
            Gets or sets the value indicating the method builder that will be used to
            create the target method.
            </summary>
    </member>
    <member name="T:LinFu.IoC.Configuration.ConstructorInvoke">
      <summary>
            A class that invokes constructor instances.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.ConstructorInvoke.#ctor">
      <summary>
            Initializes the class with the default values.
            </summary>
    </member>
    <member name="T:LinFu.IoC.Configuration.ConstructorMethodBuilder">
      <summary>
            A method builder that generates dynamic methods using existing constructors.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.ConstructorMethodBuilder.GetReturnType(System.Reflection.ConstructorInfo)">
      <summary>
            Returns the declaring type of the target constructor.
            </summary>
      <param name="constructor">
      </param>
      <returns>The declaring type of the target constructor.</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.ConstructorMethodBuilder.EmitCall(System.Reflection.Emit.ILGenerator,System.Reflection.ConstructorInfo)">
      <summary>
            Emits an instruction that instantiates the type associated with the
            <paramref name="constructor" />.
            </summary>
      <param name="IL">The <see cref="T:System.Reflection.Emit.ILGenerator" /> of the target method body.</param>
      <param name="constructor">The target constructor.</param>
    </member>
    <member name="T:LinFu.IoC.ContainerExtensions">
      <summary>
            A class that adds generics support to existing 
            <see cref="T:LinFu.IoC.Interfaces.IContainer" /> and <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" />
            instances.
            </summary>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.LoadFrom(LinFu.IoC.Interfaces.IServiceContainer,LinFu.Reflection.IAssemblyLoader,System.String,System.String,LinFu.Reflection.ILoader{LinFu.IoC.Interfaces.IServiceContainer})">
      <summary>
            Loads a set of <paramref name="searchPattern">files</paramref> from the <paramref name="directory">target directory</paramref>
            using a custom <see cref="T:LinFu.Reflection.IAssemblyLoader" /> instance.
            </summary>
      <param name="container">The container to be loaded.</param>
      <param name="assemblyLoader">The custom <see cref="T:LinFu.Reflection.IAssemblyLoader" /> that will be used to load the target assemblies from disk.</param>
      <param name="directory">The target directory.</param>
      <param name="searchPattern">The search pattern that describes the list of files to be loaded.</param>
      <param name="customLoader">The custom loader that will be used to load the container.</param>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.LoadFrom(LinFu.IoC.Interfaces.IServiceContainer,LinFu.Reflection.IAssemblyLoader,System.String,System.String)">
      <summary>
            Loads a set of <paramref name="searchPattern">files</paramref> from the <paramref name="directory">target directory</paramref>
            using a custom <see cref="T:LinFu.Reflection.IAssemblyLoader" /> instance.
            </summary>
      <param name="container">The container to be loaded.</param>
      <param name="assemblyLoader">The custom <see cref="T:LinFu.Reflection.IAssemblyLoader" /> that will be used to load the target assemblies from disk.</param>
      <param name="directory">The target directory.</param>
      <param name="searchPattern">The search pattern that describes the list of files to be loaded.</param>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.LoadFrom(LinFu.IoC.Interfaces.IServiceContainer,System.String,System.String,LinFu.Reflection.ILoader{LinFu.IoC.Interfaces.IServiceContainer})">
      <summary>
            Loads a set of <paramref name="searchPattern">files</paramref> from the <paramref name="directory">target directory</paramref>.
            </summary>
      <param name="container">The container to be loaded.</param>
      <param name="directory">The target directory.</param>
      <param name="searchPattern">The search pattern that describes the list of files to be loaded.</param>
      <param name="customLoader">The custom loader that will be used to load the container.</param>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.LoadFrom(LinFu.IoC.Interfaces.IServiceContainer,System.String,System.String)">
      <summary>
            Loads a set of <paramref name="searchPattern">files</paramref> from the <paramref name="directory">target directory</paramref>.
            </summary>
      <param name="container">The container to be loaded.</param>
      <param name="directory">The target directory.</param>
      <param name="searchPattern">The search pattern that describes the list of files to be loaded.</param>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.LoadFromBaseDirectory(LinFu.IoC.Interfaces.IServiceContainer,System.String)">
      <summary>
            Loads a set of <paramref name="searchPattern">files</paramref> from the application base directory.
            </summary>
      <param name="container">The container to be loaded.</param>
      <param name="searchPattern">The search pattern that describes the list of files to be loaded.</param>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.AutoCreateFrom(System.Type,LinFu.IoC.Interfaces.IServiceContainer,System.Object[])">
      <summary>
            Automatically instantiates a <paramref name="concreteType" />
            with the constructor with the most resolvable parameters from
            the given <paramref name="container" /> instance.
            </summary>
      <remarks>
            This method only performs constructor injection on the target type. If you need any other form of injection (such as property injection), you'll need to 
            register your type and instantiate it with the <see cref="M:LinFu.IoC.ContainerExtensions.GetService``1(LinFu.IoC.Interfaces.IServiceContainer,System.Object[])" /> method.
            </remarks>
      <param name="container">The service container that contains the arguments that will automatically be injected into the constructor.</param>
      <param name="concreteType">The type to instantiate.</param>
      <param name="additionalArguments">The list of arguments to pass to the target type.</param>
      <returns>A valid, non-null object reference.</returns>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.LoadFrom(LinFu.IoC.Interfaces.IServiceContainer,System.Reflection.Assembly)">
      <summary>
            Loads an existing <paramref name="assembly" /> into the container.
            </summary>
      <param name="container">The target container to be configured.</param>
      <param name="assembly">The assembly to be loaded.</param>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.CreateDefaultContainerLoader(LinFu.Reflection.ILoader{LinFu.IoC.Interfaces.IServiceContainer})">
      <summary>
            Generates the default <see cref="T:LinFu.IoC.Configuration.AssemblyContainerLoader" /> for a <see cref="T:LinFu.IoC.Configuration.Loader" /> class instance.
            </summary>
      <param name="loader">The loader that will load the target container.</param>
      <returns>A valid <see cref="T:LinFu.IoC.Configuration.AssemblyContainerLoader" /> instance.</returns>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.SetCustomPropertyInjectionAttribute(LinFu.IoC.Interfaces.IServiceContainer,System.Type)">
      <summary>
            Sets the custom attribute type that will be used to mark properties
            for automatic injection.
            </summary>
      <param name="container">The target <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" /> instance.</param>
      <param name="attributeType">The custom property attribute that will be used to mark properties for injection.</param>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.SetCustomMethodInjectionAttribute(LinFu.IoC.Interfaces.IServiceContainer,System.Type)">
      <summary>
            Sets the custom attribute type that will be used to mark methods
            for automatic injection.
            </summary>
      <param name="container">The target <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" /> instance.</param>
      <param name="attributeType">The custom property attribute that will be used to mark method for injection.</param>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.SetCustomFieldInjectionAttribute(LinFu.IoC.Interfaces.IServiceContainer,System.Type)">
      <summary>
            Sets the custom attribute type that will be used to mark fields
            for automatic injection.
            </summary>
      <param name="container">The target <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" /> instance.</param>
      <param name="attributeType">The custom property attribute that will be used to mark fields for injection.</param>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.Initialize(LinFu.IoC.Interfaces.IServiceContainer)">
      <summary>
            Initializes the target <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" />
            with the default services.
            </summary>
      <param name="container">
      </param>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.AutoCreate(LinFu.IoC.Interfaces.IServiceContainer,System.Type,System.Object[])">
      <summary>
            Automatically instantiates a <paramref name="concreteType" />
            with the constructor with the most resolvable parameters from
            the given <paramref name="container" /> instance.
            </summary>
      <param name="container">The service container that contains the arguments that will automatically be injected into the constructor.</param>
      <param name="concreteType">The type to instantiate.</param>
      <param name="additionalArguments">The list of arguments to pass to the target type.</param>
      <returns>A valid, non-null object reference.</returns>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.PostProcess(LinFu.IoC.Interfaces.IServiceContainer,System.Type,System.Object,System.Object[])">
      <summary>
            Postprocesses an object instance as if it were created from the target <paramref name="container" />.
            </summary>
      <param name="container">The container that will postprocess the target <paramref name="instance" />.</param>
      <param name="concreteType">The type being processed.</param>
      <param name="instance">The target instance to be processed.</param>
      <param name="additionalArguments">The list of arguments to pass to the target type.</param>
      <returns>A valid, non-null object reference.</returns>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.AutoCreateInternal(LinFu.IoC.Interfaces.IServiceContainer,System.Type,System.Object[])">
      <summary>
            Automatically instantiates a <paramref name="concreteType" />
            with the constructor with the most resolvable parameters from
            the given <paramref name="container" /> instance.
            </summary>
      <remarks>
            This method only performs constructor injection on the target type. If you need any other form of injection (such as property injection), you'll need to 
            register your type and instantiate it with the <see cref="M:LinFu.IoC.ContainerExtensions.GetService``1(LinFu.IoC.Interfaces.IServiceContainer,System.Object[])" /> method.
            </remarks>
      <param name="container">The service container that contains the arguments that will automatically be injected into the constructor.</param>
      <param name="concreteType">The type to instantiate.</param>
      <param name="additionalArguments">The list of arguments to pass to the target type.</param>
      <returns>A valid, non-null object reference.</returns>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.AddDefaultServices(LinFu.IoC.Interfaces.IServiceContainer)">
      <summary>
            Initializes the container with the minimum required services.
            </summary>
      <param name="container">The target service container.</param>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.GetService``1(LinFu.IoC.Interfaces.IServiceContainer,System.Object[])">
      <summary>
            Creates an instance of <typeparamref name="T" />
            using the given <paramref name="container" />.
            </summary>
      <typeparam name="T">The service type to create.</typeparam>
      <param name="container">The container that will instantiate the service.</param>
      <param name="additionalArguments">The additional arguments that will be used to construct the service type.</param>
      <returns>If successful, it will return a service instance that is compatible with the given type;
            otherwise, it will just return a <c>null</c> value.</returns>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.GetService(LinFu.IoC.Interfaces.IServiceContainer,LinFu.IoC.Interfaces.IServiceInfo,System.Object[])">
      <summary>
            Instantiates a service that matches the <paramref name="info">service description</paramref>.
            </summary>
      <param name="container">The container that will instantiate the service.</param>
      <param name="info">The description of the requested service.</param>
      <param name="additionalArguments">The additional arguments that will be used to construct the service type.</param>
      <returns>If successful, it will return a service instance that is compatible with the given type;
            otherwise, it will just return a <c>null</c> value.</returns>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.GetService``1(LinFu.IoC.Interfaces.IServiceContainer,System.String,System.Object[])">
      <summary>
            Creates an instance of <typeparamref name="T" />
            using the given <paramref name="container" />.
            </summary>
      <typeparam name="T">The service type to create.</typeparam>
      <param name="container">The container that will instantiate the service.</param>
      <param name="serviceName">The name of the service to instantiate.</param>
      <param name="additionalArguments">The additional arguments that will be used to construct the service type.</param>
      <returns>If successful, it will return a service instance that is compatible with the given type;
            otherwise, it will just return a <c>null</c> value.</returns>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.AddService(LinFu.IoC.Interfaces.IServiceContainer,System.Type,System.Type)">
      <summary>
            Configures the container to instantiate the <paramref name="implementingType" />
            on every request for the <paramref name="serviceType" />.
            </summary>
      <param name="container">The container that will hold the service type.</param>
      <param name="serviceType">The type of service being implemented.</param>
      <param name="implementingType">The concrete type that will implement the service type.</param>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.AddService(LinFu.IoC.Interfaces.IServiceContainer,System.Type,LinFu.IoC.Configuration.LifecycleType)">
      <summary>
            Registers the <paramref name="serviceTypeToRegisterAsSelf">service type</paramref>
            as both the implementing type and the service type using the given <paramref name="lifecycle" />.
            </summary>
      <param name="container">The container that will hold the service type.</param>
      <param name="serviceTypeToRegisterAsSelf">The service type that will be registered as both the service type and the implementing type.</param>
      <param name="lifecycle">The service <see cref="T:LinFu.IoC.Configuration.LifecycleType" />.</param>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.AddService(LinFu.IoC.Interfaces.IServiceContainer,System.Type)">
      <summary>
            Registers the <paramref name="serviceTypeToRegisterAsSelf">service type</paramref>
            as both the implementing type and the service type.
            </summary>
      <param name="container">The container that will hold the service type.</param>
      <param name="serviceTypeToRegisterAsSelf">The service type that will be registered as both the service type and the implementing type.</param>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.AddService(LinFu.IoC.Interfaces.IServiceContainer,System.Type,System.Type,LinFu.IoC.Configuration.LifecycleType)">
      <summary>
            Configures the container to instantiate the <paramref name="implementingType" />
            on every request for the <paramref name="serviceType" />.
            </summary>
      <param name="container">The container that will hold the service type.</param>
      <param name="serviceType">The type of service being implemented.</param>
      <param name="implementingType">The concrete type that will implement the service type.</param>
      <param name="lifecycle">The service <see cref="T:LinFu.IoC.Configuration.LifecycleType" />.</param>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.AddService(LinFu.IoC.Interfaces.IServiceContainer,System.String,System.Type,System.Object)">
      <summary>
            Registers an existing service instance with the container using the given
            <paramref name="serviceName" /> and <paramref name="serviceType" />.
            </summary>
      <param name="container">The target container instance.</param>
      <param name="serviceName">The service name that will be associated with the service instance.</param>
      <param name="serviceType">The target service type.</param>
      <param name="serviceInstance">The actual service instance that will represent the service type.</param>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.AddService(LinFu.IoC.Interfaces.IServiceContainer,System.Type,System.Object)">
      <summary>
            Registers an existing service instance with the container using the given
            <paramref name="serviceType" />.
            </summary>
      <param name="container">The target container instance.</param>
      <param name="serviceType">The target service type.</param>
      <param name="serviceInstance">The actual service instance that will represent the service type.</param>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.AddService(LinFu.IoC.Interfaces.IServiceContainer,System.String,System.Type,System.Type,LinFu.IoC.Configuration.LifecycleType)">
      <summary>
            Configures the container to instantiate the <paramref name="implementingType" />
            on every request for the <paramref name="serviceType" />.
            </summary>
      <param name="serviceName">The name of the service to associate with the given <paramref name="serviceType" />.</param>
      <param name="container">The container that will hold the service type.</param>
      <param name="serviceType">The type of service being implemented.</param>
      <param name="implementingType">The concrete type that will implement the service type.</param>
      <param name="lifecycle">The service <see cref="T:LinFu.IoC.Configuration.LifecycleType" />.</param>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.AddFactory``1(LinFu.IoC.Interfaces.IServiceContainer,System.String,LinFu.IoC.Interfaces.IFactory{``0})">
      <summary>
            Adds an <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance and associates it
            with the given <typeparamref name="T">service type</typeparamref> and
            <paramref name="serviceName">service name</paramref>.
            </summary>
      <param name="serviceName">The name of the service to associate with the given <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance.</param>
      <param name="container">The container that will hold the factory instance.</param>
      <param name="factory">The <see cref="T:LinFu.IoC.Interfaces.IFactory`1" /> instance that will create the object instance.</param>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.AddFactory``1(LinFu.IoC.Interfaces.IServiceContainer,LinFu.IoC.Interfaces.IFactory{``0})">
      <summary>
            Adds an <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance and associates it
            with the given <typeparamref name="T">service type</typeparamref>.
            </summary>
      <param name="container">The container that will hold the factory instance.</param>
      <param name="factory">The <see cref="T:LinFu.IoC.Interfaces.IFactory`1" /> instance that will create the object instance.</param>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.AddFactory(LinFu.IoC.Interfaces.IServiceContainer,System.String,System.Type,LinFu.IoC.Interfaces.IFactory)">
      <summary>
            Adds an <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance and associates it with the given
            <paramref name="serviceName" /> and <paramref name="serviceType" /></summary>
      <param name="container">The target container.</param>
      <param name="serviceName">The service name.</param>
      <param name="serviceType">The service type.</param>
      <param name="factory">The factory instance that will be responsible for creating the service itself.</param>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.AddFactory(LinFu.IoC.Interfaces.IServiceContainer,System.Type,LinFu.IoC.Interfaces.IFactory)">
      <summary>
            Adds an <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance and associates it with the given
            <paramref name="serviceType" /></summary>
      <param name="container">The target container.</param>
      <param name="serviceType">The service type.</param>
      <param name="factory">The factory instance that will be responsible for creating the service itself.</param>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.AddDefaultFactory(LinFu.IoC.Interfaces.IServiceContainer,System.Type,LinFu.IoC.Interfaces.IFactory)">
      <summary>
            Registers the <paramref name="factory" /> as the default factory instance
            that will be used if no other factory can be found for the current <paramref name="serviceType" />.
            </summary>
      <param name="container">The host container.</param>
      <param name="serviceType">The service type that will be created by the default factory.</param>
      <param name="factory">The <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance that will be used if no other factories can create the given service type.</param>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.AddService``1(LinFu.IoC.Interfaces.IServiceContainer,System.String,System.Func{``0})">
      <summary>
            Adds a service to the container by using the given <paramref name="factoryMethod" /> 
            to instantiate the service instance.
            </summary>
      <typeparam name="TResult">The service type itself.</typeparam>
      <param name="serviceName">The name that will be associated with the service instance.</param>
      <param name="container">The host container that will instantiate the service type.</param>
      <param name="factoryMethod">The factory method that will be used to create the actual service instance.</param>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.AddService``2(LinFu.IoC.Interfaces.IServiceContainer,System.String,System.Func{``0,``1})">
      <summary>
            Adds a service to the container by using the given <paramref name="factoryMethod" /> 
            to instantiate the service instance.
            </summary>
      <typeparam name="TResult">The service type itself.</typeparam>
      <typeparam name="T1">The first parameter type of the <paramref name="factoryMethod" />.</typeparam>
      <param name="serviceName">The name that will be associated with the service instance.</param>
      <param name="container">The host container that will instantiate the service type.</param>
      <param name="factoryMethod">The factory method that will be used to create the actual service instance.</param>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.AddService(LinFu.IoC.Interfaces.IServiceContainer,System.String,System.Type,System.MulticastDelegate)">
      <summary>
            Adds a service to the container by using the given <paramref name="factoryMethod" /> 
            to instantiate the service instance.
            </summary>
      <param name="serviceName">The name that will be associated with the service instance.</param>
      <param name="container">The host container that will instantiate the service type.</param>
      <param name="factoryMethod">The factory method that will be used to create the actual service instance.</param>
      <param name="serviceType">The service type that will be implemented.</param>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.AddService``3(LinFu.IoC.Interfaces.IServiceContainer,System.String,System.Func{``0,``1,``2})">
      <summary>
            Adds a service to the container by using the given <paramref name="factoryMethod" /> 
            to instantiate the service instance.
            </summary>
      <typeparam name="TResult">The service type itself.</typeparam>
      <typeparam name="T1">The first parameter type of the <paramref name="factoryMethod" />.</typeparam>
      <typeparam name="T2">The second parameter type of the <paramref name="factoryMethod" />.</typeparam>
      <param name="serviceName">The name that will be associated with the service instance.</param>
      <param name="container">The host container that will instantiate the service type.</param>
      <param name="factoryMethod">The factory method that will be used to create the actual service instance.</param>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.AddService``5(LinFu.IoC.Interfaces.IServiceContainer,System.String,System.Func{``0,``1,``2,``3,``4})">
      <summary>
            Adds a service to the container by using the given <paramref name="factoryMethod" /> 
            to instantiate the service instance.
            </summary>
      <typeparam name="TResult">The service type itself.</typeparam>
      <typeparam name="T1">The first parameter type of the <paramref name="factoryMethod" />.</typeparam>
      <typeparam name="T2">The second parameter type of the <paramref name="factoryMethod" />.</typeparam>
      <typeparam name="T3">The third parameter type of the <paramref name="factoryMethod" />.</typeparam>
      <typeparam name="T4">The third parameter type of the <paramref name="factoryMethod" />.</typeparam>
      <param name="serviceName">The name that will be associated with the service instance.</param>
      <param name="container">The host container that will instantiate the service type.</param>
      <param name="factoryMethod">The factory method that will be used to create the actual service instance.</param>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.AddService``4(LinFu.IoC.Interfaces.IServiceContainer,System.String,System.Func{``0,``1,``2,``3})">
      <summary>
            Adds a service to the container by using the given <paramref name="factoryMethod" /> 
            to instantiate the service instance.
            </summary>
      <typeparam name="TResult">The service type itself.</typeparam>
      <typeparam name="T1">The first parameter type of the <paramref name="factoryMethod" />.</typeparam>
      <typeparam name="T2">The second parameter type of the <paramref name="factoryMethod" />.</typeparam>
      <typeparam name="T3">The third parameter type of the <paramref name="factoryMethod" />.</typeparam>
      <param name="serviceName">The name that will be associated with the service instance.</param>
      <param name="container">The host container that will instantiate the service type.</param>
      <param name="factoryMethod">The factory method that will be used to create the actual service instance.</param>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.AddService``1(LinFu.IoC.Interfaces.IServiceContainer,System.String,System.Func{LinFu.IoC.Interfaces.IFactoryRequest,``0},LinFu.IoC.Configuration.LifecycleType)">
      <summary>
            Adds a service to the container by using the given <paramref name="factoryMethod" /> and <paramref name="lifecycleType" />
            to instantiate the service instance.
            </summary>
      <typeparam name="T">The service type itself.</typeparam>
      <param name="serviceName">The name that will be associated with the service instance.</param>
      <param name="container">The host container that will instantiate the service type.</param>
      <param name="factoryMethod">The factory method that will be used to create the actual service instance.</param>
      <param name="lifecycleType">The service <see cref="T:LinFu.IoC.Configuration.LifecycleType" /> type.</param>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.AddService``1(LinFu.IoC.Interfaces.IServiceContainer,System.Func{LinFu.IoC.Interfaces.IFactoryRequest,``0},LinFu.IoC.Configuration.LifecycleType)">
      <summary>
            Adds a service to the container by using the given <paramref name="factoryMethod" /> and <paramref name="lifecycleType" />
            to instantiate the service instance.
            </summary>
      <typeparam name="T">The service type itself.</typeparam>
      <param name="container">The host container that will instantiate the service type.</param>
      <param name="factoryMethod">The factory method that will be used to create the actual service instance.</param>
      <param name="lifecycleType">The service <see cref="T:LinFu.IoC.Configuration.LifecycleType" /> type.</param>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.AddService``1(LinFu.IoC.Interfaces.IServiceContainer,``0)">
      <summary>
            Adds an existing service instance to the container.
            </summary>
      <typeparam name="T">The type of service being added.</typeparam>
      <param name="container">The container that will hold the service instance.</param>
      <param name="instance">The service instance itself.</param>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.AddService``1(LinFu.IoC.Interfaces.IServiceContainer,System.String,``0)">
      <summary>
            Adds an existing service instance to the container and
            associates it with the <paramref name="serviceName" />.
            </summary>
      <typeparam name="T">The type of service being added.</typeparam>
      <param name="container">The container that will hold the service instance.</param>
      <param name="serviceName">The name that will be associated with the service instance.</param>
      <param name="instance">The service instance itself.</param>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.GetServices``1(LinFu.IoC.Interfaces.IServiceContainer,System.Object[])">
      <summary>
            Returns all the services in the container that match the given
            <typeparamref name="T">service type</typeparamref>.
            </summary>
      <typeparam name="T">The type of service to return.</typeparam>
      <param name="container">The target container.</param>
      <param name="additionalArguments">The additional arguments that will be used to construct the service type.</param>
      <returns>The list of services that implement the given service type.</returns>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.GetServices(LinFu.IoC.Interfaces.IServiceContainer,System.Func{LinFu.IoC.Interfaces.IServiceInfo,System.Boolean},System.Object[])">
      <summary>
            Returns a list of services that match the given <paramref name="condition" />.
            </summary>
      <param name="condition">The predicate that determines which services should be returned.</param>
      <returns>A list of <see cref="T:LinFu.IoC.Interfaces.IServiceInstance" /> objects that describe the services returned as well as provide a reference to the resulting services themselves.</returns>
      <param name="container">the target <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" /> instance.</param>
      <param name="additionalArguments">The additional arguments that will be used to construct the service type.</param>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.Contains(LinFu.IoC.Interfaces.IServiceContainer,System.String,System.Type,System.Object[])">
      <summary>
            Determines whether or not the container can instantiate the given <paramref name="serviceName" />
            and <paramref name="serviceType" /> using the given <paramref name="sampleArguments" />.
            </summary>
      <param name="container">The target container.</param>
      <param name="serviceName">The name of the requested service.</param>
      <param name="serviceType">The requested service type.</param>
      <param name="sampleArguments">The potential arguments for the service type.</param>
      <returns>Returns <c>true</c> if the requested services exist; otherwise, it will return <c>false</c>.</returns>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.Contains(LinFu.IoC.Interfaces.IServiceContainer,System.Type)">
      <summary>
            Determines whether or not the container contains a service that matches
            the given <paramref name="serviceType" />.
            </summary>
      <param name="container">The target container.</param>
      <param name="serviceType">The requested service type.</param>
      <returns>Returns <c>true</c> if the requested services exist; otherwise, it will return <c>false</c>.</returns>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.Contains(LinFu.IoC.Interfaces.IServiceContainer,System.String,System.Type)">
      <summary>
            Determines whether or not the container contains a service that matches
            the given <paramref name="serviceType" />.
            </summary>
      <param name="container">The target container.</param>
      <param name="serviceName">The requested service name.</param>
      <param name="serviceType">The requested service type.</param>
      <returns>Returns <c>true</c> if the requested services exist; otherwise, it will return <c>false</c>.</returns>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.Contains(LinFu.IoC.Interfaces.IServiceContainer,System.Func{LinFu.IoC.Interfaces.IServiceInfo,System.Boolean})">
      <summary>
            Determines whether or not a container contains services that match
            the given <paramref name="condition" />.
            </summary>
      <param name="container">The target container.</param>
      <param name="condition">The predicate that will be used to determine whether or not the requested services exist.</param>
      <returns>Returns <c>true</c> if the requested services exist; otherwise, it will return <c>false</c>.</returns>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.DisableAutoPropertyInjection(LinFu.IoC.Interfaces.IServiceContainer)">
      <summary>
            Disables automatic property injection for the <paramref name="container" />.
            </summary>
      <param name="container">The target container.</param>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.DisableAutoMethodInjection(LinFu.IoC.Interfaces.IServiceContainer)">
      <summary>
            Disables automatic method injection for the <paramref name="container" />.
            </summary>
      <param name="container">The target container.</param>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.DisableAutoFieldInjection(LinFu.IoC.Interfaces.IServiceContainer)">
      <summary>
            Disables automatic field injection for the <paramref name="container" />.
            </summary>
      <param name="container">The target container.</param>
    </member>
    <member name="M:LinFu.IoC.ContainerExtensions.DisableAutoInjectionFor``1(LinFu.IoC.Interfaces.IServiceContainer)">
      <summary>
            Disables automatic dependency injection for members that match the specific
            <typeparamref name="TMember" /> type.
            </summary>
      <typeparam name="TMember">The member injection type to disable.</typeparam>
      <param name="container">The target container.</param>
    </member>
    <member name="T:LinFu.IoC.FluentExtensions">
      <summary>
            A class that adds fluent syntax support to <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" />
            instances.
            </summary>
    </member>
    <member name="M:LinFu.IoC.FluentExtensions.Inject``1(LinFu.IoC.Interfaces.IServiceContainer,System.String)">
      <summary>
            Injects a <typeparamref name="TService" /> type
            into a <paramref name="container" /> using the
            given <paramref name="serviceName" /></summary>
      <typeparam name="TService">The type of service to inject.</typeparam>
      <param name="container">The container that will hold the actual service service instance.</param>
      <param name="serviceName">The name of the service to create.</param>
      <returns>A non-null <see cref="T:LinFu.IoC.Configuration.IUsingLambda`1" /> instance.</returns>
    </member>
    <member name="M:LinFu.IoC.FluentExtensions.Inject``1(LinFu.IoC.Interfaces.IServiceContainer)">
      <summary>
            Injects a <typeparamref name="TService" /> type
            into a <paramref name="container" />.
            </summary>
      <typeparam name="TService">The type of service to inject.</typeparam>
      <param name="container">The container that will hold the actual service service instance.</param>
      <returns>A non-null <see cref="T:LinFu.IoC.Configuration.IUsingLambda`1" /> instance.</returns>
    </member>
    <member name="M:LinFu.IoC.FluentExtensions.Initialize``1(LinFu.IoC.Interfaces.IServiceContainer)">
      <summary>
            Initializes services that match the given <typeparamref name="TService" /> type.
            </summary>
      <typeparam name="TService">The service type to initialize.</typeparam>
      <param name="container">The container that will create the service itself.</param>
      <returns>A <see cref="T:LinFu.IoC.Configuration.Interfaces.IPropertyInjectionLambda`1" /> instance. This cannot be <c>null</c>.</returns>
    </member>
    <member name="M:LinFu.IoC.FluentExtensions.Initialize``1(LinFu.IoC.Interfaces.IServiceContainer,System.String)">
      <summary>
            Initializes services that match the given <paramref name="serviceName" /> and <typeparamref name="TService" /> type.
            </summary>
      <typeparam name="TService">The service type to initialize.</typeparam>
      <param name="container">The container that will create the service itself.</param>
      <param name="serviceName">The name of the service to initialize.</param>
      <returns>A <see cref="T:LinFu.IoC.Configuration.Interfaces.IPropertyInjectionLambda`1" /> instance. This cannot be <c>null</c>.</returns>
    </member>
    <member name="M:LinFu.IoC.FluentExtensions.CreateAdapter``1(System.Func{LinFu.IoC.Interfaces.IFactoryRequest,``0})">
      <summary>
            Converts a <see cref="T:System.Func`4" />
            lambda into an equivalent <see cref="T:System.Func`4" />
            instance.
            </summary>
      <typeparam name="TService">The type of service to create.</typeparam>
      <param name="func">The lambda function to be converted.</param>
      <returns>The equivalent <see cref="T:System.Func`2" />
            that delegates its calls back to the <paramref name="func" /> lambda function.</returns>
    </member>
    <member name="T:LinFu.IoC.Configuration.ResolutionExtensions">
      <summary>
            Adds methods that extend LinFu.IoC to support automatic constructor resolution.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.ResolutionExtensions.MustExistInContainer(System.Type)">
      <summary>
            Generates a predicate that determines whether or not a specific parameter type
            exists in a container.
            </summary>
      <param name="parameterType">The target <see cref="T:System.Type" />. </param>
      <returns>A a predicate that determines whether or not a specific type
            exists in a container</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.ResolutionExtensions.ExistsAsEnumerableSetOfServices(System.Type)">
      <summary>
            Generates a predicate that determines whether or not a specific type is actually
            a list of services that can be created from a given container.
            </summary>
      <param name="parameterType">The target <see cref="T:System.Type" />. </param>
      <returns>A a predicate that determines whether or not a specific type
            exists as a list of services in a container</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.ResolutionExtensions.ExistsAsServiceArray(System.Type)">
      <summary>
            Generates a predicate that determines whether or not a specific type is actually
            a list of services that can be created from a given container.
            </summary>
      <param name="parameterType">The target <see cref="T:System.Type" />. </param>
      <returns>A a predicate that determines whether or not a specific type
            exists as a list of services in a container</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.ResolutionExtensions.ResolveArgumentsFrom(System.Reflection.MethodBase,LinFu.IoC.Interfaces.IServiceContainer)">
      <summary>
            Builds an argument list for the <paramref name="method" />
            using the given <paramref name="container" /> instance.
            </summary>
      <param name="method">The method that will be used to instantiate an object instance.</param>
      <param name="container">The container that will provide the method arguments.</param>
      <returns>An array of objects to be used with the target method.</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.ResolutionExtensions.ResolveFrom(LinFu.IoC.Configuration.Interfaces.IArgumentResolver,System.Reflection.MethodBase,LinFu.IoC.Interfaces.IServiceContainer,System.Object[])">
      <summary>
            Builds an argument list for the target <paramref name="method" /> from
            services embedded inside the <paramref name="container" /> instance.
            </summary>
      <param name="resolver">The <see cref="T:LinFu.IoC.Configuration.Interfaces.IArgumentResolver" /> instance that will determine the method arguments.</param>
      <param name="method">The target method.</param>
      <param name="container">The container that will provide the method arguments.</param>
      <param name="additionalArguments">The additional arguments that will be passed to the target method.</param>
      <returns>An array of objects to be used with the target method.</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.ResolutionExtensions.Cast(System.Collections.IEnumerable,System.Type)">
      <summary>
            Casts an <see cref="T:System.Collections.IEnumerable" /> set of items into an array of
            <paramref name="targetElementType" /> items.
            </summary>
      <param name="items">The items being converted.</param>
      <param name="targetElementType">The element type of the resulting array.</param>
      <returns>An array of items that match the <paramref name="targetElementType" />.</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.ResolutionExtensions.Cast``1(System.Collections.IEnumerable)">
      <summary>
            Performs a strongly typed cast against an <see cref="T:System.Collections.IEnumerable" /> instance.
            </summary>
      <typeparam name="T">The target element type.</typeparam>
      <param name="items">The list of items being converted.</param>
      <returns>An array of items that match the <typeparamref name="T" /> element type.</returns>
    </member>
    <member name="T:LinFu.IoC.Configuration.Interfaces.IFactoryBuilder">
      <summary>
            Represents a class that can generate <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instances 
            from a given service type, implementing type, and lifecycle.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.Interfaces.IFactoryBuilder.CreateFactory(System.Type,System.Type,LinFu.IoC.Configuration.LifecycleType)">
      <summary>
            Generates a <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance that can create the <paramref name="serviceType" />
            using the <paramref name="implementingType" /> and <paramref name="lifecycle" /> model.
            </summary>
      <param name="serviceType">The service type that will be created by the factory.</param>
      <param name="implementingType">The concrete type that will provide the implementation for the service type.</param>
      <param name="lifecycle">The instancing behavior of the given service type.</param>
      <returns>A valid <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance.</returns>
    </member>
    <member name="T:LinFu.IoC.Configuration.FactoryBuilder">
      <summary>
            The default implementation of the <see cref="T:LinFu.IoC.Configuration.Interfaces.IFactoryBuilder" /> class.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.FactoryBuilder.CreateFactory(System.Type,System.Type,LinFu.IoC.Configuration.LifecycleType)">
      <summary>
            Creates a factory instance that can create instaces of the given
            <paramref name="serviceType" />  using the <paramref name="implementingType" />
            as the implementation.
            </summary>
      <param name="serviceType">The service being implemented.</param>
      <param name="implementingType">The actual type that will implement the service.</param>
      <param name="lifecycle">The <see cref="T:LinFu.IoC.Configuration.LifecycleType" /> that determines the lifetime of each instance being created.</param>
      <returns>A valid <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance.</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.FactoryBuilder.CreateFactory(System.Type,System.Type,System.Type)">
      <summary>
            Creates a factory instance that can create instaces of the given
            <paramref name="serviceType" />  using the <paramref name="actualType" />
            as the implementation.
            </summary>
      <param name="serviceType">The service being implemented.</param>
      <param name="actualType">The actual type that will implement the service.</param>
      <param name="factoryType">The factory type that will instantiate the target service.</param>
      <returns>A valid <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance.</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.FactoryBuilder.GetActualType(System.Type,System.Type)">
      <summary>
            Determines the implementing concrete type from the given <paramref name="serviceType" />.
            </summary>
      <param name="serviceType">The service type.</param>
      <param name="implementingType">The concrete class that will implement the service type.</param>
      <returns>The actual implementing type.</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.FactoryBuilder.CreateFactoryMethod(System.Type,System.Type)">
      <summary>
            A <c>private</c> method that creates the factory method delegate
            for use with a particular factory class.
            </summary>
      <seealso cref="T:LinFu.IoC.Factories.SingletonFactory`1" />
      <seealso cref="T:LinFu.IoC.Factories.OncePerRequestFactory`1" />
      <seealso cref="T:LinFu.IoC.Factories.OncePerThreadFactory`1" />
      <param name="serviceType">The service type being instantiated.</param>
      <param name="implementingType">The type that will provide the implementation for the actual service.</param>
      <returns>A factory method delegate that can create the given service.</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.FactoryBuilder.CreateFactoryMethodInternal``2">
      <summary>
            A method that generates the actual lambda function that creates
            the new service instance.
            </summary>
      <typeparam name="TService">The service type being instantiated.</typeparam>
      <typeparam name="TImplementation">The type that will provide the implementation for the actual service.</typeparam>
      <returns>A strongly-typed factory method delegate that can create the given service.</returns>
    </member>
    <member name="T:LinFu.IoC.Configuration.BaseContext`1">
      <summary>
            Represents a class that provides the most basic information
            for executing a fluent command against a 
            <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" /> instance.
            </summary>
      <typeparam name="TService">
      </typeparam>
    </member>
    <member name="P:LinFu.IoC.Configuration.BaseContext`1.ServiceType">
      <summary>
            The service type to be created.
            </summary>
    </member>
    <member name="P:LinFu.IoC.Configuration.BaseContext`1.ServiceName">
      <summary>
            The name of the service to be created.
            </summary>
    </member>
    <member name="P:LinFu.IoC.Configuration.BaseContext`1.Container">
      <summary>
            The actual <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" />
            that ultimately will hold the service instance.
            </summary>
    </member>
    <member name="T:LinFu.IoC.Configuration.ActionContext`1">
      <summary>
            Represents the <c>internal</c> context class that will be used to 
            incrementally build enough information to initialize
            a specific <typeparamref name="TService" /> type once
            that service has been instantiated.
            </summary>
      <typeparam name="TService">The service type to be created.</typeparam>
    </member>
    <member name="P:LinFu.IoC.Configuration.ActionContext`1.Action">
      <summary>
            The action that will be performed on an <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" />
            instance once the fluent command executes.
            </summary>
    </member>
    <member name="T:LinFu.IoC.Configuration.ActionPostProcessor`1">
      <summary>
            Represents a postprocessor that will execute
            the action associated with the given <see cref="T:LinFu.IoC.Configuration.ActionContext`1" />
            instance every time the target container returns a 
            service with particular service name and service type.
            </summary>
      <typeparam name="TService">
      </typeparam>
    </member>
    <member name="T:LinFu.IoC.Configuration.IGenerateFactory`1">
      <summary>
            Represents a fluent class that allows
            users to create specific types of factories.
            </summary>
      <typeparam name="TService">The type of service being created.</typeparam>
    </member>
    <member name="M:LinFu.IoC.Configuration.IGenerateFactory`1.AsSingleton">
      <summary>
            Creates a singleton factory.
            </summary>
      <seealso cref="T:LinFu.IoC.Factories.SingletonFactory`1" />
    </member>
    <member name="M:LinFu.IoC.Configuration.IGenerateFactory`1.OncePerThread">
      <summary>
            Creates a once per thread factory.
            </summary>
      <seealso cref="T:LinFu.IoC.Factories.OncePerThreadFactory`1" />
    </member>
    <member name="M:LinFu.IoC.Configuration.IGenerateFactory`1.OncePerRequest">
      <summary>
            Creates a once per request factory.
            </summary>
      <seealso cref="T:LinFu.IoC.Factories.OncePerRequestFactory`1" />
    </member>
    <member name="T:LinFu.IoC.Configuration.GenerateFactory`1">
      <summary>
            Represents a fluent class that allows
            users to create specific types of factories.
            </summary>
      <typeparam name="TService">The type of service being created.</typeparam>
    </member>
    <member name="M:LinFu.IoC.Configuration.GenerateFactory`1.#ctor(LinFu.IoC.Configuration.InjectionContext{`0})">
      <summary>
            Instantiates the class using the given
            <paramref name="context" />.
            </summary>
      <param name="context">The <see cref="T:LinFu.IoC.Configuration.InjectionContext`1" /> instance
            which will contain the information necessary to build a fluent command.</param>
    </member>
    <member name="M:LinFu.IoC.Configuration.GenerateFactory`1.AsSingleton">
      <summary>
            Creates a singleton factory.
            </summary>
      <seealso cref="T:LinFu.IoC.Factories.SingletonFactory`1" />
    </member>
    <member name="M:LinFu.IoC.Configuration.GenerateFactory`1.OncePerThread">
      <summary>
            Creates a once per thread factory.
            </summary>
      <seealso cref="T:LinFu.IoC.Factories.OncePerThreadFactory`1" />
    </member>
    <member name="M:LinFu.IoC.Configuration.GenerateFactory`1.OncePerRequest">
      <summary>
            Creates a once per request factory.
            </summary>
      <seealso cref="T:LinFu.IoC.Factories.OncePerRequestFactory`1" />
    </member>
    <member name="M:LinFu.IoC.Configuration.GenerateFactory`1.AddFactory(System.Func{System.Func{LinFu.IoC.Interfaces.IFactoryRequest,`0},LinFu.IoC.Interfaces.IFactory{`0}})">
      <summary>
            Adds a factory to the container by using the 
            <paramref name="createFactory" /> delegate to
            create the actual <see cref="T:LinFu.IoC.Interfaces.IFactory`1" />
            instance.
            </summary>
      <param name="createFactory">The delegate that will create the actual factory instance.</param>
    </member>
    <member name="T:LinFu.IoC.Configuration.InjectionContext`1">
      <summary>
            Represents the <c>internal</c> context class that will be used to 
            incrementally build enough information to inject a specific
            <see cref="T:LinFu.IoC.Interfaces.IFactory`1" /> instance into a container.
            </summary>
      <typeparam name="TService">The service type to be created.</typeparam>
    </member>
    <member name="P:LinFu.IoC.Configuration.InjectionContext`1.FactoryMethod">
      <summary>
            The factory method that will be used to
            instantiate the actual <typeparamref name="TService" />
            instance.
            </summary>
    </member>
    <member name="T:LinFu.IoC.Configuration.Interfaces.IPropertyInjectionLambda`1">
      <summary>
            Represents a fluent class that creates
            a method that initializes a <typeparamref name="TService" />
            instance.
            </summary>
      <typeparam name="TService">The service type being instantiated.</typeparam>
    </member>
    <member name="M:LinFu.IoC.Configuration.Interfaces.IPropertyInjectionLambda`1.With(System.Action{`0})">
      <summary>
            Initializes service instances with the given
            <paramref name="action" />.
            </summary>
      <param name="action">An <see cref="T:System.Action`1" /> delegate that will be used to initialize newly created services.</param>
    </member>
    <member name="M:LinFu.IoC.Configuration.Interfaces.IPropertyInjectionLambda`1.With(System.Action{LinFu.IoC.Interfaces.IServiceContainer,`0})">
      <summary>
            Uses an action delegate to initialize a given service using
            the given <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" /> and <typeparamref name="TService" />
            instances.
            </summary>
      <param name="action">An <see cref="T:System.Func`2" /> delegate that will be used to initialize newly created services.</param>
    </member>
    <member name="T:LinFu.IoC.Configuration.PropertyInjectionLambda`1">
      <summary>
            Represents a fluent class that creates
            a method that initializes a <typeparamref name="TService" />
            instance.
            </summary>
      <typeparam name="TService">The service type being instantiated.</typeparam>
    </member>
    <member name="M:LinFu.IoC.Configuration.PropertyInjectionLambda`1.#ctor(LinFu.IoC.Configuration.ActionContext{`0})">
      <summary>
            Initializes the class with the <paramref name="context" />.
            </summary>
      <param name="context">The context that will be associated with the target container.</param>
    </member>
    <member name="M:LinFu.IoC.Configuration.PropertyInjectionLambda`1.With(System.Action{`0})">
      <summary>
            Initializes service instances with the given
            <paramref name="action" />.
            </summary>
      <param name="action">An <see cref="T:System.Action`1" /> delegate that will be used to initialize newly created services.</param>
    </member>
    <member name="M:LinFu.IoC.Configuration.PropertyInjectionLambda`1.With(System.Action{LinFu.IoC.Interfaces.IServiceContainer,`0})">
      <summary>
            Uses an action delegate to initialize a given service using
            the given <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" /> and <typeparamref name="TService" />
            instances.
            </summary>
      <param name="action">An <see cref="T:System.Func`2" /> delegate that will be used to initialize newly created services.</param>
    </member>
    <member name="M:LinFu.IoC.Configuration.PropertyInjectionLambda`1.AddPostProcessor(LinFu.IoC.Configuration.ActionContext{`0})">
      <summary>
            Attaches the action associated with the <see cref="T:LinFu.IoC.Configuration.ActionContext`1" />
            instance to the target container embedded within the <see cref="T:LinFu.IoC.Configuration.ActionContext`1" />
            class itself.
            </summary>
      <param name="context">The context that will be associated with the target container.</param>
    </member>
    <member name="T:LinFu.IoC.Configuration.IUsingLambda`1">
      <summary>
            Represents a fluent class that creates
            a factory method that will be used
            in instantiating a specific service instance.
            </summary>
      <typeparam name="TService">The service type being instantiated.</typeparam>
    </member>
    <member name="M:LinFu.IoC.Configuration.IUsingLambda`1.Using``1">
      <summary>
            Creates a service instance using the
            concrete <typeparamref name="TConcrete" /> type 
            as the implementation for the <typeparamref name="TService" />
            type.
            </summary>
      <typeparam name="TConcrete">The concrete implementation that implements <typeparamref name="TService" />. This class must have a default constructor.</typeparam>
      <returns>A non-null <see cref="T:LinFu.IoC.Configuration.IGenerateFactory`1" /> instance that will be used to create a factory and add it to a specific container.</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.IUsingLambda`1.Using(System.Func{LinFu.IoC.Interfaces.IServiceContainer,System.Object[],`0})">
      <summary>
            Creates a service instance using the
            <paramref name="factoryMethod" /> to
            instantiate the service instance
            with a particular factory type.
            </summary>
      <seealso cref="T:LinFu.IoC.Configuration.IGenerateFactory`1" />
      <param name="factoryMethod">The factory method that will be used to instantiate the actual service instance.</param>
      <returns>A non-null <see cref="T:LinFu.IoC.Configuration.IGenerateFactory`1" /> instance that will be used to create a factory and add it to a specific container.</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.IUsingLambda`1.Using(System.Func{LinFu.IoC.Interfaces.IServiceContainer,`0})">
      <summary>
            Creates a service instance using the
            <paramref name="factoryMethod" /> to
            instantiate the service instance
            with a particular factory type.
            </summary>
      <seealso cref="T:LinFu.IoC.Configuration.IGenerateFactory`1" />
      <param name="factoryMethod">The factory method that will be used to instantiate the actual service instance.</param>
      <returns>A non-null <see cref="T:LinFu.IoC.Configuration.IGenerateFactory`1" /> instance that will be used to create a factory and add it to a specific container.</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.IUsingLambda`1.Using(System.Func{`0})">
      <summary>
            Creates a service instance using the
            <paramref name="factoryMethod" /> to
            instantiate the service instance
            with a particular factory type.
            </summary>
      <param name="factoryMethod">The factory method that will be used to instantiate the actual service instance.</param>
      <returns>A non-null <see cref="T:LinFu.IoC.Configuration.IGenerateFactory`1" /> instance that will be used to create a factory and add it to a specific container.</returns>
    </member>
    <member name="T:LinFu.IoC.Configuration.UsingLambda`1">
      <summary>
            Represents a fluent class that creates
            a factory method that will be used
            in instantiating a specific service instance.
            </summary>
      <typeparam name="TService">The service type being instantiated.</typeparam>
    </member>
    <member name="M:LinFu.IoC.Configuration.UsingLambda`1.#ctor(LinFu.IoC.Configuration.InjectionContext{`0})">
      <summary>
            Initializes the class using the given <paramref name="context" />.
            </summary>
      <param name="context">the <c>internal</c> context class that will be used to 
            incrementally build enough information to inject a specific
            <see cref="T:LinFu.IoC.Interfaces.IFactory`1" /> instance into a container.</param>
    </member>
    <member name="M:LinFu.IoC.Configuration.UsingLambda`1.Using``1">
      <summary>
            Creates a service instance using the
            concrete <typeparamref name="TConcrete" /> type 
            as the implementation for the <typeparamref name="TService" />
            type.
            </summary>
      <typeparam name="TConcrete">The concrete implementation that implements <typeparamref name="TService" />. This class must have a default constructor.</typeparam>
      <returns>A non-null <see cref="T:LinFu.IoC.Configuration.IGenerateFactory`1" /> instance that will be used to create a factory and add it to a specific container.</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.UsingLambda`1.Using(System.Func{LinFu.IoC.Interfaces.IServiceContainer,System.Object[],`0})">
      <summary>
            Creates a service instance using the
            <paramref name="factoryMethod" /> to
            instantiate the service instance
            with a particular factory type.
            </summary>
      <seealso cref="T:LinFu.IoC.Configuration.IGenerateFactory`1" />
      <param name="factoryMethod">The factory method that will be used to instantiate the actual service instance.</param>
      <returns>A non-null <see cref="T:LinFu.IoC.Configuration.IGenerateFactory`1" /> instance that will be used to create a factory and add it to a specific container.</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.UsingLambda`1.Using(System.Func{LinFu.IoC.Interfaces.IServiceContainer,`0})">
      <summary>
            Creates a service instance using the
            <paramref name="factoryMethod" /> to
            instantiate the service instance
            with a particular factory type.
            </summary>
      <seealso cref="T:LinFu.IoC.Configuration.IGenerateFactory`1" />
      <param name="factoryMethod">The factory method that will be used to instantiate the actual service instance.</param>
      <returns>A non-null <see cref="T:LinFu.IoC.Configuration.IGenerateFactory`1" /> instance that will be used to create a factory and add it to a specific container.</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.UsingLambda`1.Using(System.Func{`0})">
      <summary>
            Creates a service instance using the
            <paramref name="factoryMethod" /> to
            instantiate the service instance
            with a particular factory type.
            </summary>
      <param name="factoryMethod">The factory method that will be used to instantiate the actual service instance.</param>
      <returns>A non-null <see cref="T:LinFu.IoC.Configuration.IGenerateFactory`1" /> instance that will be used to create a factory and add it to a specific container.</returns>
    </member>
    <member name="T:LinFu.IoC.Configuration.Initializer`1">
      <summary>
            A class that initializes service instances that use
            the <see cref="T:LinFu.Reflection.IInitialize`1" /> interface.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.Initializer`1.#ctor(System.Func{LinFu.IoC.Interfaces.IServiceRequestResult,`0})">
      <summary>
            Initializes the class with the given <paramref name="getSource" /> delegate.
            </summary>
      <param name="getSource">The functor that will obtain the object instance that will be used to initialize a given service.</param>
    </member>
    <member name="M:LinFu.IoC.Configuration.Initializer`1.PostProcess(LinFu.IoC.Interfaces.IServiceRequestResult)">
      <summary>
            Initializes every service that implements
            the <see cref="T:LinFu.Reflection.IInitialize`1" /> interface.
            </summary>
      <param name="result">The <see cref="T:LinFu.IoC.Interfaces.IServiceRequestResult" /> instance that contains the service instance to be initialized.</param>
    </member>
    <member name="M:LinFu.IoC.Configuration.Initializer`1.Initialize(LinFu.Reflection.IInitialize{`0},`0)">
      <summary>
            Initializes the <paramref name="target" /> with the given <paramref name="source" /> instance.
            </summary>
      <param name="target">The target to initialize.</param>
      <param name="source">The instance that will be introduced to the <see cref="T:LinFu.Reflection.IInitialize`1" /> instance.</param>
    </member>
    <member name="T:LinFu.IoC.Configuration.Initializer">
      <summary>
            A class that initializes service instances that use
            the <see cref="T:LinFu.IoC.Configuration.IInitialize" /> interface.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.Initializer.#ctor">
      <summary>
            Initializes the class with the default settings.
            </summary>
    </member>
    <member name="T:LinFu.IoC.Configuration.InitializerPlugin">
      <summary>
            A class that injects the <see cref="T:LinFu.IoC.Configuration.Initializer" /> postprocessor
            into every container that is created or loaded.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.InitializerPlugin.BeginLoad(LinFu.IoC.Interfaces.IServiceContainer)">
      <summary>
            This override does absolutely nothing.
            </summary>
      <param name="target">The target container.</param>
    </member>
    <member name="M:LinFu.IoC.Configuration.InitializerPlugin.EndLoad(LinFu.IoC.Interfaces.IServiceContainer)">
      <summary>
            Injects the <see cref="T:LinFu.IoC.Configuration.Initializer" /> postprocessor into
            the container.
            </summary>
      <param name="target">
      </param>
    </member>
    <member name="T:LinFu.IoC.Configuration.Interfaces.IMemberInjectionFilter`1">
      <summary>
            An interface responsible for determining which methods
            should be injected.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.Interfaces.IMemberInjectionFilter`1.GetInjectableMembers(System.Type)">
      <summary>
            Returns the list of <see cref="T:System.Reflection.MethodBase" /> objects
            that will be injected with arbitrary values.
            </summary>
      <param name="targetType">The target type that contains the target methods.</param>
      <returns>A set of methods that describe which methods that will injected.</returns>
    </member>
    <member name="T:LinFu.IoC.Configuration.BaseMemberInjectionFilter`1">
      <summary>
            Defines the basic behavior of the <see cref="T:LinFu.IoC.Configuration.Interfaces.IMemberInjectionFilter`1" /> interface.
            </summary>
      <typeparam name="TMember">The member type that will be filtered.</typeparam>
    </member>
    <member name="M:LinFu.IoC.Configuration.BaseMemberInjectionFilter`1.GetInjectableMembers(System.Type)">
      <summary>
            Returns the list of <typeparamref name="TMember" /> objects
            whose setters will injected with arbitrary values.
            </summary>
      <remarks>This implementation selects properties that are marked with the <see cref="T:LinFu.IoC.Configuration.InjectAttribute" />.</remarks>
      <param name="targetType">The target type that contains the target properties.</param>
      <returns>A set of properties that describe which parameters should be injected.</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.BaseMemberInjectionFilter`1.GetMembers(System.Type,LinFu.IoC.Interfaces.IServiceContainer)">
      <summary>
            Determines which members should be selected from the <paramref name="targetType" />
            using the <paramref name="container" /></summary>
      <param name="targetType">The target type that will supply the list of members that will be filtered.</param>
      <param name="container">The target container.</param>
      <returns>A list of <typeparamref name="TMember" /> objects that pass the filter description.</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.BaseMemberInjectionFilter`1.Filter(LinFu.IoC.Interfaces.IServiceContainer,System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Determines which items should be injected from the <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" /> instance.
            </summary>
      <param name="container">The source container that will supply the values for the selected members.</param>
      <param name="items">The list of properties that will be filtered.</param>
      <returns>A list of properties that will be injected.</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.BaseMemberInjectionFilter`1.Initialize(LinFu.IoC.Interfaces.IServiceContainer)">
      <summary>
            Initializes the <see cref="T:LinFu.IoC.Configuration.BaseMemberInjectionFilter`1" /> class.
            </summary>
      <param name="source">The host container.</param>
    </member>
    <member name="T:LinFu.IoC.Configuration.AttributedFieldInjectionFilter">
      <summary>
            A default implementation of the <see cref="T:LinFu.IoC.Configuration.Interfaces.IMemberInjectionFilter`1" />
            class that returns fields which have the <see cref="T:LinFu.IoC.Configuration.InjectAttribute" />
            defined.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.AttributedFieldInjectionFilter.#ctor">
      <summary>
            Initializes the class and uses the <see cref="T:LinFu.IoC.Configuration.InjectAttribute" />
            to specify which field should be automatically injected with
            services from the container.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.AttributedFieldInjectionFilter.#ctor(System.Type)">
      <summary>
            Initializes the class and uses the <paramref name="attributeType" />
            to specify which fields should be automatically injected with
            services from the container.
            </summary>
      <param name="attributeType">The custom property attribute that will be used to mark properties for automatic injection.</param>
    </member>
    <member name="M:LinFu.IoC.Configuration.AttributedFieldInjectionFilter.GetMembers(System.Type,LinFu.IoC.Interfaces.IServiceContainer)">
      <summary>
            Determines which members should be selected from the <paramref name="targetType" />
            using the <paramref name="container" /></summary>
      <param name="targetType">The target type that will supply the list of members that will be filtered.</param>
      <param name="container">The target container.</param>
      <returns>A list of <see cref="T:System.Reflection.FieldInfo" /> objects that pass the filter description.</returns>
    </member>
    <member name="T:LinFu.IoC.Configuration.AttributedMethodInjectionFilter">
      <summary>
            A default implementation of the <see cref="T:LinFu.IoC.Configuration.Interfaces.IMemberInjectionFilter`1" />
            class that returns methods which have the <see cref="T:LinFu.IoC.Configuration.InjectAttribute" />
            defined.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.AttributedMethodInjectionFilter.#ctor">
      <summary>
            Initializes the class with the <see cref="T:LinFu.IoC.Configuration.InjectAttribute" /> as the
            default injection attribute.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.AttributedMethodInjectionFilter.#ctor(System.Type)">
      <summary>
            Initializes the class and uses the <paramref name="attributeType" />
            as the custom injection attribute.
            </summary>
      <param name="attributeType">
      </param>
    </member>
    <member name="M:LinFu.IoC.Configuration.AttributedMethodInjectionFilter.GetMembers(System.Type,LinFu.IoC.Interfaces.IServiceContainer)">
      <summary>
            Returns the methods that have the custom attribute type defined.
            </summary>
      <param name="targetType">The target type that contains the target methods.</param>
      <param name="container">The host container.</param>
      <returns>The list of methods that have the custom attribute type defined.</returns>
    </member>
    <member name="T:LinFu.IoC.Configuration.AttributedPropertyInjectionFilter">
      <summary>
            A default implementation of the <see cref="T:LinFu.IoC.Configuration.Interfaces.IMemberInjectionFilter`1" />
            class that returns properties which have the <see cref="T:LinFu.IoC.Configuration.InjectAttribute" />
            defined.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.AttributedPropertyInjectionFilter.#ctor">
      <summary>
            Initializes the class and uses the <see cref="T:LinFu.IoC.Configuration.InjectAttribute" />
            to specify which properties should be automatically injected with
            services from the container.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.AttributedPropertyInjectionFilter.#ctor(System.Type)">
      <summary>
            Initializes the class and uses the <paramref name="attributeType" />
            to specify which properties should be automatically injected with
            services from the container.
            </summary>
      <param name="attributeType">The custom property attribute that will be used to mark properties for automatic injection.</param>
    </member>
    <member name="M:LinFu.IoC.Configuration.AttributedPropertyInjectionFilter.Filter(LinFu.IoC.Interfaces.IServiceContainer,System.Collections.Generic.IEnumerable{System.Reflection.PropertyInfo})">
      <summary>
            Determines which properties should be injected from the <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" /> instance.
            </summary>
      <param name="container">The source container that will supply the property values for the selected properties.</param>
      <param name="properties">The list of properties to be filtered.</param>
      <returns>A list of properties that should be injected.</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.AttributedPropertyInjectionFilter.GetMembers(System.Type,LinFu.IoC.Interfaces.IServiceContainer)">
      <summary>
            Determines which members should be selected from the <paramref name="targetType" />
            using the <paramref name="container" /></summary>
      <param name="targetType">The target type that will supply the list of members that will be filtered.</param>
      <param name="container">The target container.</param>
      <returns>A list of <see cref="T:System.Reflection.PropertyInfo" /> objects that pass the filter description.</returns>
    </member>
    <member name="T:LinFu.IoC.Configuration.Interfaces.IContainerPlugin">
      <summary>
            Represents an alias interface used for backward compatibility with LinFu IoC 1.0
            </summary>
    </member>
    <member name="T:LinFu.IoC.Configuration.AutoMemberInjector`1">
      <summary>
            The base class that defines the behavior for automatically injecting service
            instances into type member instances.
            </summary>
      <typeparam name="TMember">
      </typeparam>
    </member>
    <member name="M:LinFu.IoC.Configuration.AutoMemberInjector`1.PostProcess(LinFu.IoC.Interfaces.IServiceRequestResult)">
      <summary>
            Automatically injects service instances
            into properties as soon as they are initialized.
            </summary>
      <param name="result">The service request result that contains the service whose members will be injected with service instances.</param>
    </member>
    <member name="M:LinFu.IoC.Configuration.AutoMemberInjector`1.Inject(System.Object,`0,LinFu.IoC.Configuration.Interfaces.IArgumentResolver,LinFu.IoC.Interfaces.IServiceContainer,System.Object[])">
      <summary>
            Injects services from the <paramref name="container" /> into the target <paramref name="member" /> instance.
            </summary>
      <param name="target">The target object.</param>
      <param name="member">The <typeparamref name="TMember" /> instance that will store the service instance.</param>
      <param name="argumentResolver">The <see cref="T:LinFu.IoC.Configuration.Interfaces.IArgumentResolver" /> that will determine which arguments will be assigned to the target member.</param>
      <param name="additionalArguments">The additional arguments that were passed to the <see cref="T:LinFu.IoC.Interfaces.IServiceRequestResult" /> during the instantiation process.</param>
      <param name="container">The container that will provide the service instances.</param>
    </member>
    <member name="M:LinFu.IoC.Configuration.AutoMemberInjector`1.AutoInject(LinFu.IoC.Interfaces.IServiceRequestResult)">
      <summary>
            Injects a member service dependency into a target service instance.
            </summary>
      <param name="result">The <see cref="T:LinFu.IoC.Interfaces.IServiceRequestResult" /> that will be processed for injection.</param>
    </member>
    <member name="M:LinFu.IoC.Configuration.AutoMemberInjector`1.BeginLoad(LinFu.IoC.Interfaces.IServiceContainer)">
      <summary>
            Does absolutely nothing.
            </summary>
      <param name="target">The target container.</param>
    </member>
    <member name="M:LinFu.IoC.Configuration.AutoMemberInjector`1.EndLoad(LinFu.IoC.Interfaces.IServiceContainer)">
      <summary>
            Inserts the <see cref="T:LinFu.IoC.Configuration.AutoPropertyInjector" /> class at the end
            of the PostProcessor chain.
            </summary>
      <param name="target">The target container.</param>
    </member>
    <member name="T:LinFu.IoC.Configuration.AutoFieldInjector">
      <summary>
            A class that automatically injects fields using values
            provided by an <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" /> instance.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.AutoFieldInjector.Inject(System.Object,System.Reflection.FieldInfo,LinFu.IoC.Configuration.Interfaces.IArgumentResolver,LinFu.IoC.Interfaces.IServiceContainer,System.Object[])">
      <summary>
            Injects a field with values from a given container.
            </summary>
      <param name="target">The target object.</param>
      <param name="member">The <see cref="T:System.Reflection.FieldInfo" /> instance that will store the service instance.</param>
      <param name="argumentResolver">The <see cref="T:LinFu.IoC.Configuration.Interfaces.IArgumentResolver" /> that will determine which values will be assigned to the target member.</param>
      <param name="additionalArguments">The additional arguments that were passed to the <see cref="T:LinFu.IoC.Interfaces.IServiceRequestResult" /> during the instantiation process. Note: This parameter will be ignored by this override.</param>
      <param name="container">The container that will provide the service instances.</param>
    </member>
    <member name="T:LinFu.IoC.Configuration.AutoMethodInjector">
      <summary>
            A class that automatically invokes methods using arguments
            derived from existing instances from within a <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" />
            instance.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.AutoMethodInjector.Inject(System.Object,System.Reflection.MethodInfo,LinFu.IoC.Configuration.Interfaces.IArgumentResolver,LinFu.IoC.Interfaces.IServiceContainer,System.Object[])">
      <summary>
            Injects services from the <paramref name="container" /> into the target <see cref="T:System.Reflection.MethodInfo" /> instance.
            </summary>
      <param name="target">The target object.</param>
      <param name="method">The <see cref="T:System.Reflection.MethodInfo" /> instance that will store the service instance.</param>
      <param name="resolver">The <see cref="T:LinFu.IoC.Configuration.Interfaces.IArgumentResolver" /> that will determine which arguments will be assigned to the target member.</param>
      <param name="additionalArguments">The additional arguments that were passed to the <see cref="T:LinFu.IoC.Interfaces.IServiceRequestResult" /> during the instantiation process.</param>
      <param name="container">The container that will provide the service instances.</param>
    </member>
    <member name="T:LinFu.IoC.Configuration.AutoPropertyInjector">
      <summary>
            A class that automatically injects property dependencies into
            service instances.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.AutoPropertyInjector.Inject(System.Object,System.Reflection.PropertyInfo,LinFu.IoC.Configuration.Interfaces.IArgumentResolver,LinFu.IoC.Interfaces.IServiceContainer,System.Object[])">
      <summary>
            Injects services from the <paramref name="container" /> into the target <see cref="T:System.Reflection.PropertyInfo" /> instance.
            </summary>
      <param name="target">The target object.</param>
      <param name="property">The <see cref="T:System.Reflection.PropertyInfo" /> instance that will store the service instance.</param>
      <param name="resolver">The <see cref="T:LinFu.IoC.Configuration.Interfaces.IArgumentResolver" /> that will determine which arguments will be assigned to the target member.</param>
      <param name="additionalArguments">The additional arguments that were passed to the <see cref="T:LinFu.IoC.Interfaces.IServiceRequestResult" /> during the instantiation process.</param>
      <param name="container">The container that will provide the service instances.</param>
    </member>
    <member name="T:LinFu.IoC.Configuration.Injectors.CustomFactoryInjector">
      <summary>
            A class that injects unnamed custom <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instances into a given
            service container.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.Injectors.CustomFactoryInjector.#ctor(System.Type,LinFu.IoC.Interfaces.IFactory)">
      <summary>
            Initializes the class with the given service type and factory.
            </summary>
      <param name="serviceType">The service type that will be created by the factory.</param>
      <param name="factory">The <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance that will be used to create the service instance.</param>
    </member>
    <member name="M:LinFu.IoC.Configuration.Injectors.CustomFactoryInjector.Preprocess(LinFu.IoC.Interfaces.IServiceRequest)">
      <summary>
            Injects the given factory into the target container.
            </summary>
      <param name="request">The <see cref="T:LinFu.IoC.Interfaces.IServiceRequest" /> instance that describes the service that is currently being requested.</param>
    </member>
    <member name="T:LinFu.IoC.Configuration.Injectors.NullMemberInjectionFilter`1">
      <summary>
            Represents a type of <see cref="T:LinFu.IoC.Configuration.Interfaces.IMemberInjectionFilter`1" />
            that always returns an empty match.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.Injectors.NullMemberInjectionFilter`1.GetInjectableMembers(System.Type)">
      <summary>
            Always returns an empty list of injectable members.
            </summary>
      <param name="targetType">The type to be injected.</param>
      <returns>An empty list.</returns>
    </member>
    <member name="T:LinFu.IoC.Configuration.PropertyInjectionFilter">
      <summary>
            An <see cref="T:LinFu.IoC.Configuration.Interfaces.IMemberInjectionFilter`1" /> implementation
            that automatically selects properties whose property types
            currently exist in the target container.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.PropertyInjectionFilter.GetMembers(System.Type,LinFu.IoC.Interfaces.IServiceContainer)">
      <summary>
            Determines which members should be selected from the <paramref name="targetType" />
            using the <paramref name="container" /></summary>
      <param name="targetType">The target type that will supply the list of members that will be filtered.</param>
      <param name="container">The target container.</param>
      <returns>A list of <see cref="T:System.Reflection.PropertyInfo" /> objects that pass the filter description.</returns>
    </member>
    <member name="T:LinFu.IoC.Configuration.InMemoryAssemblyLoader">
      <summary>
            An assembly loader that returns an existing
            <see cref="T:System.Reflection.Assembly" /> from memory.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.InMemoryAssemblyLoader.#ctor(System.Reflection.Assembly)">
      <summary>
            Initializes the class with an existing
            <see cref="T:System.Reflection.Assembly" />.
            </summary>
      <param name="targetAssembly">The target assembly.</param>
    </member>
    <member name="T:LinFu.IoC.Configuration.Interfaces.IMethodFinderContext">
      <summary>
            Represents the data associated with a <see cref="T:LinFu.IoC.Configuration.Interfaces.IMethodFinder`1" /> search.
            </summary>
    </member>
    <member name="P:LinFu.IoC.Configuration.Interfaces.IMethodFinderContext.TypeArguments">
      <summary>
            Gets or sets the value indicating the type arguments that will be passed to the target method.
            </summary>
    </member>
    <member name="P:LinFu.IoC.Configuration.Interfaces.IMethodFinderContext.Arguments">
      <summary>
            Gets or sets the value indicating the list of arguments that will be passed to the target method.
            </summary>
    </member>
    <member name="P:LinFu.IoC.Configuration.Interfaces.IMethodFinderContext.ReturnType">
      <summary>
            Gets or sets the value indicating the <see cref="T:System.Type">return type</see> of the target method.
            </summary>
    </member>
    <member name="T:LinFu.IoC.Configuration.Interfaces.IMethodFinder`1">
      <summary>
            Represents a class that determines which method best matches the
            services currently in the target container.
            </summary>
      <typeparam name="T">The method type to search.</typeparam>
    </member>
    <member name="M:LinFu.IoC.Configuration.Interfaces.IMethodFinder`1.GetBestMatch(System.Collections.Generic.IEnumerable{`0},LinFu.IoC.Configuration.Interfaces.IMethodFinderContext)">
      <summary>
            Determines which method best matches the
            services currently in the target container.
            </summary>
      <param name="items">The list of methods to search.</param>
      <param name="finderContext">The <see cref="T:LinFu.IoC.Configuration.Interfaces.IMethodFinderContext" /> that describes the target method.</param>
      <returns>Returns the method with the most resolvable parameters from the target <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" /> instance.</returns>
    </member>
    <member name="T:LinFu.IoC.Configuration.Interfaces.IMethodFinderWithContainer`1">
      <summary>
            Represents a method finder that uses a <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" /> instance
            during its method searches.
            </summary>
      <typeparam name="TMethod">
      </typeparam>
    </member>
    <member name="P:LinFu.IoC.Configuration.Interfaces.IMethodFinderWithContainer`1.Container">
      <summary>
            Gets the value indicating the service container that will be used in the
            method search.
            </summary>
    </member>
    <member name="T:LinFu.IoC.Configuration.AssemblyContainerLoader">
      <summary>
            Represents a class that loads configuration information
            from a given assembly.
            </summary>
    </member>
    <member name="T:LinFu.IoC.Configuration.ITypeLoader">
      <summary>
            Generates one or more <see cref="T:System.Action`1" /> instances
            from a given source type so that it can be used
            against an <see cref="T:LinFu.IoC.Interfaces.IContainer" /> instance.
            </summary>
    </member>
    <member name="T:LinFu.IoC.Configuration.FactoryAttributeLoader">
      <summary>
            A class that injects custom <see cref="T:LinFu.IoC.Interfaces.IFactory" /> and <see cref="T:LinFu.IoC.Interfaces.IFactory`1" />
            instances into an <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" /> instance.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.FactoryAttributeLoader.Load(System.Type)">
      <summary>
            Loads an <see cref="T:LinFu.IoC.Interfaces.IFactory" /> and <see cref="T:LinFu.IoC.Interfaces.IFactory`1" /> instance
            into a <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" /> instance using the given
            <paramref name="sourceType" />.
            </summary>
      <param name="sourceType">The input type from which one or more factories will be created.</param>
      <returns>A set of <see cref="T:System.Action`1" /> instances. This cannot be null.</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.FactoryAttributeLoader.GetResults(System.Type,System.Collections.Generic.IEnumerable{LinFu.IoC.Configuration.FactoryAttribute},System.Func{LinFu.IoC.Interfaces.IFactoryRequest,System.Object})">
      <summary>
            Instantiates the <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instances associated with the <paramref name="sourceType" /> and
            adds those factories to the target container upon initialization.
            </summary>
      <param name="sourceType">The <see cref="T:System.Type" /> currently being inspected.</param>
      <param name="attributeList">The list of <see cref="T:LinFu.IoC.Configuration.FactoryAttribute" /> instances currently declared on on the source type.</param>
      <param name="getFactoryInstance">The functor that will be responsible for generating the factory instance.</param>
      <returns>A list of actions that will add the factories to the target container.</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.FactoryAttributeLoader.GetFactory(System.Type,System.Func{LinFu.IoC.Interfaces.IFactoryRequest,LinFu.IoC.Interfaces.IFactory},System.Collections.Generic.ICollection{System.Type})">
      <summary>
            Instantiates the given factory using the <paramref name="getStronglyTypedFactory">factory functor.</paramref></summary>
      <param name="currentServiceType">The service type that will be created by the factory.</param>
      <param name="getStronglyTypedFactory">The functor that will be responsible for creating the factory itself.</param>
      <param name="implementedInterfaces">The list of <see cref="T:LinFu.IoC.Interfaces.IFactory`1" /> interfaces that are implemented by the source type.</param>
      <returns>A valid factory instance.</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.FactoryAttributeLoader.CanLoad(System.Type)">
      <summary>
            Determines whether or not the current <paramref name="sourceType" />
            can be loaded.
            </summary>
      <param name="sourceType">The source type currently being loaded.</param>
      <returns>Returns <c>true</c> if the type is a class type; otherwise, it returns <c>false</c>.</returns>
    </member>
    <member name="T:LinFu.IoC.Configuration.Loaders.ImplementsAttributeLoader">
      <summary>
            A loader class that scans a type for <see cref="T:LinFu.IoC.Configuration.ImplementsAttribute" />
            attribute declarations and creates a factory for each corresponding 
            attribute instance.
            </summary>
      <seealso cref="T:LinFu.IoC.Interfaces.IFactory" />
    </member>
    <member name="M:LinFu.IoC.Configuration.Loaders.ImplementsAttributeLoader.Load(System.Type)">
      <summary>
            Converts a given <see cref="T:System.Type" /> into
            a set of <see cref="T:System.Action`1" /> instances so that
            the <see cref="T:LinFu.IoC.Interfaces.IContainer" /> instance can be loaded
            with the given factories.
            </summary>
      <param name="sourceType">The input type from which one or more factories will be created.</param>
      <returns>A set of <see cref="T:System.Action`1" /> instances. This cannot be null.</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.Loaders.ImplementsAttributeLoader.CreateFactory(System.Type,System.Type,LinFu.IoC.Configuration.LifecycleType)">
      <summary>
            Creates a factory instance that can create instaces of the given
            <paramref name="serviceType" />  using the <paramref name="implementingType" />
            as the implementation.
            </summary>
      <param name="serviceType">The service being implemented.</param>
      <param name="implementingType">The actual type that will implement the service.</param>
      <param name="lifecycle">The <see cref="T:LinFu.IoC.Configuration.LifecycleType" /> that determines the lifetime of each instance being created.</param>
      <returns>A valid <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance.</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.Loaders.ImplementsAttributeLoader.CanLoad(System.Type)">
      <summary>
            Determines whether or not the current <paramref name="sourceType" />
            can be loaded.
            </summary>
      <param name="sourceType">The source type currently being loaded.</param>
      <returns>Returns <c>true</c> if the type is a class type; otherwise, it returns <c>false</c>.</returns>
    </member>
    <member name="T:LinFu.IoC.Configuration.Loader">
      <summary>
            Represents a class that can dynamically configure
            <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" /> instances at runtime.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.Loader.#ctor">
      <summary>
            Initializes the loader using the default values.
            </summary>
    </member>
    <member name="P:LinFu.IoC.Configuration.Loader.AssemblyLoader">
      <summary>
            Gets or sets the value indicating the <see cref="T:LinFu.Reflection.IAssemblyLoader" /> instance
            that will be used to load assemblies into memory.
            </summary>
    </member>
    <member name="T:LinFu.IoC.Configuration.Loaders.PostProcessorLoader">
      <summary>
            A class that automatically loads <see cref="T:LinFu.IoC.Interfaces.IPostProcessor" />
            instances and configures a loader to inject those postprocessors
            into a container upon initialization.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.Loaders.PostProcessorLoader.CanLoad(System.Type)">
      <summary>
            Determines if the plugin loader can load the <paramref name="inputType" />.
            </summary>
      <remarks>The target type must implement the <see cref="T:LinFu.IoC.Interfaces.IPostProcessor" /> interface before it can be loaded into memory.</remarks>
      <param name="inputType">The target type that might contain the target instance.</param>
      <returns>
        <c>true</c> if the type can be loaded; otherwise, it returns <c>false</c>.</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.Loaders.PostProcessorLoader.Load(System.Type)">
      <summary>
            Loads a set of <see cref="T:LinFu.IoC.Interfaces.IPostProcessor" /> instances
            so that they can be loaded into a container upon initialization.
            </summary>
      <param name="inputType">The type that will be used to configure the target loader.</param>
      <returns>A set of <see cref="T:System.Action`1" /> instances. This cannot be <c>null</c>.</returns>
    </member>
    <member name="T:LinFu.IoC.Configuration.Loaders.PreProcessorLoader">
      <summary>
            A class that automatically loads <see cref="T:LinFu.IoC.Interfaces.IPreProcessor" />
            instances and configures a loader to inject those postprocessors
            into a container upon initialization.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.Loaders.PreProcessorLoader.CanLoad(System.Type)">
      <summary>
            Determines if the plugin loader can load the <paramref name="inputType" />.
            </summary>
      <remarks>The target type must implement the <see cref="T:LinFu.IoC.Interfaces.IPreProcessor" /> interface before it can be loaded into memory.</remarks>
      <param name="inputType">The target type that might contain the target instance.</param>
      <returns>
        <c>true</c> if the type can be loaded; otherwise, it returns <c>false</c>.</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.Loaders.PreProcessorLoader.Load(System.Type)">
      <summary>
            Loads a set of <see cref="T:LinFu.IoC.Interfaces.IPreProcessor" /> instances
            so that they can be loaded into a container upon initialization.
            </summary>
      <param name="inputType">The type that will be used to configure the target loader.</param>
      <returns>A set of <see cref="T:System.Action`1" /> instances. This cannot be <c>null</c>.</returns>
    </member>
    <member name="T:LinFu.IoC.Configuration.MethodBuilder">
      <summary>
            A class that dynamically generates calls to a <see cref="T:System.Reflection.MethodInfo" /> instance.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.MethodBuilder.PushInstance(System.Reflection.Emit.ILGenerator,System.Reflection.MethodInfo)">
      <summary>
            Pushes the method target onto the evaluation stack.
            </summary>
      <param name="IL">The <see cref="T:System.Reflection.Emit.ILGenerator" /> of the method body.</param>
      <param name="method">The target method.</param>
    </member>
    <member name="M:LinFu.IoC.Configuration.MethodBuilder.PushMethodArguments(System.Reflection.Emit.ILGenerator,System.Reflection.MethodBase)">
      <summary>
            Pushes the method arguments onto the stack.
            </summary>
      <param name="IL">The <see cref="T:System.Reflection.Emit.ILGenerator" /> of the target method body.</param>
      <param name="targetMethod">The target method that will be invoked.</param>
    </member>
    <member name="M:LinFu.IoC.Configuration.MethodBuilder.GetReturnType(System.Reflection.MethodInfo)">
      <summary>
            Determines the return type from the target <paramref name="method" />.
            </summary>
      <param name="method">The target method itself.</param>
      <returns>The method return type.</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.MethodBuilder.GetParameterList(System.Reflection.MethodInfo,System.Type[])">
      <summary>
            Determines the parameter types of the dynamically generated method.
            </summary>
      <param name="existingMethod">The target method.</param>
      <param name="parameterTypes">The target method argument types.</param>
      <returns>The list of <see cref="T:System.Type" /> objects that describe the signature of the method to generate.</returns>
      <remarks>This override will add an additional parameter type to accomodate the method target.</remarks>
    </member>
    <member name="M:LinFu.IoC.Configuration.MethodBuilder.EmitCall(System.Reflection.Emit.ILGenerator,System.Reflection.MethodInfo)">
      <summary>
            Emits the instruction to call the target <paramref name="method" /></summary>
      <param name="IL">The <see cref="T:System.Reflection.Emit.ILGenerator" /> of the target method body.</param>
      <param name="method">The method that will be invoked.</param>
    </member>
    <member name="T:LinFu.IoC.Configuration.MethodFinderContext">
      <summary>
            Represents the data associated with a <see cref="T:LinFu.IoC.Configuration.Interfaces.IMethodFinder`1" /> search.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.MethodFinderContext.#ctor(System.Object[])">
      <summary>
            Initializes the context with the default values.
            </summary>
      <param name="arguments">The list of arguments that will be passed to the target method.</param>
    </member>
    <member name="M:LinFu.IoC.Configuration.MethodFinderContext.#ctor(System.Collections.Generic.IEnumerable{System.Type},System.Collections.Generic.IEnumerable{System.Object},System.Type)">
      <summary>
            Initializes the context with the default values.
            </summary>
      <param name="typeArguments">The type arguments that will be used to construct the target method.</param>
      <param name="arguments">The list of arguments that will be passed to the target method.</param>
      <param name="returnType">The type that must be returned by the target method.</param>
    </member>
    <member name="P:LinFu.IoC.Configuration.MethodFinderContext.TypeArguments">
      <summary>
            Gets or sets the value indicating the type arguments that will be passed to the target method.
            </summary>
    </member>
    <member name="P:LinFu.IoC.Configuration.MethodFinderContext.Arguments">
      <summary>
            Gets or sets the value indicating the list of arguments that will be passed to the target method.
            </summary>
    </member>
    <member name="P:LinFu.IoC.Configuration.MethodFinderContext.ReturnType">
      <summary>
            Gets or sets the value indicating the <see cref="T:System.Type">return type</see> of the target method.
            </summary>
    </member>
    <member name="T:LinFu.IoC.Configuration.MethodInvoke">
      <summary>
            A class that invokes methods.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.MethodInvoke.#ctor">
      <summary>
            Initializes the class with the default values.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.MethodInvoke.DoInvoke(System.Object,System.Reflection.MethodInfo,System.Reflection.MethodBase,System.Object[])">
      <summary>
            Invokes the <paramref name="targetMethod" /> with the given <paramref name="arguments" />.
            </summary>
      <param name="target">The target instance.</param>
      <param name="originalMethod">The original method that describes the target method.</param>
      <param name="targetMethod">The actual method that will be invoked.</param>
      <param name="arguments">The method arguments.</param>
      <returns>The return value from the target method.</returns>
    </member>
    <member name="T:LinFu.IoC.Configuration.Interfaces.IPropertySetter">
      <summary>
            A class responsible for setting property values.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.Interfaces.IPropertySetter.Set(System.Object,System.Reflection.PropertyInfo,System.Object)">
      <summary>
            Sets the value of the <paramref name="targetProperty" />.
            </summary>
            /// <param name="target">The target instance that contains the property to be modified.</param><param name="targetProperty">The property that will store the given value.</param><param name="value">The value that will be assigned to the property.</param></member>
    <member name="T:LinFu.IoC.Configuration.PropertySetter">
      <summary>
            A class responsible for setting property values.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.PropertySetter.Set(System.Object,System.Reflection.PropertyInfo,System.Object)">
      <summary>
            Sets the value of the <paramref name="targetProperty" />.
            </summary>
      <param name="target">The target instance that contains the property to be modified.</param>
      <param name="targetProperty">The property that will store the given value.</param>
      <param name="value">The value that will be assigned to the property.</param>
    </member>
    <member name="M:LinFu.IoC.Configuration.PropertySetter.GenerateSetter(System.Reflection.PropertyInfo)">
      <summary>
            Generates an <see cref="T:System.Action`2" /> delegate that will be used
            as the property setter for a particular type.
            </summary>
      <param name="targetProperty">The property that will be modified.</param>
      <returns>A property setter.</returns>
    </member>
    <member name="T:LinFu.IoC.Configuration.RecursiveDependencyException">
      <summary>
            The exception thrown when a recursive dependency is detected
            inside a <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" /> instance.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.RecursiveDependencyException.#ctor(System.Collections.Generic.LinkedList{System.Type})">
      <summary>
            Initializes the <see cref="T:LinFu.IoC.Configuration.RecursiveDependencyException" />
            class with the <paramref name="typeChain">chain</paramref>
            of depedencies that caused the exception.
            </summary>
      <param name="typeChain">The sequence of types that caused the dependency exception.</param>
    </member>
    <member name="P:LinFu.IoC.Configuration.RecursiveDependencyException.TypeChain">
      <summary>
            Gets the value indicating the chain of types that caused the exception.
            </summary>
    </member>
    <member name="P:LinFu.IoC.Configuration.RecursiveDependencyException.Message">
      <summary>
            Gets the value indicating the error message from the <see cref="T:LinFu.IoC.Configuration.RecursiveDependencyException" />.
            </summary>
    </member>
    <member name="T:LinFu.IoC.Configuration.ReflectionMethodBuilder`1">
      <summary>
            Represents a <see cref="T:LinFu.IoC.Configuration.Interfaces.IMethodBuilder`1" /> type that simply lets 
            methods pass through it without performing any modifications to those methods.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.ReflectionMethodBuilder`1.CreateMethod(`0)">
      <summary>
            Returns the <paramref name="existingMethod" /> unmodified.
            </summary>
      <param name="existingMethod">The method to be modified.</param>
      <returns>The modified method.</returns>
    </member>
    <member name="T:LinFu.IoC.Configuration.Interfaces.IArgumentResolver">
      <summary>
            Represents a type that can generate method arguments
            from an existing <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" /> instance.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.Interfaces.IArgumentResolver.ResolveFrom(System.Collections.Generic.IEnumerable{System.Type},LinFu.IoC.Interfaces.IServiceContainer,System.Object[])">
      <summary>
            Generates constructor arguments from the given <paramref name="parameterTypes" />
            and <paramref name="container" />.
            </summary>
      <param name="parameterTypes">The parameter types for the target method.</param>
      <param name="container">The container that will provide the method arguments.</param>
      <param name="additionalArguments">The additional arguments that will be passed to the target method.</param>
      <returns>An array of objects that represent the arguments to be passed to the target method.</returns>
    </member>
    <member name="T:LinFu.IoC.Configuration.ArgumentResolver">
      <summary>
            Represents the default implementation of the <see cref="T:LinFu.IoC.Configuration.Interfaces.IArgumentResolver" /> class.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.ArgumentResolver.ResolveFrom(System.Collections.Generic.IEnumerable{System.Type},LinFu.IoC.Interfaces.IServiceContainer,System.Object[])">
      <summary>
            Generates method arguments from the given <paramref name="parameterTypes" />
            and <paramref name="container" />.
            </summary>
      <param name="parameterTypes">The parameter types for the target method.</param>
      <param name="container">The container that will provide the method arguments.</param>
      <param name="additionalArguments">The additional arguments that will be passed to the target method.</param>
      <returns>An array of objects that represent the arguments to be passed to the target method.</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.ArgumentResolver.AddArrayArgument(System.Type,LinFu.IoC.Interfaces.IServiceContainer,System.Collections.Generic.ICollection{System.Object})">
      <summary>
            Constructs an array of services using the services currently available
            in the <paramref name="container" />.
            </summary>
      <param name="parameterType">The current parameter type.</param>
      <param name="container">The container that will be used to build the array of services.</param>
      <param name="argumentList">The list that will store new service array.</param>
    </member>
    <member name="M:LinFu.IoC.Configuration.ArgumentResolver.AddEnumerableArgument(System.Type,LinFu.IoC.Interfaces.IServiceContainer,System.Collections.Generic.ICollection{System.Object})">
      <summary>
            Determines whether or not a parameter type is an existing
            list of available services and automatically constructs the
            service list and adds it to the <paramref name="argumentList" />.
            </summary>
      <param name="parameterType">The current constructor parameter type.</param>
      <param name="container">The container that will provide the argument values.</param>
      <param name="argumentList">The list that will hold the arguments to be passed to the constructor.</param>
    </member>
    <member name="T:LinFu.IoC.Configuration.Interfaces.IMemberResolver`1">
      <summary>
            Represents a class that can choose a member that best matches
            the services currently available in a given <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" /> instance.
            </summary>
      <typeparam name="TMember">The member type that will be searched.</typeparam>
    </member>
    <member name="M:LinFu.IoC.Configuration.Interfaces.IMemberResolver`1.ResolveFrom(System.Type,LinFu.IoC.Interfaces.IServiceContainer,LinFu.IoC.Configuration.Interfaces.IMethodFinderContext)">
      <summary>
            Uses the <paramref name="container" /> to determine which member can be used to instantiate
            a <paramref name="concreteType">concrete type</paramref>.
            </summary>
      <param name="concreteType">The target type.</param>
      <param name="container">The container that contains the service instances that will be used to invoke the target member.</param>
      <param name="finderContext">The <see cref="T:LinFu.IoC.Configuration.Interfaces.IMethodFinderContext" /> that describes the target method.</param>
      <returns>A <typeparamref name="TMember" /> instance if a match is found; otherwise, it will return <c>null</c>.</returns>
    </member>
    <member name="T:LinFu.IoC.Configuration.MemberResolver`1">
      <summary>
            Represents a class that can choose a member that best matches
            the services currently available in a given <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" /> instance.
            </summary>
      <typeparam name="TMember">The member type that will be searched.</typeparam>
    </member>
    <member name="M:LinFu.IoC.Configuration.MemberResolver`1.#ctor">
      <summary>
            The default constructor for the <see cref="T:LinFu.IoC.Configuration.MemberResolver`1" /> class.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.MemberResolver`1.#ctor(System.Func{LinFu.IoC.Interfaces.IServiceContainer,LinFu.IoC.Configuration.Interfaces.IMethodFinder{`0}})">
      <summary>
            Initializes the class with a <paramref name="getFinder">functor</paramref>
            that will be used to instantiate the method finder that will be used in the search.
            </summary>
      <param name="getFinder">The functor that will be used to instantiate the method finder.</param>
    </member>
    <member name="M:LinFu.IoC.Configuration.MemberResolver`1.ResolveFrom(System.Type,LinFu.IoC.Interfaces.IServiceContainer,LinFu.IoC.Configuration.Interfaces.IMethodFinderContext)">
      <summary>
            Uses the <paramref name="container" /> to determine which member to use from
            the <paramref name="concreteType">concrete type</paramref>.
            </summary>
      <param name="concreteType">The target type.</param>
      <param name="container">The container that contains the member values that will be used to invoke the members.</param>
      <param name="finderContext">The <see cref="T:LinFu.IoC.Configuration.Interfaces.IMethodFinderContext" /> that describes the target method.</param>
      <returns>A member instance if a match is found; otherwise, it will return <c>null</c>.</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.MemberResolver`1.GetMethodFinder(LinFu.IoC.Interfaces.IServiceContainer)">
      <summary>
            Determines the <see cref="T:LinFu.IoC.Configuration.Interfaces.IMethodFinder`1" /> that will be used
            in the method search.
            </summary>
      <param name="container">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.MemberResolver`1.GetDefaultResult(System.Type)">
      <summary>
            The method used to retrieve the default result if no
            other alternative is found.
            </summary>
      <param name="concreteType">The target type that contains the default member.</param>
      <returns>The default member result.</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.MemberResolver`1.GetMembers(System.Type)">
      <summary>
            Lists the members associated with the <paramref name="concreteType" />.
            </summary>
      <param name="concreteType">The target type that contains the type members.</param>
      <returns>A list of members that belong to the concrete type.</returns>
    </member>
    <member name="T:LinFu.IoC.Configuration.ConstructorResolver">
      <summary>
            Represents the default implementation of the <see cref="T:LinFu.IoC.Configuration.Interfaces.IMemberResolver`1" /> class.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.ConstructorResolver.#ctor">
      <summary>
            Initializes the class with the default values.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.ConstructorResolver.#ctor(System.Func{LinFu.IoC.Interfaces.IServiceContainer,LinFu.IoC.Configuration.Interfaces.IMethodFinder{System.Reflection.ConstructorInfo}})">
      <summary>
            Initializes the class using the custom method finder.
            </summary>
      <param name="getFinder">The functor that will be used to instantiate the method finder.</param>
    </member>
    <member name="M:LinFu.IoC.Configuration.ConstructorResolver.GetMembers(System.Type)">
      <summary>
            Returns the constructors that belong to the <paramref name="concreteType" />.
            </summary>
      <param name="concreteType">The type that contains the list of constructors.</param>
      <returns>A list of constructors that belong to the <paramref name="concreteType" />.</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.ConstructorResolver.GetDefaultResult(System.Type)">
      <summary>
            Returns the parameterless constructor in case the search fails.
            </summary>
      <param name="concreteType">The target type that contains the default constructor.</param>
      <returns>The default constructor.</returns>
    </member>
    <member name="T:LinFu.IoC.Configuration.MethodFinder`1">
      <summary>
            Represents a class that determines which method best matches the
            services currently in the target container.
            </summary>
      <typeparam name="T">The method type to search.</typeparam>
    </member>
    <member name="M:LinFu.IoC.Configuration.MethodFinder`1.GetBestMatch(System.Collections.Generic.IEnumerable{`0},LinFu.IoC.Configuration.Interfaces.IMethodFinderContext)">
      <summary>
            Determines which method best matches the
            services currently in the target container.
            </summary>
      <param name="items">The list of methods to search.</param>
      <param name="finderContext">The <see cref="T:LinFu.IoC.Configuration.Interfaces.IMethodFinderContext" /> that describes the target method.</param>
      <returns>Returns the method with the most resolvable parameters from the target <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" /> instance.</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.MethodFinder`1.SelectBestMatch(System.Collections.Generic.IEnumerable{LinFu.Finders.Interfaces.IFuzzyItem{`0}})">
      <summary>
            Determines which item among the <paramref name="candidates" /> is the best match.
            </summary>
      <param name="candidates">The list of possible matches.</param>
      <returns>The best match if found; otherwise, it should return <c>null</c>.</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.MethodFinder`1.Rank(System.Collections.Generic.IList{LinFu.Finders.Interfaces.IFuzzyItem{`0}},LinFu.IoC.Configuration.Interfaces.IMethodFinderContext)">
      <summary>
            Adds additional <see cref="T:LinFu.Finders.Interfaces.ICriteria`1" /> to the fuzzy search list.
            </summary>
      <param name="methods">The list of methods to rank.</param>
      <param name="finderContext">The <see cref="T:LinFu.IoC.Configuration.Interfaces.IMethodFinderContext" /> that describes the target method.</param>
    </member>
    <member name="M:LinFu.IoC.Configuration.MethodFinder`1.CheckArguments(System.Collections.Generic.IList{LinFu.Finders.Interfaces.IFuzzyItem{`0}},System.Collections.Generic.IEnumerable{System.Type})">
      <summary>
            Attempts to match the <paramref name="additionalArgumentTypes" /> against the <paramref name="fuzzyList">list of methods</paramref>.
            </summary>
      <param name="fuzzyList">The list of items currently being compared.</param>
      <param name="additionalArgumentTypes">The set of <see cref="T:System.Type" /> instances that describe each supplied argument type.</param>
    </member>
    <member name="T:LinFu.IoC.Configuration.Resolvers.MethodFinderFromContainer`1">
      <summary>
            A <see cref="T:LinFu.IoC.Configuration.MethodFinder`1" /> type that uses a <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" />
            instance to find a method with the most resolvable parameters.
            </summary>
      <typeparam name="TMethod">The method type that will be searched.</typeparam>
    </member>
    <member name="M:LinFu.IoC.Configuration.Resolvers.MethodFinderFromContainer`1.CheckParameters(LinFu.Finders.Interfaces.IFuzzyItem{`0},LinFu.IoC.Interfaces.IServiceContainer,System.Int32)">
      <summary>
            Examines a <see cref="T:System.Reflection.ConstructorInfo" /> instance
            and determines if it can be instantiated with the services embedded in
            the target <paramref name="container" />.
            </summary>
      <param name="fuzzyItem">The <see cref="T:LinFu.Finders.FuzzyItem`1" /> that represents the constructor to be examined.</param>
      <param name="container">The container that contains the services that will be used to instantiate the target type.</param>
      <param name="maxIndex">Indicates the index that 
            marks the point where the user-supplied arguments begin.</param>
    </member>
    <member name="M:LinFu.IoC.Configuration.Resolvers.MethodFinderFromContainer`1.Rank(System.Collections.Generic.IList{LinFu.Finders.Interfaces.IFuzzyItem{`0}},LinFu.IoC.Configuration.Interfaces.IMethodFinderContext)">
      <summary>
            Adds additional <see cref="T:LinFu.Finders.Interfaces.ICriteria`1" /> to the fuzzy search list.
            </summary>
      <param name="methods">The list of methods to rank.</param>
      <param name="finderContext">The <see cref="T:LinFu.IoC.Configuration.Interfaces.IMethodFinderContext" /> that describes the target method.</param>
    </member>
    <member name="M:LinFu.IoC.Configuration.Resolvers.MethodFinderFromContainer`1.Initialize(LinFu.IoC.Interfaces.IServiceContainer)">
      <summary>
            Initializes the target with the host container.
            </summary>
      <param name="container">The host <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" /> instance.</param>
    </member>
    <member name="P:LinFu.IoC.Configuration.Resolvers.MethodFinderFromContainer`1.Container">
      <summary>
            Gets the value indicating the service container that will be used in the
            method search.
            </summary>
    </member>
    <member name="T:LinFu.IoC.Interfaces.IServiceInstance">
      <summary>
            A type that represents a service instance returned by a container.
            </summary>
    </member>
    <member name="P:LinFu.IoC.Interfaces.IServiceInstance.ServiceInfo">
      <summary>
            Gets the value indicating the <see cref="T:LinFu.IoC.Interfaces.IServiceInfo" /> instance 
            that describes the service instance itself.
            </summary>
    </member>
    <member name="P:LinFu.IoC.Interfaces.IServiceInstance.Object">
      <summary>
            Gets the value indicating the service instance itself.
            </summary>
    </member>
    <member name="T:LinFu.IoC.Configuration.ServiceInstance">
      <summary>
            Represents the default implementation of the <see cref="T:LinFu.IoC.Interfaces.IServiceInstance" /> interface.
            </summary>
    </member>
    <member name="T:LinFu.IoC.Configuration.TypeCounter">
      <summary>
            Counts the number of occurrences of a specific type.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Configuration.TypeCounter.Increment(System.Type)">
      <summary>
            Increments the count for the current <paramref name="type" />.
            </summary>
      <param name="type">The type being counted.</param>
    </member>
    <member name="M:LinFu.IoC.Configuration.TypeCounter.CountOf(System.Type)">
      <summary>
            Returns the number of occurrences of a specific <paramref name="type" />.
            </summary>
      <param name="type">The type being counted.</param>
      <returns>The number of occurrences for the given type.</returns>
    </member>
    <member name="M:LinFu.IoC.Configuration.TypeCounter.Decrement(System.Type)">
      <summary>
            Decrements the count for the current <paramref name="type" />.
            </summary>
      <param name="type">The type being counted.</param>
    </member>
    <member name="M:LinFu.IoC.Configuration.TypeCounter.Reset">
      <summary>
            Resets the counts back to zero.
            </summary>
    </member>
    <member name="P:LinFu.IoC.Configuration.TypeCounter.AvailableTypes">
      <summary>
            Gets the value indicating the types that are
            currently being counted.
            </summary>
    </member>
    <member name="T:LinFu.IoC.Interfaces.ICreateInstance">
      <summary>
            Represents a type that can create service instances from a given <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance and <see cref="T:LinFu.IoC.Interfaces.IFactoryRequest" />.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Interfaces.ICreateInstance.CreateFrom(LinFu.IoC.Interfaces.IFactoryRequest,LinFu.IoC.Interfaces.IFactory)">
      <summary>
            Creates a service instance using the given <paramref name="factoryRequest" /> and <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance.
            </summary>
      <param name="factoryRequest">The <see cref="T:LinFu.IoC.Interfaces.IFactoryRequest" /> instance that describes the context of the service request.</param>
      <param name="factory">The <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance that will be used to instantiate the service type.</param>
      <returns>A valid service instance.</returns>
    </member>
    <member name="T:LinFu.IoC.CreatorFromInstance">
      <summary>
            Represents an <see cref="T:LinFu.IoC.Interfaces.ICreateInstance" /> type that generates an object instance from an existing instance.
            </summary>
    </member>
    <member name="M:LinFu.IoC.CreatorFromInstance.#ctor(System.Object)">
      <summary>
            Initializes the class with the target <paramref name="instance" />.
            </summary>
      <param name="instance">The instance that will be returned every time the <see cref="M:LinFu.IoC.CreatorFromInstance.CreateFrom(LinFu.IoC.Interfaces.IFactoryRequest,LinFu.IoC.Interfaces.IFactory)" /> method is called.</param>
    </member>
    <member name="M:LinFu.IoC.CreatorFromInstance.CreateFrom(LinFu.IoC.Interfaces.IFactoryRequest,LinFu.IoC.Interfaces.IFactory)">
      <summary>
            Returns the object instance that given when the <see cref="T:LinFu.IoC.CreatorFromInstance" /> class instance was initialized.
            </summary>
      <param name="factoryRequest">The <see cref="T:LinFu.IoC.Interfaces.IFactoryRequest" /> instance that describes the context of the service request.</param>
      <param name="factory">The <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance that will be used to instantiate the service type.</param>
      <returns>A valid service instance.</returns>
    </member>
    <member name="T:LinFu.IoC.DefaultCreator">
      <summary>
            Represents the default implementation for the <see cref="T:LinFu.IoC.Interfaces.ICreateInstance" /></summary>
    </member>
    <member name="M:LinFu.IoC.DefaultCreator.CreateFrom(LinFu.IoC.Interfaces.IFactoryRequest,LinFu.IoC.Interfaces.IFactory)">
      <summary>
            Creates a service instance using the given <paramref name="factoryRequest" /> and <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance.
            </summary>
      <param name="factoryRequest">The <see cref="T:LinFu.IoC.Interfaces.IFactoryRequest" /> instance that describes the context of the service request.</param>
      <param name="factory">The <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance that will be used to instantiate the service type.</param>
      <returns>A valid service instance.</returns>
    </member>
    <member name="T:LinFu.IoC.Interfaces.IGetService">
      <summary>
            Represents a class that determines the behavior a <see cref="T:LinFu.IoC.ServiceContainer" /> instance.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Interfaces.IGetService.GetService(LinFu.IoC.Interfaces.IServiceRequest)">
      <summary>
            Causes the container to instantiate the service using the given
            <paramref name="serviceRequest">service request</paramref>. If the service type cannot be created, it will simply return null.
            </summary>
      <returns>A valid object reference if the service can be created; otherwise, it will return <c>null</c></returns>
    </member>
    <member name="T:LinFu.IoC.DefaultGetServiceBehavior">
      <summary>
            Represents the default implementation for the <see cref="T:LinFu.IoC.Interfaces.IGetService" /> interface.
            </summary>
    </member>
    <member name="M:LinFu.IoC.DefaultGetServiceBehavior.#ctor(LinFu.IoC.Interfaces.IServiceContainer)">
      <summary>
            Initializes the class with the given <paramref name="container" /> instance.
            </summary>
      <param name="container">The target service container.</param>
    </member>
    <member name="M:LinFu.IoC.DefaultGetServiceBehavior.#ctor(LinFu.IoC.Interfaces.IServiceContainer,LinFu.IoC.Interfaces.ICreateInstance,LinFu.IoC.Interfaces.IPreProcessor,LinFu.IoC.Interfaces.IPostProcessor)">
      <summary>
            Initializes the class with the given <paramref name="container" /> instance.
            </summary>
      <param name="container">The target service container.</param>
      <param name="creator">The <see cref="T:LinFu.IoC.Interfaces.ICreateInstance" /> instance responsible for instantiating service types.</param>
      <param name="preProcessor">The <see cref="T:LinFu.IoC.Interfaces.IPreProcessor" /> that will allow users to intercept a given service request.</param>
      <param name="postProcessor">The <see cref="T:LinFu.IoC.Interfaces.IPostProcessor" /> instance that will handle the results of a given service request.</param>
    </member>
    <member name="M:LinFu.IoC.DefaultGetServiceBehavior.GetService(LinFu.IoC.Interfaces.IServiceRequest)">
      <summary>
            Instantiates the service described by the <paramref name="serviceRequest" />.
            </summary>
      <param name="serviceRequest">The <see cref="T:LinFu.IoC.Interfaces.IServiceRequest" /> that describes the service that needs to be instantiated.</param>
      <returns>A valid object reference if the service can be found; otherwise, it will return <c>null</c>.</returns>
    </member>
    <member name="T:LinFu.IoC.Interfaces.IFactory`1">
      <summary>
            A strongly-typed version of <see cref="T:LinFu.IoC.Interfaces.IFactory" />. Allows users
            to create their own service instances
            </summary>
      <typeparam name="T">The instance type that can be created by this factory.</typeparam>
    </member>
    <member name="M:LinFu.IoC.Interfaces.IFactory`1.CreateInstance(LinFu.IoC.Interfaces.IFactoryRequest)">
      <summary>
            Creates a service instance using the given <see cref="T:LinFu.IoC.Interfaces.IFactoryRequest" /> instance.
            </summary>
      <param name="request">The <see cref="T:LinFu.IoC.Interfaces.IFactoryRequest" /> instance that describes the requested service.</param>
      <returns>An object instance that represents the service to be created. This cannot be <c>null</c>.</returns>
    </member>
    <member name="T:LinFu.IoC.Factories.BaseFactory`1">
      <summary>
            A factory base class that combines both the IFactory and
            the IFactory&lt;T&gt; interfaces into a single class.
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="M:LinFu.IoC.Factories.BaseFactory`1.CreateInstance(LinFu.IoC.Interfaces.IFactoryRequest)">
      <summary>
            Creates a service instance using the given container.
            </summary>
      <remarks>
        <see cref="T:LinFu.IoC.Interfaces.IFactory" /> developers can inherit from this class
            instead of having to write their own custom factories
            from scratch. This should cut down on some of the boilerplate
            code necessary to get a factory class up and running.
            </remarks>
      <param name="request">The <see cref="T:LinFu.IoC.Interfaces.IFactoryRequest" /> instance that describes the requested service.</param>
      <returns>An object instance that represents the service to be created. This cannot be <c>null</c>.</returns>
    </member>
    <member name="T:LinFu.IoC.Factories.DelegateFactory">
      <summary>
            Represents a class that uses a <see cref="T:System.MulticastDelegate" />
            to instantiate a service instance.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Factories.DelegateFactory.#ctor(System.MulticastDelegate)">
      <summary>
            Initializes the class with the given <paramref name="targetDelegate" /></summary>
      <param name="targetDelegate">The delegate that will be used to instantiate the factory.</param>
    </member>
    <member name="M:LinFu.IoC.Factories.DelegateFactory.CreateInstance(LinFu.IoC.Interfaces.IFactoryRequest)">
      <summary>
            Instantiates the service type using the given delegate.
            </summary>
      <param name="request">The <see cref="T:LinFu.IoC.Interfaces.IFactoryRequest" /> that describes the service that needs to be created.</param>
      <returns>The service instance.</returns>
    </member>
    <member name="T:LinFu.IoC.FactoryAdapter`1">
      <summary>
            An adapter that converts strongly-typed IFactory&lt;T&gt; 
            instances into an equivalent IFactory instance.
            </summary>
      <typeparam name="T">The service type to create.</typeparam>
    </member>
    <member name="M:LinFu.IoC.FactoryAdapter`1.#ctor(System.Object)">
      <summary>
            Creates the factory adapter using the given
            IFactory&lt;T&gt; instance.
            </summary>
      <param name="factory">The factory instance that
            will be called every time the <see cref="M:LinFu.IoC.Interfaces.IFactory.CreateInstance(LinFu.IoC.Interfaces.IFactoryRequest)" /> method
            is called. </param>
    </member>
    <member name="M:LinFu.IoC.FactoryAdapter`1.CreateInstance(LinFu.IoC.Interfaces.IFactoryRequest)">
      <summary>
            Overridden. Uses the strongly-typed factory
            to create the service instance every time
            the <see cref="M:LinFu.IoC.Interfaces.IFactory.CreateInstance(LinFu.IoC.Interfaces.IFactoryRequest)" /> method 
            is called.
            </summary>
      <param name="request">The <see cref="T:LinFu.IoC.Interfaces.IFactoryRequest" /> instance that describes the requested service.</param>
      <returns>An object instance that represents the service to be created. This cannot be <c>null</c>.</returns>
    </member>
    <member name="P:LinFu.IoC.FactoryAdapter`1.Factory">
      <summary>
            The factory that will create the service instance.
            </summary>
    </member>
    <member name="T:LinFu.IoC.Factories.FunctorFactory">
      <summary>
            A class that converts a delegate into an <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Factories.FunctorFactory.#ctor(System.Func{LinFu.IoC.Interfaces.IFactoryRequest,System.Object})">
      <summary>
            Initializes the class with the given <paramref name="factoryMethod" />.
            </summary>
      <param name="factoryMethod">The delegate that will be used to instantiate a type.</param>
    </member>
    <member name="M:LinFu.IoC.Factories.FunctorFactory.CreateInstance(LinFu.IoC.Interfaces.IFactoryRequest)">
      <summary>
            Instantiates an object reference using the given factory method.
            </summary>
      <param name="request">The <see cref="T:LinFu.IoC.Interfaces.IFactoryRequest" /> instance that describes the requested service.</param>
      <returns>A non-null object reference that represents the service type.</returns>
    </member>
    <member name="T:LinFu.IoC.InstanceFactory">
      <summary>
            A factory that uses an existing object reference
            instead of creating a new service.
            </summary>
    </member>
    <member name="M:LinFu.IoC.InstanceFactory.#ctor(System.Object)">
      <summary>
            Creates a factory using the existing <paramref name="instance" />.
            </summary>
      <param name="instance">The existing object reference that the factory will return.</param>
    </member>
    <member name="M:LinFu.IoC.InstanceFactory.CreateInstance(LinFu.IoC.Interfaces.IFactoryRequest)">
      <summary>
            A method that returns the existing object reference associated with
            this factory. 
            </summary>
      <param name="request">The <see cref="T:LinFu.IoC.Interfaces.IFactoryRequest" /> instance that describes the requested service.</param>
      <returns>A non-null object reference.</returns>
    </member>
    <member name="T:LinFu.IoC.Factories.LazyFactory">
      <summary>
            Represents an <see cref="T:LinFu.IoC.Interfaces.IFactory" /> class that instantiates a factory only on request.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Factories.LazyFactory.#ctor(System.Func{LinFu.IoC.Interfaces.IFactoryRequest,LinFu.IoC.Interfaces.IFactory})">
      <summary>
            Instantiates the class with the factory functor method.
            </summary>
      <param name="getFactory">The functor that will be responsible for instantiating the actual factory.</param>
    </member>
    <member name="M:LinFu.IoC.Factories.LazyFactory.CreateInstance(LinFu.IoC.Interfaces.IFactoryRequest)">
      <summary>
            Instantiates the actual factory instance and uses it to instantiate the target service type.
            </summary>
      <param name="request">The <see cref="T:LinFu.IoC.Interfaces.IFactoryRequest" /> that describes the service to be created.</param>
      <returns>A valid service instance.</returns>
    </member>
    <member name="T:LinFu.IoC.Factories.LazyFactory`1">
      <summary>
            Represents a factory that returns strongly-typed IFactory instances.
            </summary>
      <typeparam name="T">The service type to be created.</typeparam>
    </member>
    <member name="M:LinFu.IoC.Factories.LazyFactory`1.#ctor(System.Func{LinFu.IoC.Interfaces.IFactoryRequest,LinFu.IoC.Interfaces.IFactory})">
      <summary>
            Initializes the factory with the given <paramref name="getFactory" /> functor.
            </summary>
      <param name="getFactory">The functor that will instantiate the actual factory instance.</param>
    </member>
    <member name="M:LinFu.IoC.Factories.LazyFactory`1.CreateInstance(LinFu.IoC.Interfaces.IFactoryRequest)">
      <summary>
            Instantiates the service type using the actual factory.
            </summary>
      <param name="request">The <see cref="T:LinFu.IoC.Interfaces.IFactoryRequest" /> instance that describes the service to be created.</param>
      <returns>
      </returns>
    </member>
    <member name="T:LinFu.IoC.Factories.OncePerRequestFactory`1">
      <summary>
            A factory that creates a unique service instance every time
            the <see cref="M:LinFu.IoC.Factories.OncePerRequestFactory`1.CreateInstance(LinFu.IoC.Interfaces.IFactoryRequest)" /> method is called.
            </summary>
      <typeparam name="T">The type of service to instantiate.</typeparam>
    </member>
    <member name="M:LinFu.IoC.Factories.OncePerRequestFactory`1.#ctor(System.Func{LinFu.IoC.Interfaces.IFactoryRequest,`0})">
      <summary>
            Initializes the factory class using the <paramref name="createInstance" />
            parameter as a factory delegate.
            </summary>
      <example>
            The following is an example of initializing a <c>OncePerRequestFactory&lt;T&gt;</c>
            type:
            <code>
                // Define the factory delegate
                Func&lt;IFactoryRequest, ISomeService&gt; createService = container=&gt;new SomeServiceImplementation();
            
                // Create the factory
                var factory = new OncePerRequestFactory&lt;ISomeService&gt;(createService);
            
                // Use the service instance
                var service = factory.CreateInstance(null);
                
                // ...
            </code></example>
      <param name="createInstance">The delegate that will be used to create each new service instance.</param>
    </member>
    <member name="M:LinFu.IoC.Factories.OncePerRequestFactory`1.CreateInstance(LinFu.IoC.Interfaces.IFactoryRequest)">
      <summary>
            This method creates a new service instance every time
            it is invoked. 
            </summary>
      <param name="request">The <see cref="T:LinFu.IoC.Interfaces.IFactoryRequest" /> instance that describes the requested service.</param>
      <returns>A non-null object reference.</returns>
    </member>
    <member name="T:LinFu.IoC.Factories.OncePerThreadFactory`1">
      <summary>
            A factory that creates service instances that are unique
            from within the same thread as the factory itself.
            </summary>
      <typeparam name="T">The type of service to instantiate.</typeparam>
    </member>
    <member name="M:LinFu.IoC.Factories.OncePerThreadFactory`1.#ctor(System.Func{LinFu.IoC.Interfaces.IFactoryRequest,`0})">
      <summary>
            Initializes the factory class using the <paramref name="createInstance" />
            parameter as a factory delegate.
            </summary>
      <example>
            The following is an example of initializing a <c>OncePerThreadFactory&lt;T&gt;</c>
            type:
            <code>
                // Define the factory delegate
                Func&lt;IFactoryRequest, ISomeService&gt; createService = container=&gt;new SomeServiceImplementation();
            
                // Create the factory
                var factory = new OncePerThreadFactory&lt;ISomeService&gt;(createService);
            
                // Use the service instance
                var service = factory.CreateInstance(null);
                
                // ...
            </code></example>
      <param name="createInstance">The delegate that will be used to create each new service instance.</param>
    </member>
    <member name="M:LinFu.IoC.Factories.OncePerThreadFactory`1.CreateInstance(LinFu.IoC.Interfaces.IFactoryRequest)">
      <summary>
            Creates the service instance using the given <see cref="T:LinFu.IoC.Interfaces.IFactoryRequest" />
            instance. Every service instance created from this factory will
            only be created once per thread.
            </summary>
      <param name="request">The <see cref="T:LinFu.IoC.Interfaces.IFactoryRequest" /> instance that describes the requested service.</param>
      <returns>A a service instance as thread-wide singleton.</returns>
    </member>
    <member name="T:LinFu.IoC.Factories.SingletonFactory`1">
      <summary>
            A factory that creates Singletons. Each service that this factory creates will only be created once per concrete type.
            </summary>
      <typeparam name="T">The type of service to instantiate.</typeparam>
    </member>
    <member name="M:LinFu.IoC.Factories.SingletonFactory`1.#ctor(System.Func{LinFu.IoC.Interfaces.IFactoryRequest,`0})">
      <summary>
            Initializes the factory class using the <paramref name="createInstance" />
            parameter as a factory delegate.
            </summary>
      <example>
            The following is an example of initializing a <c>SingletonFactory&lt;T&gt;</c>
            type:
            <code>
                // Define the factory delegate
                Func&lt;IFactoryRequest, ISomeService&gt; createService = container=&gt;new SomeServiceImplementation();
            
                // Create the factory
                var factory = new SingletonFactory&lt;ISomeService&gt;(createService);
            
                // Use the service instance
                var service = factory.CreateInstance(null);
                
                // ...
            </code></example>
      <param name="createInstance">The delegate that will be used to create each new service instance.</param>
    </member>
    <member name="M:LinFu.IoC.Factories.SingletonFactory`1.CreateInstance(LinFu.IoC.Interfaces.IFactoryRequest)">
      <summary>
            A method that creates a service instance as a singleton.
            </summary>
      <param name="request">The <see cref="T:LinFu.IoC.Interfaces.IFactoryRequest" /> instance that describes the requested service.</param>
      <returns>A service instance as a singleton.</returns>
    </member>
    <member name="T:LinFu.IoC.FactoryExtensions">
      <summary>
            Extends the <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance with a few helper methods.
            </summary>
    </member>
    <member name="M:LinFu.IoC.FactoryExtensions.CreateInstance(LinFu.IoC.Interfaces.IFactory,System.Type,LinFu.IoC.Interfaces.IServiceContainer,System.Object[])">
      <summary>
            Creates an object instance.
            </summary>
      <param name="factory">The target factory.</param>
      <param name="serviceType">The requested service type.</param>
      <param name="container">The target service contaienr.</param>
      <param name="additionalArguments">The additional arguments that will be used to create the service instance.</param>
      <returns>A service instance.</returns>
    </member>
    <member name="T:LinFu.IoC.FactoryRequest">
      <summary>
            Represents the default implementation of the <see cref="T:LinFu.IoC.Interfaces.IFactoryRequest" /> interface.
            </summary>
    </member>
    <member name="P:LinFu.IoC.FactoryRequest.Container">
      <summary>
            Gets the value indicating the service container that made the service request.
            </summary>
    </member>
    <member name="P:LinFu.IoC.FactoryRequest.ServiceName">
      <summary>
            Gets the value indicating the service name.
            </summary>
      <remarks>A null service name indicates that no service name was given during the request.</remarks>
    </member>
    <member name="P:LinFu.IoC.FactoryRequest.ServiceType">
      <summary>
            Gets the value indicating the requested service type.
            </summary>
    </member>
    <member name="P:LinFu.IoC.FactoryRequest.Arguments">
      <summary>
            Gets the value indicating the additional arguments given in the factory request.
            </summary>
    </member>
    <member name="T:LinFu.IoC.Interfaces.IFactoryStorage">
      <summary>
            Represents a class that stores factory instances.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Interfaces.IFactoryStorage.GetFactory(LinFu.IoC.Interfaces.IServiceInfo)">
      <summary>
            Determines which factories should be used
            for a particular service request.
            </summary>
      <param name="serviceInfo">The <see cref="T:LinFu.IoC.Interfaces.IServiceInfo" /> object that describes the target factory.</param>
      <returns>A factory instance.</returns>
    </member>
    <member name="M:LinFu.IoC.Interfaces.IFactoryStorage.AddFactory(LinFu.IoC.Interfaces.IServiceInfo,LinFu.IoC.Interfaces.IFactory)">
      <summary>
            Adds a <see cref="T:LinFu.IoC.Interfaces.IFactory" /> to the current <see cref="T:LinFu.IoC.Interfaces.IFactoryStorage" /> object.
            </summary>
      <param name="serviceInfo">The <see cref="T:LinFu.IoC.Interfaces.IServiceInfo" /> object that describes the target factory.</param>
      <param name="factory">The <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance that will create the object instance.</param>
    </member>
    <member name="M:LinFu.IoC.Interfaces.IFactoryStorage.ContainsFactory(LinFu.IoC.Interfaces.IServiceInfo)">
      <summary>
            Determines whether or not a factory exists in storage.
            </summary>
      <param name="serviceInfo">The <see cref="T:LinFu.IoC.Interfaces.IServiceInfo" /> object that describes the target factory.</param>
      <returns>Returns <c>true</c> if the factory exists; otherwise, it will return <c>false</c>.</returns>
    </member>
    <member name="P:LinFu.IoC.Interfaces.IFactoryStorage.AvailableFactories">
      <summary>
            Gets a value indicating the list of <see cref="T:LinFu.IoC.Interfaces.IServiceInfo" /> objects
            that describe each available factory in the current <see cref="T:LinFu.IoC.Interfaces.IFactoryStorage" />
            instance.
            </summary>
    </member>
    <member name="T:LinFu.IoC.BaseFactoryStorage">
      <summary>
            Represents the default base implementation of the <see cref="T:LinFu.IoC.Interfaces.IFactoryStorage" /> class.
            </summary>
    </member>
    <member name="M:LinFu.IoC.BaseFactoryStorage.GetFactory(LinFu.IoC.Interfaces.IServiceInfo)">
      <summary>
            Determines which factories should be used
            for a particular service request.
            </summary>
      <param name="serviceInfo">The <see cref="T:LinFu.IoC.Interfaces.IServiceInfo" /> object that describes the target factory.</param>
      <returns>A factory instance.</returns>
    </member>
    <member name="M:LinFu.IoC.BaseFactoryStorage.AddFactory(LinFu.IoC.Interfaces.IServiceInfo,LinFu.IoC.Interfaces.IFactory)">
      <summary>
            Adds a <see cref="T:LinFu.IoC.Interfaces.IFactory" /> to the current <see cref="T:LinFu.IoC.Interfaces.IFactoryStorage" /> object.
            </summary>
      <param name="serviceInfo">The <see cref="T:LinFu.IoC.Interfaces.IServiceInfo" /> object that describes the target factory.</param>
      <param name="factory">The <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance that will create the object instance.</param>
    </member>
    <member name="M:LinFu.IoC.BaseFactoryStorage.ContainsFactory(LinFu.IoC.Interfaces.IServiceInfo)">
      <summary>
            Determines whether or not a factory exists in storage.
            </summary>
      <param name="serviceInfo">The <see cref="T:LinFu.IoC.Interfaces.IServiceInfo" /> object that describes the target factory.</param>
      <returns>Returns <c>true</c> if the factory exists; otherwise, it will return <c>false</c>.</returns>
    </member>
    <member name="P:LinFu.IoC.BaseFactoryStorage.AvailableFactories">
      <summary>
            Gets a value indicating the list of <see cref="T:LinFu.IoC.Interfaces.IServiceInfo" /> objects
            that describe each available factory in the current <see cref="T:LinFu.IoC.Interfaces.IFactoryStorage" />
            instance.
            </summary>
    </member>
    <member name="T:LinFu.IoC.FactoryStorage">
      <summary>
            Represents an <see cref="T:LinFu.IoC.Interfaces.IFactoryStorage" /> instance that adds generics support to the <see cref="T:LinFu.IoC.BaseFactoryStorage" /> implementation.
            </summary>
    </member>
    <member name="M:LinFu.IoC.FactoryStorage.ContainsFactory(LinFu.IoC.Interfaces.IServiceInfo)">
      <summary>
            Determines whether or not an <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance
            can be used to create the given service described by the <paramref name="serviceInfo" /> object.
            </summary>
      <param name="serviceInfo">The <see cref="T:LinFu.IoC.Interfaces.IServiceInfo" /> object that describes the service to be created.</param>
      <returns>
        <c>True</c> if the service can be created; otherwise, it will return <c>false</c>.</returns>
    </member>
    <member name="M:LinFu.IoC.FactoryStorage.GetFactory(LinFu.IoC.Interfaces.IServiceInfo)">
      <summary>
            Obtains the <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance that can instantiate the
            service described by the <paramref name="serviceInfo" /> object instance.
            </summary>
      <param name="serviceInfo">The <see cref="T:LinFu.IoC.Interfaces.IServiceInfo" /> object that describes the service to be created.</param>
      <returns>A <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance if the service can be instantiated; otherwise, it will return <c>false</c>.</returns>
    </member>
    <member name="T:LinFu.IoC.FactoryStorageExtensions">
      <summary>
            An extension class that adds a few helper methods to the
            <see cref="T:LinFu.IoC.Interfaces.IFactoryStorage" /> interface.
            </summary>
    </member>
    <member name="M:LinFu.IoC.FactoryStorageExtensions.AddFactory(LinFu.IoC.Interfaces.IFactoryStorage,System.String,System.Type,System.Collections.Generic.IEnumerable{System.Type},LinFu.IoC.Interfaces.IFactory)">
      <summary>
            Adds a factory to the current <see cref="T:LinFu.IoC.Interfaces.IFactoryStorage" /> instance.
            </summary>
      <param name="storage">The <see cref="T:LinFu.IoC.Interfaces.IFactoryStorage" /> object that will store the target factory.</param>
      <param name="serviceName">The name that will be associated with the target factory.</param>
      <param name="serviceType">The service type that the factory will be able to create.</param>
      <param name="additionalParameterTypes">The list of additional parameters that this factory type will support.</param>
      <param name="factory">The <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance that will create the object instance.</param>
    </member>
    <member name="M:LinFu.IoC.FactoryStorageExtensions.GetFactory(LinFu.IoC.Interfaces.IFactoryStorage,System.String,System.Type,System.Collections.Generic.IEnumerable{System.Object})">
      <summary>
            Determines which factories should be used
            for a particular service request.
            </summary>
      <param name="storage">The <see cref="T:LinFu.IoC.Interfaces.IFactoryStorage" /> object that holds the target factory.</param>
      <param name="serviceName">The name that will be associated with the target factory.</param>
      <param name="serviceType">The service type that the factory will be able to create.</param>
      <param name="additionalParameters">The list of additional parameter values that this factory type will use to instantiate the service.</param>
      <returns>A factory instance.</returns>
    </member>
    <member name="M:LinFu.IoC.FactoryStorageExtensions.GetFactory(LinFu.IoC.Interfaces.IFactoryStorage,System.String,System.Type,System.Collections.Generic.IEnumerable{System.Type})">
      <summary>
            Determines which factories should be used
            for a particular service request.
            </summary>
      <param name="storage">The <see cref="T:LinFu.IoC.Interfaces.IFactoryStorage" /> object that holds the target factory.</param>
      <param name="serviceName">The name that will be associated with the target factory.</param>
      <param name="serviceType">The service type that the factory will be able to create.</param>
      <param name="additionalParameterTypes">The list of additional parameters that this factory type will support.</param>
      <returns>A factory instance.</returns>
    </member>
    <member name="M:LinFu.IoC.FactoryStorageExtensions.ContainsFactory(LinFu.IoC.Interfaces.IFactoryStorage,System.String,System.Type,System.Collections.Generic.IEnumerable{System.Type})">
      <summary>
            Determines whether or not a factory exists in storage.
            </summary>
      <param name="storage">The <see cref="T:LinFu.IoC.Interfaces.IFactoryStorage" /> object that holds the target factory.</param>
      <param name="serviceName">The name that will be associated with the target factory.</param>
      <param name="serviceType">The service type that the factory will be able to create.</param>
      <param name="additionalParameterTypes">The list of additional parameters that this factory type will support.</param>
      <returns>Returns <c>true</c> if the factory exists; otherwise, it will return <c>false</c>.</returns>
    </member>
    <member name="T:LinFu.IoC.Interceptors.BaseInterceptor">
      <summary>
            A class that provides the most basic functionality for an interceptor.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Interceptors.BaseInterceptor.#ctor">
      <summary>
            The default constructor.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Interceptors.BaseInterceptor.#ctor(LinFu.IoC.Configuration.Interfaces.IMethodInvoke{System.Reflection.MethodInfo})">
      <summary>
            Initializes the class with the <paramref name="methodInvoke" /> instance.
            </summary>
      <param name="methodInvoke">The <see cref="T:LinFu.IoC.Configuration.Interfaces.IMethodInvoke`1" /> instance that will invoke the target method.</param>
    </member>
    <member name="M:LinFu.IoC.Interceptors.BaseInterceptor.GetTarget(LinFu.AOP.Interfaces.IInvocationInfo)">
      <summary>
            Gets the target object instance.
            </summary>
      <param name="info">The <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> instance that describes the current execution context.</param>
    </member>
    <member name="M:LinFu.IoC.Interceptors.BaseInterceptor.Intercept(LinFu.AOP.Interfaces.IInvocationInfo)">
      <summary>
            Intercepts a method call using the given
            <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> instance.
            </summary>
      <param name="info">The <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> instance that will 
            contain all the necessary information associated with a 
            particular method call.</param>
      <returns>The return value of the target method. If the return type of the target
            method is <see cref="T:System.Void" />, then the return value will be ignored.</returns>
    </member>
    <member name="P:LinFu.IoC.Interceptors.BaseInterceptor.MethodInvoker">
      <summary>
            Gets the value indicating the <see cref="T:LinFu.IoC.Configuration.Interfaces.IMethodInvoke`1" /> instance
            that will be used to invoke the target method.
            </summary>
    </member>
    <member name="T:LinFu.IoC.Interceptors.LazyInterceptor`1">
      <summary>
            An interceptor class that instantiates a target type only when
            the methods for that target are invoked.
            </summary>
      <typeparam name="T">The type of object to intercept.</typeparam>
    </member>
    <member name="M:LinFu.IoC.Interceptors.LazyInterceptor`1.#ctor(System.Func{`0})">
      <summary>
            Initializes the class with the <paramref name="getInstance" />
            factory method.
            </summary>
      <param name="getInstance">The functor that will be used to create the actual object instance.</param>
    </member>
    <member name="M:LinFu.IoC.Interceptors.LazyInterceptor`1.GetTarget(LinFu.AOP.Interfaces.IInvocationInfo)">
      <summary>
            A method that uses the given factory method to provide a target
            for the method currently being invoked.
            </summary>
      <param name="info">The <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> object that describes the current invocation context.</param>
      <returns>The target itself.</returns>
    </member>
    <member name="M:LinFu.IoC.Interceptors.LazyInterceptor`1.Intercept(LinFu.AOP.Interfaces.IInvocationInfo)">
      <summary>
            Intercepts the method and initializes the target instance before the 
            actual object is invoked.
            </summary>
      <param name="info">The <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> that describes the execution context.</param>
      <returns>The return value of the target method.</returns>
    </member>
    <member name="T:LinFu.IoC.Interceptors.AroundInvokeAdapter">
      <summary>
            Adapts a <see cref="T:LinFu.AOP.Interfaces.IAroundInvoke" /> instance into an <see cref="T:LinFu.AOP.Interfaces.IInterceptor" />.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Interceptors.AroundInvokeAdapter.#ctor(System.Func{System.Object},LinFu.IoC.Configuration.Interfaces.IMethodInvoke{System.Reflection.MethodInfo},LinFu.AOP.Interfaces.IAroundInvoke)">
      <summary>
            Initializes the <see cref="T:LinFu.IoC.Interceptors.AroundInvokeAdapter" /> class.
            </summary>
      <param name="getTarget">The functor responsible for obtaining the target instance.</param>
      <param name="methodInvoke">The method invoker.</param>
      <param name="aroundInvoke">The target <see cref="T:LinFu.AOP.Interfaces.IAroundInvoke" /> instance.</param>
    </member>
    <member name="M:LinFu.IoC.Interceptors.AroundInvokeAdapter.Intercept(LinFu.AOP.Interfaces.IInvocationInfo)">
      <summary>
            Converts the call to <see cref="M:LinFu.AOP.Interfaces.IInterceptor.Intercept(LinFu.AOP.Interfaces.IInvocationInfo)" /> to an
            <see cref="T:LinFu.AOP.Interfaces.IAroundInvoke" /> method call.
            </summary>
      <param name="info">The <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> that describes the context of the method call.</param>
      <returns>The return value from the target method.</returns>
    </member>
    <member name="M:LinFu.IoC.Interceptors.AroundInvokeAdapter.GetTarget(LinFu.AOP.Interfaces.IInvocationInfo)">
      <summary>
            Gets the target object instance.
            </summary>
      <param name="info">The <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> instance that describes the current execution context.</param>
    </member>
    <member name="T:LinFu.IoC.Interceptors.InterceptorAttributeLoader">
      <summary>
            The class responsible for loading interceptors marked with the
            <see cref="T:LinFu.IoC.Interceptors.InterceptsAttribute" /> class.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Interceptors.InterceptorAttributeLoader.#ctor(LinFu.Reflection.ILoader{LinFu.IoC.Interfaces.IServiceContainer})">
      <summary>
            Initializes the class with the given <paramref name="loaderHost" />.
            </summary>
      <param name="loaderHost">The <see cref="T:LinFu.Reflection.ILoader`1" /> instance that will be responsible for loading the <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" /> instance itself.</param>
    </member>
    <member name="M:LinFu.IoC.Interceptors.InterceptorAttributeLoader.Load(System.Type)">
      <summary>
            Loads an <see cref="T:LinFu.AOP.Interfaces.IInterceptor" /> derived class into a particular <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" /> instance
            so that the current interceptor type can intercept calls made to services created from the given
            target container.
            </summary>
      <param name="input">The interceptor type.</param>
      <returns>By default, this will always return an empty set of container actions. The actual interceptor itself will be injected at the end of the postprocessor chain.</returns>
    </member>
    <member name="M:LinFu.IoC.Interceptors.InterceptorAttributeLoader.CreateProxyFrom(LinFu.IoC.Interfaces.IServiceRequestResult,System.Func{LinFu.IoC.Interfaces.IServiceRequestResult,LinFu.AOP.Interfaces.IInterceptor})">
      <summary>
            Generates a proxy instance from an existing <see cref="T:LinFu.IoC.Interfaces.IServiceRequestResult" /> instance.
            </summary>
      <param name="request">The <see cref="T:LinFu.IoC.Interfaces.IServiceRequestResult" /> instance that describes the proxy type that must be generated.</param>
      <param name="getInterceptor">The <see cref="T:LinFu.AOP.Interfaces.IInterceptor" /> functor that will create the interceptor which will handle all calls made to the proxy instance.</param>
      <returns>A service proxy.</returns>
    </member>
    <member name="M:LinFu.IoC.Interceptors.InterceptorAttributeLoader.CanLoad(System.Type)">
      <summary>
            Determines whether or not a target type is an interceptor.
            </summary>
      <param name="inputType">The target type currently being tested.</param>
      <returns>Returns <c>true</c> if the <paramref name="inputType" /> is an interceptor; otherwise, it will return <c>false</c>.</returns>
    </member>
    <member name="T:LinFu.IoC.Interceptors.InterceptsAttribute">
      <summary>
            The attribute class used to indentify interceptor classes.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Interceptors.InterceptsAttribute.#ctor(System.Type)">
      <summary>
            Initializes the class with the given <paramref name="targetType" />.
            </summary>
      <param name="targetType">The target type that will be intercepted.</param>
    </member>
    <member name="M:LinFu.IoC.Interceptors.InterceptsAttribute.#ctor(System.String,System.Type)">
      <summary>
            Initializes the class with the given <paramref name="targetType" /> and <paramref name="serviceName" />.
            </summary>
      <param name="serviceName">The name of service that will be intercepted.</param>
      <param name="targetType">The target type that will be intercepted.</param>
    </member>
    <member name="P:LinFu.IoC.Interceptors.InterceptsAttribute.ServiceName">
      <summary>
            Gets the value indicating the name of the service to intercept.
            </summary>
    </member>
    <member name="P:LinFu.IoC.Interceptors.InterceptsAttribute.TargetType">
      <summary>
            Gets the value indicating the target type that will be intercepted.
            </summary>
    </member>
    <member name="T:LinFu.IoC.Interceptors.InvocationInfoInterceptor">
      <summary>
            An interceptor that intercepts <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> instances
            and replaces the original target instance with a surrogate instance.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Interceptors.InvocationInfoInterceptor.#ctor(LinFu.AOP.Interfaces.IInvocationInfo,System.Func{System.Object},LinFu.IoC.Configuration.Interfaces.IMethodInvoke{System.Reflection.MethodInfo})">
      <summary>
            Initializes the class with a functor that can provide the actual target instance.
            </summary>
      <param name="getActualTarget">The <see cref="T:System.Func`1" /> that will provide the target instance that will be used for the method invocation.</param>
      <param name="methodInvoke">The method invoker.</param>
      <param name="realInfo">The <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> instance that describes the current execution context.</param>
    </member>
    <member name="M:LinFu.IoC.Interceptors.InvocationInfoInterceptor.GetTarget(LinFu.AOP.Interfaces.IInvocationInfo)">
      <summary>
            Gets the target object instance.
            </summary>
      <param name="info">The <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> instance that describes the current execution context.</param>
    </member>
    <member name="T:LinFu.IoC.Interceptors.ProxyContainerPlugin">
      <summary>
            A <see cref="T:LinFu.IoC.Configuration.Interfaces.IContainerPlugin" /> implementation that inserts
            <see cref="T:LinFu.IoC.Interceptors.ProxyInjector" /> instances at the beginning of a <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" />
            loading sequence.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Interceptors.ProxyContainerPlugin.#ctor(LinFu.IoC.Interceptors.ProxyInjector)">
      <summary>
            Initializes the class with the given <see cref="T:LinFu.IoC.Interceptors.ProxyInjector" /> instance.
            </summary>
      <param name="injector">The postprocessor that will inject proxies in place of actual service requests.</param>
    </member>
    <member name="M:LinFu.IoC.Interceptors.ProxyContainerPlugin.BeginLoad(LinFu.IoC.Interfaces.IServiceContainer)">
      <summary>
            Injects a <see cref="T:LinFu.IoC.Interceptors.ProxyInjector" /> into the <paramref name="target">target container</paramref>.
            </summary>
      <param name="target">The service container that will hold the <see cref="T:LinFu.IoC.Interceptors.ProxyInjector" />.</param>
    </member>
    <member name="M:LinFu.IoC.Interceptors.ProxyContainerPlugin.EndLoad(LinFu.IoC.Interfaces.IServiceContainer)">
      <summary>
            Does absolutely nothing.
            </summary>
      <param name="target">The target container.</param>
    </member>
    <member name="T:LinFu.IoC.Interceptors.ProxyInjector">
      <summary>
            Represents a class that automatically injects a proxy instance
            instead of an actual service instance.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Interceptors.ProxyInjector.#ctor(System.Func{LinFu.IoC.Interfaces.IServiceRequestResult,System.Boolean},System.Func{LinFu.IoC.Interfaces.IServiceRequestResult,System.Object})">
      <summary>
            Initializes the class with the <paramref name="filterPredicate" />
            and the <paramref name="createProxy" /> factory method.
            </summary>
      <param name="filterPredicate">The predicate that will determine which service requests will be proxied.</param>
      <param name="createProxy">The factory method that will generate the proxy instance itself.</param>
    </member>
    <member name="M:LinFu.IoC.Interceptors.ProxyInjector.PostProcess(LinFu.IoC.Interfaces.IServiceRequestResult)">
      <summary>
            A method that injects service proxies in place of the actual <see cref="P:LinFu.IoC.Interfaces.IServiceRequestResult.ActualResult" />.
            </summary>
      <param name="result">The <see cref="T:LinFu.IoC.Interfaces.IServiceRequestResult" /> instance that describes the service request.</param>
    </member>
    <member name="T:LinFu.IoC.Configuration.IContainerLoader">
      <summary>
            Represents a loader that reads a file and converts it
            into an equivalent set of a set of <see cref="T:System.Action`1" />
            instances that can be applied to a particular
            instance of an <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" /> class.
            </summary>
    </member>
    <member name="T:LinFu.IoC.Interceptors.Redirector">
      <summary>
            An interceptor class that redirects calls to another interceptor.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Interceptors.Redirector.GetTarget(LinFu.AOP.Interfaces.IInvocationInfo)">
      <summary>
            Gets the target object instance.
            </summary>
      <param name="info">The <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> instance that describes the current execution context.</param>
    </member>
    <member name="T:LinFu.IoC.Interfaces.IScope">
      <summary>
            Represents a class that keeps track of all the disposable objects 
            created within a service container and disposes them when 
            the scope itself has been disposed.
            </summary>
    </member>
    <member name="T:LinFu.IoC.Reflection.LateBoundExtensions">
      <summary>
            A class that adds late binding support to any CLR object.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Reflection.LateBoundExtensions.Invoke(System.Object,System.String,System.Object[])">
      <summary>
            Invokes a method on the target <paramref name="instance" />.
            </summary>
      <param name="instance">The target instance that will be used to invoke the method.</param>
      <param name="methodName">The name of the target method.</param>
      <param name="arguments">The arguments that will be passed to the target method.</param>
      <returns>The method return value.</returns>
    </member>
    <member name="M:LinFu.IoC.Reflection.LateBoundExtensions.Invoke(System.Object,System.String,LinFu.IoC.Configuration.MethodFinderContext)">
      <summary>
            Invokes a method on the target <paramref name="instance" /> using the given <paramref name="methodName" /> and <paramref name="context" />.
            </summary>
      <param name="instance">The target instance.</param>
      <param name="methodName">The name of the target method.</param>
      <param name="context">The <see cref="T:LinFu.IoC.Configuration.Interfaces.IMethodFinderContext" /> that describes the target method.</param>
      <returns>The method return value.</returns>
    </member>
    <member name="M:LinFu.IoC.Reflection.LateBoundExtensions.Invoke``1(System.Object,System.String,System.Object[])">
      <summary>
            Invokes a method on the target <paramref name="instance" /> using the given <paramref name="methodName" />.
            </summary>
      <param name="instance">The target instance.</param>
      <param name="methodName">The name of the target method.</param>
      <typeparam name="T1">The type argument that will be passed to the target method</typeparam>.
            <param name="arguments">The arguments that will be passed to the target method.</param><returns>The method return value.</returns></member>
    <member name="M:LinFu.IoC.Reflection.LateBoundExtensions.Invoke``2(System.Object,System.String,System.Object[])">
      <summary>
            Invokes a method on the target <paramref name="instance" /> using the given <paramref name="methodName" />.
            </summary>
      <param name="instance">The target instance.</param>
      <param name="methodName">The name of the target method.</param>
      <typeparam name="T1">The first type argument that will be passed to the target method</typeparam>.
            <typeparam name="T2">The second type argument that will be passed to the target method</typeparam>.
            <param name="arguments">The arguments that will be passed to the target method.</param><returns>The method return value.</returns></member>
    <member name="M:LinFu.IoC.Reflection.LateBoundExtensions.Invoke``3(System.Object,System.String,System.Object[])">
      <summary>
            Invokes a method on the target <paramref name="instance" /> using the given <paramref name="methodName" />.
            </summary>
      <param name="instance">The target instance.</param>
      <param name="methodName">The name of the target method.</param>
      <typeparam name="T1">The first type argument that will be passed to the target method</typeparam>.
            <typeparam name="T2">The second type argument that will be passed to the target method</typeparam>.
            <typeparam name="T3">The third type argument that will be passed to the target method.</typeparam><param name="arguments">The arguments that will be passed to the target method.</param><returns>The method return value.</returns></member>
    <member name="M:LinFu.IoC.Reflection.LateBoundExtensions.Invoke``4(System.Object,System.String,System.Object[])">
      <summary>
            Invokes a method on the target <paramref name="instance" /> using the given <paramref name="methodName" />.
            </summary>
      <param name="instance">The target instance.</param>
      <param name="methodName">The name of the target method.</param>
      <typeparam name="T1">The first type argument that will be passed to the target method</typeparam>.
            <typeparam name="T2">The second type argument that will be passed to the target method</typeparam>.
            <typeparam name="T3">The third type argument that will be passed to the target method.</typeparam><typeparam name="T4">The fourth type argument that will be passed to the target method.</typeparam><param name="arguments">The arguments that will be passed to the target method.</param><returns>The method return value.</returns></member>
    <member name="M:LinFu.IoC.Reflection.LateBoundExtensions.Invoke(System.Object,System.String,System.Type[],System.Object[])">
      <summary>
            Invokes a method on the target <paramref name="instance" /> using the given <paramref name="methodName" />.
            </summary>
      <param name="instance">The target instance.</param>
      <param name="methodName">The name of the target method.</param>
      <param name="typeArguments">The type arguments that will be passed to the target method.</param>
      <param name="arguments">The arguments that will be passed to the target method.</param>
      <returns>The method return value.</returns>
    </member>
    <member name="T:LinFu.IoC.Scope">
      <summary>
            Represents a class that keeps track of all the disposable objects 
            created within a service container and disposes them when 
            the scope itself has been disposed.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Scope.Dispose">
      <summary>
            Disposes the services that have been created while the scope has been active.
            </summary>
    </member>
    <member name="M:LinFu.IoC.Scope.PostProcess(LinFu.IoC.Interfaces.IServiceRequestResult)">
      <summary>
            Monitors the <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" /> for any services that are created and automatically disposes them
            once the <see cref="T:LinFu.IoC.Interfaces.IScope" /> is disposed.
            </summary>
      <param name="result">The <see cref="T:LinFu.IoC.Interfaces.IServiceRequestResult" /> that describes the service being instantiated.</param>
    </member>
    <member name="M:LinFu.IoC.Scope.Initialize(LinFu.IoC.Interfaces.IServiceContainer)">
      <summary>
            Inserts the scope into the target <paramref name="source">container</paramref>.
            </summary>
      <param name="source">The container that will hold the scope instance.</param>
    </member>
    <member name="T:LinFu.IoC.ServiceContainer">
      <summary>
            Represents a service container with additional
            extension points for customizing service instances
            </summary>
    </member>
    <member name="M:LinFu.IoC.ServiceContainer.#ctor">
      <summary>
            Initializes the container with the default services.
            </summary>
    </member>
    <member name="M:LinFu.IoC.ServiceContainer.#ctor(LinFu.IoC.Interfaces.IGetService,LinFu.IoC.Interfaces.IFactoryStorage)">
      <summary>
            Initializes the container with a custom <see cref="T:LinFu.IoC.Interfaces.ICreateInstance" /> type.
            </summary>
      <param name="getServiceBehavior">The instance that will be responsible for generating service instances.</param>
      <param name="factoryStorage">The <see cref="T:LinFu.IoC.Interfaces.IFactoryStorage" /> instance responsible for determining which factory instance will instantiate a given service request.</param>
    </member>
    <member name="M:LinFu.IoC.ServiceContainer.AddFactory(System.String,System.Type,System.Collections.Generic.IEnumerable{System.Type},LinFu.IoC.Interfaces.IFactory)">
      <summary>
            Adds an <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance and associates it
            with the given <paramref name="serviceType">service type</paramref> and
            <paramref name="serviceName">service name</paramref>.
            </summary>
      <param name="serviceName">The name of the service to associate with the given <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance.</param>
      <param name="serviceType">The type of service that the factory will be able to create.</param>
      <param name="additionalParameterTypes">The list of additional parameters that this factory type will support.</param>
      <param name="factory">The <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance that will create the object instance.</param>
    </member>
    <member name="M:LinFu.IoC.ServiceContainer.AddFactory(System.Type,System.Collections.Generic.IEnumerable{System.Type},LinFu.IoC.Interfaces.IFactory)">
      <summary>
            Adds an <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance and associates it
            with the given <paramref name="serviceType">service type</paramref>.
            </summary>
      <param name="serviceType">The service type to associate with the factory</param>
      <param name="additionalParameterTypes">The list of additional parameters that this factory type will support.</param>
      <param name="factory">The <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance that will be responsible for creating the service instance</param>
    </member>
    <member name="M:LinFu.IoC.ServiceContainer.Contains(System.Type,System.Collections.Generic.IEnumerable{System.Type})">
      <summary>
            Determines whether or not the given <paramref name="serviceType" />
            can be instantiated by the container.
            </summary>
      <param name="serviceType">The type of service to instantiate.</param>
      <param name="additionalParameterTypes">The list of additional parameters that this factory type will support.</param>
      <returns>Returns <c>true</c> if the service exists; otherwise, it will return <c>false</c>.</returns>
    </member>
    <member name="M:LinFu.IoC.ServiceContainer.GetService(System.Type,System.Object[])">
      <summary>
            Overridden. Causes the container to instantiate the service with the given
            <paramref name="serviceType">service type</paramref>. If the service type cannot be created, then an
            exception will be thrown if the <see cref="P:LinFu.IoC.Interfaces.IContainer.SuppressErrors" /> property
            is set to false. Otherwise, it will simply return null.
            </summary>
      <remarks>
            This overload of the <c>GetService</c> method has been overridden
            so that its results can be handled by the postprocessors.
            </remarks>
      <seealso cref="T:LinFu.IoC.Interfaces.IPostProcessor" />
      <param name="serviceType">The service type to instantiate.</param>
      <param name="additionalArguments">The additional arguments that will be used to instantiate the service type.</param>
      <returns>If successful, it will return a service instance that is compatible with the given type;
            otherwise, it will just return a null value.</returns>
    </member>
    <member name="M:LinFu.IoC.ServiceContainer.GetService(System.String,System.Type,System.Object[])">
      <summary>
            Causes the container to instantiate the service with the given
            <paramref name="serviceType">service type</paramref>. If the service type cannot be created, then an
            exception will be thrown if the <see cref="P:LinFu.IoC.Interfaces.IContainer.SuppressErrors" /> property
            is set to false. Otherwise, it will simply return null.
            </summary>
      <param name="serviceName">The name of the service to instantiate.</param>
      <param name="serviceType">The service type to instantiate.</param>
      <param name="additionalArguments">The additional arguments that will be used to instantiate the service type.</param>
      <returns>If successful, it will return a service instance that is compatible with the given type;
            otherwise, it will just return a <c>null</c> value.</returns>
    </member>
    <member name="M:LinFu.IoC.ServiceContainer.Contains(System.String,System.Type,System.Collections.Generic.IEnumerable{System.Type})">
      <summary>
            Determines whether or not a service can be created using
            the given <paramref name="serviceName">service name</paramref>
            and <paramref name="serviceType">service type</paramref>.
            </summary>
      <param name="serviceName">The name of the service to associate with the given <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance.</param>
      <param name="serviceType">The type of service that the factory will be able to create.</param>
      <param name="additionalParameterTypes">The list of additional parameters that this factory type will support.</param>
      <returns>Returns <c>true</c> if the service exists; otherwise, it will return <c>false</c>.</returns>
    </member>
    <member name="P:LinFu.IoC.ServiceContainer.SuppressErrors">
      <summary>
            Gets or sets a <see cref="T:System.Boolean">System.Boolean</see> value
            that determines whether or not the container should throw
            a <see cref="T:LinFu.IoC.ServiceNotFoundException" /> if a requested service
            cannot be found or created.
            </summary>
    </member>
    <member name="P:LinFu.IoC.ServiceContainer.FactoryStorage">
      <summary>
            Gets the value indicating the <see cref="T:LinFu.IoC.Interfaces.IFactoryStorage" /> instance
            that will be used to store each <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance.
            </summary>
    </member>
    <member name="P:LinFu.IoC.ServiceContainer.PostProcessors">
      <summary>
            The list of postprocessors that will handle every
            service request result.
            </summary>
    </member>
    <member name="P:LinFu.IoC.ServiceContainer.PreProcessors">
      <summary>
            The list of preprocessors that will handle
            every service request before each actual service is created.
            </summary>
    </member>
    <member name="P:LinFu.IoC.ServiceContainer.AvailableServices">
      <summary>
            The list of services currently available inside the container.
            </summary>
    </member>
    <member name="T:LinFu.IoC.ServiceNotFoundException">
      <summary>
            The exception thrown when a service type is
            requested from a container and that named container
            is unable to find or create that particular service instance.
            </summary>
    </member>
    <member name="M:LinFu.IoC.ServiceNotFoundException.#ctor(System.Type)">
      <summary>
            Initializes the service exception using the
            given <paramref name="serviceType" /> as
            the service that was not found.
            </summary>
      <param name="serviceType">The service type being requested.</param>
    </member>
    <member name="P:LinFu.IoC.ServiceNotFoundException.Message">
      <summary>
            The error message that this particular exception
            will display.
            </summary>
    </member>
    <member name="T:LinFu.IoC.NamedServiceNotFoundException">
      <summary>
            The exception thrown when a service name and a service type is
            requested from a named container and that named container
            is unable to find or create that particular service instance.
            </summary>
    </member>
    <member name="M:LinFu.IoC.NamedServiceNotFoundException.#ctor(System.String,System.Type)">
      <summary>
            Initializes the service exception using the
            given <paramref name="serviceType" /> as
            the service that was not found.
            </summary>
      <param name="serviceType">The service type being requested.</param>
      <param name="serviceName">The name of the service being requested.</param>
    </member>
    <member name="P:LinFu.IoC.NamedServiceNotFoundException.Message">
      <summary>
            The error message that this particular exception
            will display.
            </summary>
    </member>
    <member name="T:LinFu.IoC.ServiceInfo">
      <summary>
            Represents the default implementation of the ServiceInfo class.
            </summary>
    </member>
    <member name="M:LinFu.IoC.ServiceInfo.#ctor(System.String,System.Type)">
      <summary>
            Initializes the class with the given <paramref name="serviceName" />
            and <paramref name="serviceType" />.
            </summary>
      <param name="serviceName">The name of the service.</param>
      <param name="serviceType">The type of service that can be created.</param>
    </member>
    <member name="M:LinFu.IoC.ServiceInfo.#ctor(System.String,System.Type,System.Collections.Generic.IEnumerable{System.Type})">
      <summary>
            Initializes the class with the given <paramref name="serviceName" />
            and <paramref name="serviceType" />.
            </summary>
      <param name="serviceName">The name of the service.</param>
      <param name="serviceType">The type of service that can be created.</param>
      <param name="arguments">The parameter types required by the given service.</param>
    </member>
    <member name="M:LinFu.IoC.ServiceInfo.ToString">
      <summary>
            Displays the name of the current service and the current service type.
            </summary>
      <returns>The name of the current service and the current service type.</returns>
    </member>
    <member name="M:LinFu.IoC.ServiceInfo.Equals(System.Object)">
      <summary>
            Determines if the other object is equal to the current <see cref="T:LinFu.IoC.Interfaces.IServiceInfo" /> instance.
            </summary>
      <param name="obj">The other object that will be used in the comparison.</param>
      <returns>Returns <c>true</c> if both instances have the same service name, implement the same service type and have the same arguments; otherwise, it will return <c>false</c>.</returns>
    </member>
    <member name="P:LinFu.IoC.ServiceInfo.ServiceName">
      <summary>
            The name of the service being created. By default, this property is blank.
            </summary>
    </member>
    <member name="P:LinFu.IoC.ServiceInfo.ServiceType">
      <summary>
            The type of service being requested.
            </summary>
    </member>
    <member name="P:LinFu.IoC.ServiceInfo.ArgumentTypes">
      <summary>
            Gets a value indicating the list of arguments required by this particular service.
            </summary>
    </member>
    <member name="T:LinFu.IoC.ServiceRequest">
      <summary>
            Reprsents the default implementation of the <see cref="T:LinFu.IoC.Interfaces.IServiceRequest" /> interface.
            </summary>
    </member>
    <member name="M:LinFu.IoC.ServiceRequest.#ctor(System.String,System.Type,System.Object[],LinFu.IoC.Interfaces.IFactory,LinFu.IoC.Interfaces.IServiceContainer)">
      <summary>
            Initializes the <see cref="T:LinFu.IoC.ServiceRequest" /> class.
            </summary>
      <param name="serviceName">The name of the requested service.</param>
      <param name="serviceType">The requested service type.</param>
      <param name="proposedArguments">The proposed set of arguments that will be given to the factory.</param>
      <param name="proposedFactory">The <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance that will be used to handle the service request.</param>
      <param name="container">The host container.</param>
    </member>
    <member name="P:LinFu.IoC.ServiceRequest.ProposedArguments">
      <summary>
            Gets the value indicating the original arguments that
            were given during the service request.
            </summary>
    </member>
    <member name="P:LinFu.IoC.ServiceRequest.ProposedFactory">
      <summary>
            Gets the value indicating the original <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance
            that will be used to handle the service request.
            </summary>
    </member>
    <member name="P:LinFu.IoC.ServiceRequest.Container">
      <summary>
            The container that will handle the service request.
            </summary>
    </member>
    <member name="P:LinFu.IoC.ServiceRequest.ActualArguments">
      <summary>
            Gets or sets the value indicating the actual arguments that
            will be used for the service request.
            </summary>
    </member>
    <member name="P:LinFu.IoC.ServiceRequest.ActualFactory">
      <summary>
            Gets or sets the value indicating the actual <see cref="T:LinFu.IoC.Interfaces.IFactory" /> instance
            that will be used to handle the service request.
            </summary>
    </member>
    <member name="T:LinFu.IoC.ServiceRequestResult">
      <summary>
            Represents the results returned when a service request
            is made against an <see cref="T:LinFu.IoC.Interfaces.IContainer" /> instance.
            </summary>
    </member>
    <member name="P:LinFu.IoC.ServiceRequestResult.ServiceName">
      <summary>
            The name of the service being created. By default, this property is blank.
            </summary>
    </member>
    <member name="P:LinFu.IoC.ServiceRequestResult.OriginalResult">
      <summary>
            The raw object reference created by the container itself.
            </summary>
    </member>
    <member name="P:LinFu.IoC.ServiceRequestResult.ActualResult">
      <summary>
            The result that will be returned from the container
            instead of the <see cref="P:LinFu.IoC.ServiceRequestResult.OriginalResult" />. 
            
            If this property is null, then the original result will be used.
            </summary>
    </member>
    <member name="P:LinFu.IoC.ServiceRequestResult.ServiceType">
      <summary>
            The type of service being requested.
            </summary>
    </member>
    <member name="P:LinFu.IoC.ServiceRequestResult.Container">
      <summary>
            The container that will handle the service request.
            </summary>
    </member>
    <member name="P:LinFu.IoC.ServiceRequestResult.AdditionalArguments">
      <summary>
            Gets or sets the value indicating the additional arguments that
            were used during the service request.
            </summary>
    </member>
    <member name="T:LinFu.Proxy.MethodBodyEmitter">
      <summary>
            Provides the default implementation for the
            <see cref="T:LinFu.Proxy.Interfaces.IMethodBodyEmitter" /> interface.
            </summary>
    </member>
    <member name="M:LinFu.Proxy.MethodBodyEmitter.#ctor">
      <summary>
            Initializes the class with the default values.
            </summary>
    </member>
    <member name="M:LinFu.Proxy.MethodBodyEmitter.Emit(System.Reflection.MethodInfo,Mono.Cecil.MethodDefinition)">
      <summary>
            Generates a method body for the <paramref name="targetMethod" />.
            </summary>
      <param name="originalMethod">The method currently being intercepted.</param>
      <param name="targetMethod">The target method that will contain the new method body.</param>
    </member>
    <member name="M:LinFu.Proxy.MethodBodyEmitter.EmitGetInterceptorInstruction(Mono.Cecil.Cil.CilWorker,Mono.Cecil.TypeReference,Mono.Cecil.MethodReference)">
      <summary>
            Emits the IL instructions to obtain an <see cref="T:LinFu.AOP.Interfaces.IInterceptor" /> instance for the proxy type.
            </summary>
      <param name="IL">The <see cref="T:Mono.Cecil.Cil.CilWorker" /> responsible for emitting the method body.</param>
      <param name="proxyType">The proxy type.</param>
      <param name="getInterceptorMethod">The getter method for the interceptor.</param>
    </member>
    <member name="M:LinFu.Proxy.MethodBodyEmitter.ImplementNotFound(Mono.Cecil.Cil.CilWorker)">
      <summary>
            Causes the <see cref="T:Mono.Cecil.Cil.CilWorker" /> to make the method throw a
            <see cref="T:System.NotImplementedException" /> if the method cannot be found.
            </summary>
      <param name="IL">The <see cref="T:Mono.Cecil.Cil.CilWorker" /> responsible for emitting the method body.</param>
    </member>
    <member name="M:LinFu.Proxy.MethodBodyEmitter.SaveRefArguments(Mono.Cecil.Cil.CilWorker,System.Collections.Generic.IEnumerable{Mono.Cecil.ParameterDefinition},Mono.Cecil.Cil.VariableDefinition,Mono.Cecil.Cil.VariableDefinition)">
      <summary>
            Saves the ref arguments of a given method using the
            <paramref name="arguments" /> from the <paramref name="invocationInfo" />
            object.
            </summary>
      <param name="IL">The <see cref="T:Mono.Cecil.Cil.CilWorker" /> that will emit the method body.</param>
      <param name="parameters">The parameters of the target method.</param>
      <param name="invocationInfo">The local variable that contains the <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> instance.</param>
      <param name="arguments">The local variable that will store the arguments from the <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> instance.</param>
    </member>
    <member name="M:LinFu.Proxy.MethodBodyEmitter.Initialize(LinFu.IoC.Interfaces.IServiceContainer)">
      <summary>
            Initializes the MethodBodyEmitter class.
            </summary>
      <param name="source">
      </param>
    </member>
    <member name="P:LinFu.Proxy.MethodBodyEmitter.InvocationInfoEmitter">
      <summary>
            The <see cref="T:LinFu.AOP.Cecil.Interfaces.IEmitInvocationInfo" /> instance that
            </summary>
    </member>
    <member name="T:LinFu.Proxy.ProxyBuilder">
      <summary>
            A <see cref="T:LinFu.Proxy.Interfaces.IProxyBuilder" /> type that generates
            proxies that forward all virtual method calls to a 
            single interceptor.
            </summary>
    </member>
    <member name="M:LinFu.Proxy.ProxyBuilder.#ctor">
      <summary>
            Initializes the current class with the default values.
            </summary>
    </member>
    <member name="M:LinFu.Proxy.ProxyBuilder.Construct(System.Type,System.Collections.Generic.IEnumerable{System.Type},Mono.Cecil.ModuleDefinition,Mono.Cecil.TypeDefinition)">
      <summary>
            Generates a proxy that forwards all virtual method calls
            to a single <see cref="T:LinFu.AOP.Interfaces.IInterceptor" /> instance.
            </summary>
      <param name="originalBaseType">The base class of the type being constructed.</param>
      <param name="baseInterfaces">The list of interfaces that the new type must implement.</param>
      <param name="module">The module that will hold the brand new type.</param>
      <param name="targetType">The <see cref="T:Mono.Cecil.TypeDefinition" /> that represents the type to be created.</param>
    </member>
    <member name="M:LinFu.Proxy.ProxyBuilder.Initialize(LinFu.IoC.Interfaces.IServiceContainer)">
      <summary>
            Initializes the current instance
            with the <paramref name="source" /> container.
            </summary>
      <param name="source">The <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" /> instance that will hold the current instance.</param>
    </member>
    <member name="P:LinFu.Proxy.ProxyBuilder.ProxyImplementor">
      <summary>
            Gets or sets the <see cref="T:LinFu.Reflection.Emit.Interfaces.ITypeBuilder" /> interface
            which will emit the actual implementation of the IProxy interface.
            </summary>
    </member>
    <member name="P:LinFu.Proxy.ProxyBuilder.MethodPicker">
      <summary>
            Gets or sets the <see cref="T:LinFu.Proxy.Interfaces.IMethodPicker" />
            instance that will determine which methods
            will be proxied by the proxy builder.
            </summary>
    </member>
    <member name="P:LinFu.Proxy.ProxyBuilder.ProxyMethodBuilder">
      <summary>
            The <see cref="T:LinFu.Proxy.Interfaces.IMethodBuilder" /> instance
            that will be responsible for generating each method
            for the current target type.
            </summary>
    </member>
    <member name="T:LinFu.Proxy.InterfaceExtractor">
      <summary>
            Provides the default implementation for the 
            <see cref="T:LinFu.Proxy.Interfaces.IExtractInterfaces" /> interface.
            </summary>
    </member>
    <member name="M:LinFu.Proxy.InterfaceExtractor.GetInterfaces(System.Type,System.Collections.Generic.HashSet{System.Type})">
      <summary>
            Determines which interfaces a given type should implement.
            </summary>
      <param name="currentType">The base type that holds the list of interfaces to implement.</param>
      <param name="interfaceList">The list of interfaces already being implemented. </param>
    </member>
    <member name="T:LinFu.Proxy.MethodPicker">
      <summary>
            Represents the default class implementation for the
            <see cref="T:LinFu.Proxy.Interfaces.IMethodPicker" /> interface.
            </summary>
    </member>
    <member name="M:LinFu.Proxy.MethodPicker.ChooseProxyMethodsFrom(System.Type,System.Collections.Generic.IEnumerable{System.Type})">
      <summary>
            Determines which methods can be proxied from 
            the given <paramref name="baseType" /> and <paramref name="baseInterfaces" />. 
            </summary>
      <remarks>By default, only public virtual methods will be proxied.</remarks>
      <param name="baseType">The base class of the proxy type currently being generated.</param>
      <param name="baseInterfaces">The list of interfaces that the proxy must implement.</param>
      <returns>A list of <see cref="T:System.Reflection.MethodInfo" /> objects that can be proxied.</returns>
    </member>
    <member name="T:LinFu.Proxy.ProxyCache">
      <summary>
            Represents the default implementation of the <see cref="T:LinFu.Proxy.Interfaces.IProxyCache" /> interface.
            </summary>
    </member>
    <member name="M:LinFu.Proxy.ProxyCache.Contains(System.Type,System.Type[])">
      <summary>
            Determines whether or not the cache contains an existing proxy type
            that is derived from the <paramref name="baseType" /> and implements
            the given <paramref name="baseInterfaces" />.
            </summary>
      <param name="baseType">The base type of the dynamically-generated proxy type.</param>
      <param name="baseInterfaces">The list of interfaces that the generated proxy type must implement.</param>
      <returns>Returns <c>true</c> if the proxy type already exists; otherwise, it will return <c>false.</c></returns>
    </member>
    <member name="M:LinFu.Proxy.ProxyCache.Get(System.Type,System.Type[])">
      <summary>
            Retrieves an existing proxy type from the cache.
            </summary>
      <param name="baseType">The base type of the dynamically-generated proxy type.</param>
      <param name="baseInterfaces">The list of interfaces that the generated proxy type must implement.</param>
      <returns>Returns a valid <see cref="T:System.Type" /> if the type already exists; otherwise, it might return <c>null</c> or opt to throw an exception.</returns>
    </member>
    <member name="M:LinFu.Proxy.ProxyCache.Store(System.Type,System.Type,System.Type[])">
      <summary>
            Stores a proxy type in the cache.
            </summary>
      <param name="result">The proxy type to be stored.</param>
      <param name="baseType">The base type of the dynamically-generated proxy type.</param>
      <param name="baseInterfaces">The list of interfaces that the generated proxy type must implement.</param>
    </member>
    <member name="T:LinFu.Proxy.ProxyCacheEntry">
      <summary>
            Represents a cached proxy type.
            </summary>
    </member>
    <member name="T:LinFu.Proxy.ProxyFactory">
      <summary>
            Provides the basic implementation for a proxy factory class.
            </summary>
    </member>
    <member name="M:LinFu.Proxy.ProxyFactory.#ctor">
      <summary>
            Initializes the proxy factory with the default values.
            </summary>
    </member>
    <member name="M:LinFu.Proxy.ProxyFactory.CreateProxyType(System.Type,System.Collections.Generic.IEnumerable{System.Type})">
      <summary>
            Creates a proxy type using the given
            <paramref name="baseType" /> as the base class
            and ensures that the proxy type implements the given
            interface types.
            </summary>
      <param name="baseType">The base class from which the proxy type will be derived.</param>
      <param name="baseInterfaces">The list of interfaces that the proxy will implement.</param>
      <returns>A forwarding proxy.</returns>
    </member>
    <member name="M:LinFu.Proxy.ProxyFactory.Initialize(LinFu.IoC.Interfaces.IServiceContainer)">
      <summary>
            Initializes the <see cref="T:LinFu.Proxy.ProxyFactory" /> instance
            with the <paramref name="source" /> container.
            </summary>
      <param name="source">The <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" /> instance that will hold the ProxyFactory.</param>
    </member>
    <member name="P:LinFu.Proxy.ProxyFactory.InterfaceExtractor">
      <summary>
            Gets or sets the <see cref="T:LinFu.Proxy.Interfaces.IExtractInterfaces" /> type that will be
            responsible for determining which interfaces
            the proxy type should implement.
            </summary>
    </member>
    <member name="P:LinFu.Proxy.ProxyFactory.ProxyBuilder">
      <summary>
            The <see cref="T:LinFu.Proxy.Interfaces.IProxyBuilder" /> instance that is
            responsible for generating the proxy type.
            </summary>
    </member>
    <member name="P:LinFu.Proxy.ProxyFactory.Verifier">
      <summary>
            The <see cref="T:LinFu.AOP.Cecil.Interfaces.IVerifier" /> instance that will be used to 
            ensure that the generated assemblies are valid.
            </summary>
    </member>
    <member name="P:LinFu.Proxy.ProxyFactory.Cache">
      <summary>
            Gets or sets a value indicating the <see cref="T:LinFu.Proxy.Interfaces.IProxyCache" />
            instance that will be used to cache previous proxy generation runs.
            </summary>
    </member>
    <member name="T:LinFu.Proxy.ProxyImplementor">
      <summary>
            A class that provides the default implementation
            for the IProxy interface.
            </summary>
    </member>
    <member name="M:LinFu.Proxy.ProxyImplementor.Construct(Mono.Cecil.ModuleDefinition,Mono.Cecil.TypeDefinition)">
      <summary>
            Constructs a type that implements the
            <see cref="T:LinFu.Proxy.Interfaces.IProxy" /> interface.
            </summary>
      <param name="module">The module that will hold the target type.</param>
      <param name="targetType">The type that will implement the <see cref="T:LinFu.Proxy.Interfaces.IProxy" /> interface.</param>
    </member>
    <member name="T:LinFu.Proxy.ProxyMethodBuilder">
      <summary>
            Represents the default implementation of the
            <see cref="T:LinFu.Proxy.Interfaces.IMethodBuilder" /> interface.
            </summary>
    </member>
    <member name="M:LinFu.Proxy.ProxyMethodBuilder.#ctor">
      <summary>
            Initializes the <see cref="T:LinFu.Proxy.ProxyMethodBuilder" /> class with the default property values.
            </summary>
    </member>
    <member name="M:LinFu.Proxy.ProxyMethodBuilder.CreateMethod(Mono.Cecil.TypeDefinition,System.Reflection.MethodInfo)">
      <summary>
            Creates a method that matches the signature defined in the
            <paramref name="method" /> parameter.
            </summary>
      <param name="targetType">The type that will host the new method.</param>
      <param name="method">The method from which the signature will be derived.</param>
    </member>
    <member name="M:LinFu.Proxy.ProxyMethodBuilder.MatchGenericArguments(Mono.Cecil.MethodDefinition,System.Collections.Generic.ICollection{System.Type})">
      <summary>
            Matches the generic parameters of <paramref name="newMethod">a target method</paramref></summary>
      <param name="newMethod">The generic method that contains the generic type arguments.</param>
      <param name="typeArguments">The array of <see cref="T:System.Type" /> objects that describe the generic parameters for the current method.</param>
    </member>
    <member name="M:LinFu.Proxy.ProxyMethodBuilder.Initialize(LinFu.IoC.Interfaces.IServiceContainer)">
      <summary>
            Initializes the class with the <paramref name="source" /> container.
            </summary>
      <param name="source">The <see cref="T:LinFu.IoC.Interfaces.IServiceContainer" /> instance that will create the class instance.</param>
    </member>
    <member name="P:LinFu.Proxy.ProxyMethodBuilder.Emitter">
      <summary>
            The <see cref="T:LinFu.Proxy.Interfaces.IMethodBodyEmitter" /> instance that will be
            responsible for generating the method body.
            </summary>
    </member>
    <member name="T:LinFu.Proxy.ProxyObjectReference">
      <summary>
            Represents a helper class that deserializes proxy instances.
            </summary>
    </member>
    <member name="M:LinFu.Proxy.ProxyObjectReference.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the ProxyObjectReference class.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> class that contains the serialized data.</param>
      <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that describes the serialization state.</param>
    </member>
    <member name="M:LinFu.Proxy.ProxyObjectReference.GetRealObject(System.Runtime.Serialization.StreamingContext)">
      <summary>
            Returns the deserialized proxy instance.
            </summary>
      <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that describes the serialization state.</param>
      <returns>
      </returns>
    </member>
    <member name="M:LinFu.Proxy.ProxyObjectReference.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Serializes the proxy to a stream. 
            </summary>
      <remarks>This method override does nothing.</remarks>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> class that contains the serialized data.</param>
      <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that describes the serialization state.</param>
    </member>
    <member name="T:LinFu.Proxy.SerializableProxyBuilder">
      <summary>
            Represents a <see cref="T:LinFu.Proxy.ProxyBuilder" /> type that can create serializable proxy types.
            </summary>
    </member>
    <member name="M:LinFu.Proxy.SerializableProxyBuilder.Construct(System.Type,System.Collections.Generic.IEnumerable{System.Type},Mono.Cecil.ModuleDefinition,Mono.Cecil.TypeDefinition)">
      <summary>
            Generates a proxy that forwards all virtual method calls
            to a single <see cref="T:LinFu.AOP.Interfaces.IInterceptor" /> instance.
            </summary>
      <param name="originalBaseType">The base class of the type being constructed.</param>
      <param name="baseInterfaces">The list of interfaces that the new type must implement.</param>
      <param name="module">The module that will hold the brand new type.</param>
      <param name="targetType">The <see cref="T:Mono.Cecil.TypeDefinition" /> that represents the type to be created.</param>
    </member>
    <member name="T:LinFu.Proxy.ObjectExtensions">
      <summary>
            A class that adds proxy support to the <see cref="T:System.Object" /> class
            </summary>
    </member>
    <member name="M:LinFu.Proxy.ObjectExtensions.CreateDuck``1(System.Object,System.Type[])">
      <summary>
            Creates a duck type that redirects its calls to the
            given <paramref name="target" />.
            </summary>
      <param name="target">The target instance that will be invoked once the duck type instance has been invoked.</param>
      <param name="baseInterfaces">The additional list of interfaces that will be implemented by the duck type.</param>
      <typeparam name="T">The type parameter that describes the duck type.</typeparam>
      <returns>The return value from the target method.</returns>
    </member>
    <member name="M:LinFu.Proxy.ObjectExtensions.CreateDuck(System.Object,System.Type,System.Type[])">
      <summary>
            Creates a duck type that redirects its calls to the
            given <paramref name="target" />.
            </summary>
      <param name="target">The target instance that will be invoked once the duck type instance has been invoked.</param>
      <param name="duckType">The <see cref="T:System.Type" /> that describes the duck type.</param>
      <param name="baseInterfaces">The additional list of interfaces that will be implemented by the duck type.</param>
      <returns>The return value from the target method.</returns>
    </member>
    <member name="T:LinFu.Proxy.CallAdapter">
      <summary>
            Adapts an <see cref="T:LinFu.AOP.Interfaces.IInvokeWrapper" /> instance to an
            <see cref="T:LinFu.AOP.Interfaces.IInterceptor" /> instance.
            </summary>
    </member>
    <member name="M:LinFu.Proxy.CallAdapter.#ctor(LinFu.AOP.Interfaces.IInvokeWrapper)">
      <summary>
            Initializes the CallAdapter class with the <paramref name="wrapper" /> instance.
            </summary>
      <param name="wrapper">The <see cref="T:LinFu.AOP.Interfaces.IInvokeWrapper" /> instance that will be called every time the interceptor is invoked.</param>
    </member>
    <member name="M:LinFu.Proxy.CallAdapter.Intercept(LinFu.AOP.Interfaces.IInvocationInfo)">
      <summary>
            Intercepts a method call and passes the <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> arguments
            down to the <see cref="T:LinFu.AOP.Interfaces.IInvokeWrapper" /> instance.
            </summary>
      <param name="info">The <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> instance that describes the method currently being executed.</param>
      <returns>The return value of the target method.</returns>
    </member>
    <member name="T:LinFu.Proxy.Interfaces.FunctorAsInterceptor">
      <summary>
            A class that converts a functor into an <see cref="T:LinFu.AOP.Interfaces.IInterceptor" /> instance.
            </summary>
    </member>
    <member name="M:LinFu.Proxy.Interfaces.FunctorAsInterceptor.#ctor(System.Func{LinFu.AOP.Interfaces.IInvocationInfo,System.Object})">
      <summary>
            Initializes the class with the given <paramref name="intercept">functor</paramref>.
            </summary>
      <param name="intercept">The functor that will be invoked every time a method is called on the proxy type.</param>
    </member>
    <member name="M:LinFu.Proxy.Interfaces.FunctorAsInterceptor.Intercept(LinFu.AOP.Interfaces.IInvocationInfo)">
      <summary>
            A method that redirects the method calls to 
            the functor instance.
            </summary>
      <param name="info">The <see cref="T:LinFu.AOP.Interfaces.IInvocationInfo" /> instance that describes the context of the method call.</param>
      <returns>The return value from the target method.</returns>
    </member>
    <member name="T:LinFu.Proxy.Interfaces.IExtractInterfaces">
      <summary>
            A class that is responsible for determining
            which interfaces a given type should implement.
            </summary>
    </member>
    <member name="M:LinFu.Proxy.Interfaces.IExtractInterfaces.GetInterfaces(System.Type,System.Collections.Generic.HashSet{System.Type})">
      <summary>
            Determines which interfaces a given type should implement.
            </summary>
      <param name="currentType">The base type that holds the list of interfaces to implement.</param>
      <param name="interfaces">The list of interfaces already being implemented. </param>
    </member>
    <member name="T:LinFu.Proxy.Interfaces.IMethodBodyEmitter">
      <summary>
            Represents a class that is responsible for
            constructing method bodies.
            </summary>
    </member>
    <member name="M:LinFu.Proxy.Interfaces.IMethodBodyEmitter.Emit(System.Reflection.MethodInfo,Mono.Cecil.MethodDefinition)">
      <summary>
            Generates the method body for the <paramref name="targetMethod">target method</paramref>.
            </summary>
      <param name="originalMethod">The original method that the <paramref name="targetMethod" /> will be based on.</param>
      <param name="targetMethod">The method that will contain the method body to be emitted.</param>
    </member>
    <member name="T:LinFu.Proxy.Interfaces.IMethodPicker">
      <summary>
            Represents a class that determines which methods should be proxied
            by a given proxy factory.
            </summary>
    </member>
    <member name="M:LinFu.Proxy.Interfaces.IMethodPicker.ChooseProxyMethodsFrom(System.Type,System.Collections.Generic.IEnumerable{System.Type})">
      <summary>
            Determines which methods should be proxied
            by a given proxy factory.
            </summary>
      <param name="baseType">The base class of the proxy type currently being generated.</param>
      <param name="baseInterfaces">The list of interfaces that the proxy must implement.</param>
      <returns>A list of <see cref="T:System.Reflection.MethodInfo" /> objects that can be proxied.</returns>
    </member>
    <member name="T:LinFu.Proxy.Interfaces.IMethodBuilder">
      <summary>
            Represents a class that generates methods based on other existing
            methods.
            </summary>
    </member>
    <member name="M:LinFu.Proxy.Interfaces.IMethodBuilder.CreateMethod(Mono.Cecil.TypeDefinition,System.Reflection.MethodInfo)">
      <summary>
            Creates a method that matches the signature defined in the
            <paramref name="method" /> parameter.
            </summary>
      <param name="targetType">The type that will host the new method.</param>
      <param name="method">The method from which the signature will be derived.</param>
    </member>
    <member name="T:LinFu.Proxy.Interfaces.IProxyCache">
      <summary>
            Represents an interface for classes that store results from an
            <see cref="T:LinFu.Proxy.Interfaces.IProxyFactory" /> instance.
            </summary>
    </member>
    <member name="M:LinFu.Proxy.Interfaces.IProxyCache.Contains(System.Type,System.Type[])">
      <summary>
            Determines whether or not the cache contains an existing proxy type
            that is derived from the <paramref name="baseType" /> and implements
            the given <paramref name="baseInterfaces" />.
            </summary>
      <param name="baseType">The base type of the dynamically-generated proxy type.</param>
      <param name="baseInterfaces">The list of interfaces that the generated proxy type must implement.</param>
      <returns>Returns <c>true</c> if the proxy type already exists; otherwise, it will return <c>false.</c></returns>
    </member>
    <member name="M:LinFu.Proxy.Interfaces.IProxyCache.Get(System.Type,System.Type[])">
      <summary>
            Retrieves an existing proxy type from the cache.
            </summary>
      <param name="baseType">The base type of the dynamically-generated proxy type.</param>
      <param name="baseInterfaces">The list of interfaces that the generated proxy type must implement.</param>
      <returns>Returns a valid <see cref="T:System.Type" /> if the type already exists; otherwise, it might return <c>null</c> or opt to throw an exception.</returns>
    </member>
    <member name="M:LinFu.Proxy.Interfaces.IProxyCache.Store(System.Type,System.Type,System.Type[])">
      <summary>
            Stores a proxy type in the cache.
            </summary>
      <param name="result">The proxy type to be stored.</param>
      <param name="baseType">The base type of the dynamically-generated proxy type.</param>
      <param name="baseInterfaces">The list of interfaces that the generated proxy type must implement.</param>
    </member>
    <member name="T:LinFu.Proxy.Interfaces.IProxy">
      <summary>
            Represents a dynamically generated proxy instance.
            </summary>
    </member>
    <member name="P:LinFu.Proxy.Interfaces.IProxy.Interceptor">
      <summary>
            The interceptor that will handle all
            calls made to the proxy instance.
            </summary>
    </member>
    <member name="T:LinFu.Proxy.Interfaces.IProxyBuilder">
      <summary>
            Represents a class that is responsible
            for generating proxy types.
            </summary>
    </member>
    <member name="M:LinFu.Proxy.Interfaces.IProxyBuilder.Construct(System.Type,System.Collections.Generic.IEnumerable{System.Type},Mono.Cecil.ModuleDefinition,Mono.Cecil.TypeDefinition)">
      <summary>
            Generates a proxy that must be derived
            from the <paramref name="baseType" /> and implement
            the list of <paramref name="interfaces" />.
            </summary>
      <param name="baseType">The base class of the type being constructed.</param>
      <param name="interfaces">The list of interfaces that the new type must implement.</param>
      <param name="module">The module that will hold the brand new type.</param>
      <param name="targetType">The <see cref="T:Mono.Cecil.TypeDefinition" /> that represents the type to be created.</param>
    </member>
    <member name="T:LinFu.Proxy.Interfaces.IProxyFactory">
      <summary>
            Represents the basic interface for creating
            dynamic proxy instances.
            </summary>
    </member>
    <member name="M:LinFu.Proxy.Interfaces.IProxyFactory.CreateProxyType(System.Type,System.Collections.Generic.IEnumerable{System.Type})">
      <summary>
            Generates a dynamic proxy type
            that derives from the <paramref name="baseType" />
            and implements the given <paramref name="baseInterfaces">interfaces</paramref>.
            </summary>
      <param name="baseType">The base class from which the generated dynamic proxy will be derived.</param>
      <param name="baseInterfaces">The list of interfaces that the generated dynamic proxy will implement.</param>
      <returns>A dynamic proxy type.</returns>
    </member>
    <member name="T:LinFu.Proxy.Interfaces.ProxyFactoryExtensions">
      <summary>
            Extends the <see cref="T:LinFu.Proxy.Interfaces.IProxyFactory" /> class to support
            instantiating proxy types.
            </summary>
    </member>
    <member name="M:LinFu.Proxy.Interfaces.ProxyFactoryExtensions.CreateProxy(LinFu.Proxy.Interfaces.IProxyFactory,System.Type,LinFu.AOP.Interfaces.IInvokeWrapper,System.Type[])">
      <summary>
            Uses the <paramref name="factory" /> to create a proxy instance 
            that directly derives from the <paramref name="instanceType" /> 
            and implements the given <paramref name="baseInterfaces" />.
            The <paramref name="wrapper" /> instance, in turn, will be used
            to intercept the method calls made to the proxy itself.
            </summary>
      <param name="factory">The IProxyFactory instance that will be used to generate the proxy type.</param>
      <param name="instanceType">The type that will be intercepted by the proxy.</param>
      <param name="wrapper">The <see cref="T:LinFu.AOP.Interfaces.IInvokeWrapper" /> instance that will be used to intercept method calls made to the proxy.</param>
      <param name="baseInterfaces">The additional list of interfaces that the proxy will implement.</param>
      <returns>A valid proxy instance.</returns>
    </member>
    <member name="M:LinFu.Proxy.Interfaces.ProxyFactoryExtensions.CreateProxy(LinFu.Proxy.Interfaces.IProxyFactory,System.Type,LinFu.AOP.Interfaces.IInterceptor,System.Type[])">
      <summary>
            Uses the <paramref name="factory" /> to create a proxy instance 
            that directly derives from the <paramref name="instanceType" /> 
            and implements the given <paramref name="baseInterfaces" />.
            The <paramref name="interceptor" /> instance, in turn, will be used
            to intercept the method calls made to the proxy itself.
            </summary>
      <param name="factory">The IProxyFactory instance that will be used to generate the proxy type.</param>
      <param name="instanceType">The type that will be intercepted by the proxy.</param>
      <param name="interceptor">The <see cref="T:LinFu.AOP.Interfaces.IInterceptor" /> instance that will be used to intercept method calls made to the proxy.</param>
      <param name="baseInterfaces">The additional list of interfaces that the proxy will implement.</param>
      <returns>A valid proxy instance.</returns>
    </member>
    <member name="M:LinFu.Proxy.Interfaces.ProxyFactoryExtensions.CreateProxy``1(LinFu.Proxy.Interfaces.IProxyFactory,LinFu.AOP.Interfaces.IInvokeWrapper,System.Type[])">
      <summary>
            Uses the <paramref name="factory" /> to create a proxy instance 
            that directly derives from the <typeparamref name="T" /> type
            and implements the given <paramref name="baseInterfaces" />.
            The <paramref name="wrapper" /> instance, in turn, will be used
            to intercept the method calls made to the proxy itself.
            </summary>
      <typeparam name="T">The type that will be intercepted by the proxy.</typeparam>
      <param name="factory">The IProxyFactory instance that will be used to generate the proxy type.</param>
      <param name="wrapper">The <see cref="T:LinFu.AOP.Interfaces.IInvokeWrapper" /> instance that will be used to intercept method calls made to the proxy.</param>
      <param name="baseInterfaces">The additional list of interfaces that the proxy will implement.</param>
      <returns>A valid proxy instance.</returns>
    </member>
    <member name="M:LinFu.Proxy.Interfaces.ProxyFactoryExtensions.CreateProxy``1(LinFu.Proxy.Interfaces.IProxyFactory,LinFu.AOP.Interfaces.IInterceptor,System.Type[])">
      <summary>
            Uses the <paramref name="factory" /> to create a proxy instance 
            that directly derives from the <typeparamref name="T" /> type
            and implements the given <paramref name="baseInterfaces" />.
            The <paramref name="interceptor" /> instance, in turn, will be used
            to intercept the method calls made to the proxy itself.
            </summary>
      <typeparam name="T">The type that will be intercepted by the proxy.</typeparam>
      <param name="factory">The IProxyFactory instance that will be used to generate the proxy type.</param>
      <param name="interceptor">The <see cref="T:LinFu.AOP.Interfaces.IInterceptor" /> instance that will be used to intercept method calls made to the proxy.</param>
      <param name="baseInterfaces">The additional list of interfaces that the proxy will implement.</param>
      <returns>A valid proxy instance.</returns>
    </member>
    <member name="M:LinFu.Proxy.Interfaces.ProxyFactoryExtensions.CreateProxy``1(LinFu.Proxy.Interfaces.IProxyFactory,System.Func{System.String,System.Type[],System.Object[],System.Object},System.Type[])">
      <summary>
            Uses the <paramref name="proxyFactory" /> to create a proxy instance
            that directly derives from the <typeparamref name="T" /> type
            and implements the given <paramref name="baseInterfaces" />.
            </summary>
      <remarks>
            The <paramref name="proxyImplementation" /> will be used to intercept method calls
            performed against the target instance.
            </remarks>
      <typeparam name="T">The type that will be intercepted by the proxy.</typeparam>
      <param name="proxyFactory">The IProxyFactory instance that will be used to generate the proxy type.</param>
      <param name="proxyImplementation">The functor that will invoked every time a method is called on the proxy.</param>
      <param name="baseInterfaces">The additional list of interfaces that the proxy will implement.</param>
      <returns>A valid proxy instance.</returns>
    </member>
    <member name="M:LinFu.Proxy.Interfaces.ProxyFactoryExtensions.CreateProxy(LinFu.Proxy.Interfaces.IProxyFactory,System.Type,System.Func{System.String,System.Type[],System.Object[],System.Object},System.Type[])">
      <summary>
            Uses the <paramref name="proxyFactory" /> to create a proxy instance
            that directly derives from the <typeparamref name="T" /> type
            and implements the given <paramref name="baseInterfaces" />.
            </summary>
      <remarks>
            The <paramref name="proxyImplementation" /> will be used to intercept method calls
            performed against the target instance.
            </remarks>
      <param name="targetType">The type that will be intercepted by the proxy.</param>
      <param name="proxyFactory">The IProxyFactory instance that will be used to generate the proxy type.</param>
      <param name="proxyImplementation">The functor that will invoked every time a method is called on the proxy.</param>
      <param name="baseInterfaces">The additional list of interfaces that the proxy will implement.</param>
      <returns>A valid proxy instance.</returns>
    </member>
    <member name="T:LinFu.Reflection.IActionLoader`2">
      <summary>
            Represents a class that can configure 
            a target of type <typeparamref name="TTarget" />
            using an input type of <typeparamref name="TInput" />.
            </summary>
      <typeparam name="TTarget">The target type to configure.</typeparam>
      <typeparam name="TInput">The input that will be used to configure the target.</typeparam>
    </member>
    <member name="M:LinFu.Reflection.IActionLoader`2.Load(`1)">
      <summary>
            Generates a set of <see cref="T:System.Action`1" /> instances
            using the given <paramref name="input" />.
            </summary>
      <param name="input">The input that will be used to configure the target.</param>
      <returns>A set of <see cref="T:System.Action`1" /> instances. This cannot be <c>null</c>.</returns>
    </member>
    <member name="M:LinFu.Reflection.IActionLoader`2.CanLoad(`1)">
      <summary>
            Determines if the PluginLoader can load the <paramref name="inputType" />.
            </summary>
      <param name="inputType">The target type that might contain the target <typeparamref name="TAttribute" /> instance.</param>
      <returns>
        <c>true</c> if the type can be loaded; otherwise, it returns <c>false</c>.</returns>
    </member>
    <member name="T:LinFu.Reflection.AssemblyActionLoader`1">
      <summary>
            A class that reads an assembly and converts it into a set of actions
            that can be used to build the list of actions against the <typeparamref name="TTarget" />
            type.
            </summary>
      <typeparam name="TTarget">The target type.</typeparam>
    </member>
    <member name="M:LinFu.Reflection.AssemblyActionLoader`1.#ctor(System.Func{System.Collections.Generic.IList{LinFu.Reflection.IActionLoader{`0,System.Type}}})">
      <summary>
            Initializes the class with a set of <see cref="T:LinFu.Reflection.IActionLoader`2" />
            instances that will be used to load the target assembly.
            </summary>
      <param name="getTypeLoaders">The delegate that will return the actual list of typeloaders.</param>
    </member>
    <member name="M:LinFu.Reflection.AssemblyActionLoader`1.Load(System.Reflection.Assembly)">
      <summary>
            Loads the target assembly and creates an action that can
            create the list of actions which will modify the <typeparamref name="TTarget" /> instance.
            </summary>
      <param name="input">The target assembly.</param>
      <returns>The list of actions which will modify the list of actions that will be executed against the <typeparamref name="TTarget" /> instance.</returns>
    </member>
    <member name="M:LinFu.Reflection.AssemblyActionLoader`1.CanLoad(System.Reflection.Assembly)">
      <summary>
            Determines if an <see cref="T:System.Reflection.Assembly" /> instance can be loaded.
            </summary>
      <param name="assembly">The target assembly.</param>
      <returns>Returns <c>true</c> if the assembly is not <c>null</c>.</returns>
    </member>
    <member name="M:LinFu.Reflection.AssemblyActionLoader`1.CreateActionsFrom(System.Reflection.Assembly,System.Collections.Generic.IList{System.Action{`0}})">
      <summary>
            Generates a list of actions from a target assemby.
            </summary>
      <param name="assembly">The target assembly.</param>
      <param name="resultList">The list that will store the resulting actions.</param>
    </member>
    <member name="M:LinFu.Reflection.AssemblyActionLoader`1.LoadResultsFromType(System.Type,System.Collections.Generic.ICollection{System.Action{`0}})">
      <summary>
            Generates the list of <see cref="T:System.Action`1" />
            instances which will be used to configure a target instance.
            </summary>
      <param name="type">The <see cref="T:System.Type" /> instance that holds the configuration information.</param>
      <param name="results">The list that will hold the actions which will configure the container.</param>
    </member>
    <member name="P:LinFu.Reflection.AssemblyActionLoader`1.TypeExtractor">
      <summary>
            The <see cref="T:LinFu.Reflection.ITypeExtractor" /> instance that will
            determine which types will be extracted from an assembly.
            </summary>
    </member>
    <member name="T:LinFu.Reflection.IAssemblyLoader">
      <summary>
            Represents a class that loads assemblies into memory
            from disk.
            </summary>
    </member>
    <member name="M:LinFu.Reflection.IAssemblyLoader.Load(System.String)">
      <summary>
            Loads the target assembly into memory.
            </summary>
      <param name="assemblyFile">The full path and filename of the assembly to load.</param>
      <returns>A loaded <see cref="T:System.Reflection.Assembly" /> instance.</returns>
    </member>
    <member name="T:LinFu.Reflection.AssemblyLoader">
      <summary>
            Represents a class that loads assemblies into memory
            from disk.
            </summary>
    </member>
    <member name="M:LinFu.Reflection.AssemblyLoader.Load(System.String)">
      <summary>
            Loads the target assembly into memory.
            </summary>
      <param name="assemblyFile">The full path and filename of the assembly to load.</param>
      <returns>A loaded <see cref="T:System.Reflection.Assembly" /> instance.</returns>
    </member>
    <member name="T:LinFu.Reflection.IAssemblyTargetLoader`1">
      <summary>
            Represents a specific <see cref="T:LinFu.Reflection.IActionLoader`2" />
            type that can load configuration information from an assembly
            and apply it to a <typeparamref name="TTarget" /> instance.
            </summary>
      <typeparam name="TTarget">The target type to configure.</typeparam>
    </member>
    <member name="P:LinFu.Reflection.IAssemblyTargetLoader`1.AssemblyLoader">
      <summary>
            The <see cref="T:LinFu.Reflection.IAssemblyLoader" /> instance that will load
            the target assemblies.
            </summary>
    </member>
    <member name="P:LinFu.Reflection.IAssemblyTargetLoader`1.TypeLoaders">
      <summary>
            The list of ActionLoaders that will be used to
            configure the target.
            </summary>
    </member>
    <member name="T:LinFu.Reflection.AssemblyTargetLoader`1">
      <summary>
            Represents a loader class that takes <see cref="T:System.Type" />
            instances as input and generates <see cref="T:System.Action`1" />
            instances that can be used to configure a <typeparamref name="TTarget" />
            instance.
            </summary>
      <typeparam name="TTarget">The target type to configure.</typeparam>
    </member>
    <member name="M:LinFu.Reflection.AssemblyTargetLoader`1.#ctor">
      <summary>
            Initializes the class with the default property values.
            </summary>
    </member>
    <member name="M:LinFu.Reflection.AssemblyTargetLoader`1.CanLoad(System.String)">
      <summary>
            Determines whether or not the current type loader
            instance can load the current file type.
            </summary>
      <remarks>
            This class only loads assemblies with the ".dll" extension.
            </remarks>
      <param name="filename">The filename and full path of the target file.</param>
      <returns>Returns <c>true</c> if the file can be loaded; otherwise, the result is <c>false</c>.</returns>
    </member>
    <member name="M:LinFu.Reflection.AssemblyTargetLoader`1.Load(System.String)">
      <summary>
            Reads an input file using the given <paramref name="filename" />
            and converts it into a set of <see cref="T:System.Action`1" />
            instances that can be applied to a target class instance..
            </summary>
      <remarks>This class can only load valid .NET Assemblies.</remarks>
      <param name="filename">The target file to be loaded.</param>
      <returns>A set of <see cref="T:System.Action`1" /> instances to apply to a target type.</returns>
    </member>
    <member name="P:LinFu.Reflection.AssemblyTargetLoader`1.AssemblyLoader">
      <summary>
            The <see cref="T:LinFu.Reflection.IAssemblyLoader" /> instance that will load
            the target assemblies.
            </summary>
    </member>
    <member name="P:LinFu.Reflection.AssemblyTargetLoader`1.AssemblyActionLoader">
      <summary>
            Gets or sets the value indicating the action loader 
            responsible for reading an assembly and converts it to 
            a list of actions to be performed against the target type.
            </summary>
    </member>
    <member name="P:LinFu.Reflection.AssemblyTargetLoader`1.TypeLoaders">
      <summary>
            The list of ActionLoaders that will be used to
            configure the target.
            </summary>
    </member>
    <member name="T:LinFu.Reflection.BasePluginLoader`2">
      <summary>
            Implements the basic functionality of a plugin loader.
            </summary>
      <typeparam name="TTarget">The target type being configured.</typeparam>
      <typeparam name="TAttribute">The attribute type that will be used to mark a type as a plugin.</typeparam>
    </member>
    <member name="M:LinFu.Reflection.BasePluginLoader`2.CanLoad(System.Type)">
      <summary>
            Determines if the plugin loader can load the <paramref name="inputType" />.
            </summary>
      <param name="inputType">The target type that might contain the target <typeparamref name="TAttribute" /> instance.</param>
      <returns>
        <c>true</c> if the type can be loaded; otherwise, it returns <c>false</c>.</returns>
    </member>
    <member name="M:LinFu.Reflection.BasePluginLoader`2.Load(System.Type)">
      <summary>
            Generates a set of <see cref="T:System.Action`1" /> instances
            using the given <paramref name="input" />.
            </summary>
      <param name="input">The input that will be used to configure the target.</param>
      <returns>A set of <see cref="T:System.Action`1" /> instances. This cannot be <c>null</c>.</returns>
    </member>
    <member name="T:LinFu.Reflection.CollectionExtensions">
      <summary>
            Adds additional support methods to the standard System.Collection classes.
            </summary>
    </member>
    <member name="M:LinFu.Reflection.CollectionExtensions.HasElementWith``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
      <summary>
            Determines whether or not an element exists that matches the given
            <paramref name="predicate" />.
            </summary>
      <typeparam name="T">The element type.</typeparam>
      <param name="items">The list of items being searched.</param>
      <param name="predicate">The predicate that will be used to describe the matching items.</param>
      <returns>Returns <c>true</c> if at least one match is found; otherwise, it will return <c>false</c>.</returns>
    </member>
    <member name="M:LinFu.Reflection.CollectionExtensions.LoadFrom``1(System.Collections.Generic.ICollection{``0},System.String,System.String)">
      <summary>
            Loads a list of types that match the given <typeparamref name="T">target type</typeparamref>.
            </summary>
      <typeparam name="T">The target type to be loaded.</typeparam>
      <param name="list">The list that will hold the instances of the target type.</param>
      <param name="targetDirectory">The directory that will be used to scan for assemblies that contain the target type.</param>
      <param name="filespec">The wildcard pattern that describes the files to be loaded.</param>
    </member>
    <member name="T:LinFu.Reflection.IDirectoryListing">
      <summary>
            Represents a class that can list the files
            in a given directory.
            </summary>
    </member>
    <member name="M:LinFu.Reflection.IDirectoryListing.GetFiles(System.String,System.String)">
      <summary>
            Returns the names of the files in the specified directory
            that match the specified search pattern.
            </summary>
      <param name="path">The directory to search.</param>
      <param name="searchPattern">The search string to match against the names of the files in the <paramref name="path" />.</param>
      <returns>The list of files that match the <paramref name="path" /> and <paramref name="searchPattern" /></returns>
    </member>
    <member name="T:LinFu.Reflection.DefaultDirectoryLister">
      <summary>
            A class that lists the contents of a given directory.
            </summary>
    </member>
    <member name="M:LinFu.Reflection.DefaultDirectoryLister.GetFiles(System.String,System.String)">
      <summary>
            Returns a list of files that match the <paramref name="searchPattern" />
            from the given directory <paramref name="path" />.
            </summary>
      <param name="path">The target directory to search.</param>
      <param name="searchPattern">The search string to match against the names of the files in the <paramref name="path" />.</param>
      <returns>The list of files that match the <paramref name="path" /> and <paramref name="searchPattern" /></returns>
    </member>
    <member name="T:LinFu.Reflection.IInitialize`1">
      <summary>
            Represents classes that need to be initialized
            every time a particular 
            instance creates that type.
            </summary>
    </member>
    <member name="M:LinFu.Reflection.IInitialize`1.Initialize(`0)">
      <summary>
            Initializes the target with the
            particular <typeparamref name="T" /> instance.
            </summary>
      <param name="source">The <typeparamref name="T" /> instance that will hold the target type.</param>
    </member>
    <member name="T:LinFu.Reflection.ILoader`1">
      <summary>
            Represents a generic interface for an abstract loader
            that can read configuration information from disk
            and apply it to a <typeparamref name="TTarget" /> instance.
            </summary>
      <typeparam name="TTarget">The class type being configured.</typeparam>
    </member>
    <member name="M:LinFu.Reflection.ILoader`1.LoadDirectory(System.String,System.String)">
      <summary>
            Loads the configuration using the files listed in 
            the target <paramref name="directory" /> that match 
            the given <paramref name="filespec">file pattern</paramref>.
            </summary>
      <param name="directory">The full path of the location to scan.</param>
      <param name="filespec">The wildcard file pattern string to use when specifying the target files.</param>
    </member>
    <member name="M:LinFu.Reflection.ILoader`1.LoadInto(`0)">
      <summary>
            Configures the <paramref name="target" /> instance 
            using the configuration currently loaded from disk.
            </summary>
      <param name="target">The <typeparamref name="TTarget" /> instance to be configured.</param>
    </member>
    <member name="M:LinFu.Reflection.ILoader`1.Reset">
      <summary>
            Clears the currently loaded configuration
            and resets the loader back to its defaults.
            </summary>
    </member>
    <member name="P:LinFu.Reflection.ILoader`1.Plugins">
      <summary>
            The list of <see cref="T:LinFu.Reflection.ILoaderPlugin`1" />
            instances that will be used to
            signal the beginning and end of the
            load sequence.
            </summary>
    </member>
    <member name="P:LinFu.Reflection.ILoader`1.FileLoaders">
      <summary>
            The list of <see cref="T:LinFu.Reflection.IActionLoader`2" />
            instances responsible for configuring the <typeparamref name="TTarget" /> instance.
            </summary>
    </member>
    <member name="P:LinFu.Reflection.ILoader`1.DirectoryLister">
      <summary>
            Gets or sets the <see cref="T:LinFu.Reflection.IDirectoryListing" /> instance 
            responsible for returning a list of filenames
            to the loader for processing.
            </summary>
    </member>
    <member name="P:LinFu.Reflection.ILoader`1.CustomLoaderActions">
      <summary>
            The custom list of actions that will be
            performed prior to the beginning of a load operation.
            </summary>
    </member>
    <member name="P:LinFu.Reflection.ILoader`1.QueuedActions">
      <summary>
            The list of actions that will execute
            every time a target instance is configured.
            </summary>
    </member>
    <member name="T:LinFu.Reflection.ILoaderPlugin`1">
      <summary>
            Represents a component that can monitor
            a target instance as it loads.
            </summary>
      <typeparam name="TTarget">The target instance type.</typeparam>
    </member>
    <member name="M:LinFu.Reflection.ILoaderPlugin`1.BeginLoad(`0)">
      <summary>
            Signals the beginning of a load.
            </summary>
      <param name="target">The target being loaded.</param>
    </member>
    <member name="M:LinFu.Reflection.ILoaderPlugin`1.EndLoad(`0)">
      <summary>
            Signals the end of a load.
            </summary>
      <param name="target">The target being loaded.</param>
    </member>
    <member name="T:LinFu.Reflection.ITypeExtractor">
      <summary>
            Represents a type that can extract <see cref="T:System.Type" />
            objects from an <see cref="T:System.Reflection.Assembly" /> instance.
            </summary>
    </member>
    <member name="M:LinFu.Reflection.ITypeExtractor.GetTypes(System.Reflection.Assembly)">
      <summary>
            Returns a set of types from a given assembly.
            </summary>
      <param name="targetAssembly">The <see cref="T:System.Reflection.Assembly" /> that contains the target types.</param>
      <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of types from the target assembly.</returns>
    </member>
    <member name="T:LinFu.Reflection.CollectionLoader`1">
      <summary>
            Represents an action loader that can load collections from types embedded within a given assembly.
            </summary>
      <typeparam name="T">The collection item type.</typeparam>
    </member>
    <member name="M:LinFu.Reflection.CollectionLoader`1.Load(System.Type)">
      <summary>
            Creates the list of actions that load the target collection into memory.
            </summary>
      <param name="input">The source type.</param>
      <returns>A list of actions that load the target collection into memory.</returns>
    </member>
    <member name="M:LinFu.Reflection.CollectionLoader`1.CanLoad(System.Type)">
      <summary>
            Determines whether or not the given type can be loaded into memory.
            </summary>
      <param name="inputType">The source type.</param>
      <returns>Returns <c>true</c> if the type can be loaded into memory; otherwise, it will return <c>false</c>.</returns>
    </member>
    <member name="T:LinFu.Reflection.Loader`1">
      <summary>
            Represents a generic loader class that can
            load multiple <see cref="T:System.Action`1" /> delegates from multiple files and
            apply them to a particular <typeparamref name="TTarget" /> instance.
            </summary>
      <typeparam name="TTarget">
      </typeparam>
    </member>
    <member name="M:LinFu.Reflection.Loader`1.#ctor">
      <summary>
            Initializes the target with the default settings.
            </summary>
    </member>
    <member name="M:LinFu.Reflection.Loader`1.LoadDirectory(System.String,System.String)">
      <summary>
            Loads the container with the files listed in 
            the target <paramref name="directory" /> that match 
            the given <paramref name="filespec">file pattern</paramref>.
            </summary>
      <param name="directory">The full path of the location to scan.</param>
      <param name="filespec">The wildcard file pattern string to use when specifying the target files.</param>
    </member>
    <member name="M:LinFu.Reflection.Loader`1.LoadInto(`0)">
      <summary>
            Loads the current configuration into the <paramref name="target" />
            instance.
            </summary>
      <param name="target">
      </param>
    </member>
    <member name="M:LinFu.Reflection.Loader`1.ShouldLoad(LinFu.Reflection.ILoaderPlugin{`0})">
      <summary>
            Determines whether or not a specific plugin should be loaded.
            </summary>
      <param name="plugin">The target plugin to be loaded.</param>
      <returns>
        <c>true</c> if the plugin should be loaded; otherwise, it will return <c>false</c>.</returns>
    </member>
    <member name="M:LinFu.Reflection.Loader`1.Reset">
      <summary>
            Clears the currently loaded configuration
            and resets the loader back to its defaults.
            </summary>
    </member>
    <member name="M:LinFu.Reflection.Loader`1.LoadFile(System.String)">
      <summary>
            Loads the <paramref name="currentFile">current file</paramref>
            using the list of associated <see cref="P:LinFu.Reflection.Loader`1.FileLoaders" />.
            </summary>
      <param name="currentFile">The full path and filename being loaded.</param>
    </member>
    <member name="P:LinFu.Reflection.Loader`1.QueuedActions">
      <summary>
            The list of actions that will execute
            every time a target instance is configured.
            </summary>
    </member>
    <member name="P:LinFu.Reflection.Loader`1.CustomLoaderActions">
      <summary>
            The custom list of actions that will be
            performed prior to the beginning of the first load operation.
            </summary>
      <remarks>
            These actions will be performed only once per reset.
            </remarks>
    </member>
    <member name="P:LinFu.Reflection.Loader`1.Plugins">
      <summary>
            The list of <see cref="T:LinFu.Reflection.ILoaderPlugin`1" />
            instances that will be used to
            signal the beginning and end of the
            load sequence.
            </summary>
    </member>
    <member name="P:LinFu.Reflection.Loader`1.FileLoaders">
      <summary>
            The list of <see cref="T:LinFu.Reflection.IActionLoader`2" />
            instances responsible for configuring the target instance.
            </summary>
    </member>
    <member name="P:LinFu.Reflection.Loader`1.DirectoryLister">
      <summary>
            Gets or sets the <see cref="T:LinFu.Reflection.IDirectoryListing" /> instance 
            responsible for returning a list of filenames
            to the loader for processing.
            </summary>
    </member>
    <member name="T:LinFu.Reflection.LoaderPluginAttribute">
      <summary>
            Marks a class as a loader plugin type.
            </summary>
    </member>
    <member name="T:LinFu.Reflection.PluginLoader`2">
      <summary>
            Represents a loader class that can load
            <see cref="T:LinFu.Reflection.ILoaderPlugin`1" /> instances
            marked with a particular <typeparamref name="TAttribute" />
            type.
            </summary>
      <typeparam name="TTarget">The target type being configured.</typeparam>
      <typeparam name="TAttribute">The attribute type that marks a type as a plugin type.</typeparam>
    </member>
    <member name="M:LinFu.Reflection.PluginLoader`2.CanLoad(System.Type)">
      <summary>
            Determines if the plugin loader can load the <paramref name="inputType" />.
            </summary>
      <remarks>The target type must implement <see cref="T:LinFu.Reflection.ILoaderPlugin`1" /> before it can be loaded.</remarks>
      <param name="inputType">The target type that might contain the target <typeparamref name="TAttribute" /> instance.</param>
      <returns>
        <c>true</c> if the type can be loaded; otherwise, it returns <c>false</c>.</returns>
    </member>
    <member name="M:LinFu.Reflection.PluginLoader`2.Load(System.Type)">
      <summary>
            Loads a set of actions from a <see cref="T:System.Type" />
            instance.
            </summary>
      <param name="input">The target type to scan.</param>
      <returns>A set of actions which will be applied to the target <see cref="T:LinFu.Reflection.ILoader`1" /> instance.</returns>
    </member>
    <member name="T:LinFu.Reflection.Plugins.BaseLoaderPlugin`1">
      <summary>
            A class that implements the basic functionality of
            a loader plugin.
            </summary>
      <typeparam name="TTarget">The type being loaded.</typeparam>
    </member>
    <member name="M:LinFu.Reflection.Plugins.BaseLoaderPlugin`1.BeginLoad(`0)">
      <summary>
            Signals the beginning of a load.
            </summary>
      <param name="target">The target being loaded.</param>
    </member>
    <member name="M:LinFu.Reflection.Plugins.BaseLoaderPlugin`1.EndLoad(`0)">
      <summary>
            Signals the end of a load.
            </summary>
      <param name="target">The target being loaded.</param>
    </member>
    <member name="T:LinFu.Reflection.Plugins.BaseTargetLoaderPlugin`1">
      <summary>
            A plugin class that provides the basic implementation
            for plugins that work with <see cref="T:LinFu.Reflection.IAssemblyTargetLoader`1" /> instances.
            </summary>
      <typeparam name="TTarget">The target type being configured.</typeparam>
    </member>
    <member name="M:LinFu.Reflection.Plugins.BaseTargetLoaderPlugin`1.Initialize(LinFu.Reflection.ILoader{`0})">
      <summary>
            Searches the loader for an <see cref="T:LinFu.Reflection.IAssemblyTargetLoader`1" />
            instance and uses its derived classes to initialize
            the assembly target loader.
            </summary>
      <param name="source">The <see cref="T:LinFu.Reflection.ILoader`1" /> instance that will hold the plugin.</param>
    </member>
    <member name="M:LinFu.Reflection.Plugins.BaseTargetLoaderPlugin`1.Initialize(LinFu.Reflection.ILoader{`0},LinFu.Reflection.IAssemblyTargetLoader{`0})">
      <summary>
            Initializes the <paramref name="loader" /> instance
            with the given <paramref name="assemblyLoader" /> instance.
            </summary>
      <param name="loader">The loader being configured.</param>
      <param name="assemblyLoader">The assembly loader that will load the types into the loader itself.</param>
    </member>
    <member name="T:LinFu.Reflection.Runtime">
      <summary>
            Adds helper methods that return information about the current
            runtime.
            </summary>
    </member>
    <member name="P:LinFu.Reflection.Runtime.IsRunningOnMono">
      <summary>
            Gets a value indicating if the application is
            currently running on the Mono platform.
            </summary>
    </member>
    <member name="T:LinFu.Reflection.TypeExtractor">
      <summary>
            Represents a type that can extract <see cref="T:System.Type" />
            objects from an <see cref="T:System.Reflection.Assembly" /> instance.
            </summary>
    </member>
    <member name="M:LinFu.Reflection.TypeExtractor.GetTypes(System.Reflection.Assembly)">
      <summary>
            Returns a set of types from a given assembly.
            </summary>
      <param name="targetAssembly">The <see cref="T:System.Reflection.Assembly" /> that contains the target types.</param>
      <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of types from the target assembly.</returns>
    </member>
    <member name="T:LinFu.Reflection.Emit.AssemblyDefinitionExtensions">
      <summary>
            A class that adds extension methods to the <see cref="T:Mono.Cecil.AssemblyDefinition" />
            class.
            </summary>
    </member>
    <member name="M:LinFu.Reflection.Emit.AssemblyDefinitionExtensions.ToAssembly(Mono.Cecil.AssemblyDefinition)">
      <summary>
            Converts an <see cref="T:Mono.Cecil.AssemblyDefinition" />
            into a running <see cref="T:System.Reflection.Assembly" />.
            </summary>
      <param name="definition">The <see cref="T:Mono.Cecil.AssemblyDefinition" /> to convert.</param>
      <returns>An <see cref="T:System.Reflection.Assembly" /> that represents the <see cref="T:Mono.Cecil.AssemblyDefinition" /> instance.
            </returns>
    </member>
    <member name="M:LinFu.Reflection.Emit.AssemblyDefinitionExtensions.Save(Mono.Cecil.AssemblyDefinition,System.String)">
      <summary>
            Saves the assembly to disk.
            </summary>
      <param name="definition">The target assembly definition.</param>
      <param name="filename">The output file name.</param>
    </member>
    <member name="M:LinFu.Reflection.Emit.AssemblyDefinitionExtensions.Save(Mono.Cecil.AssemblyDefinition,System.IO.Stream)">
      <summary>
            Saves the assembly to disk.
            </summary>
      <param name="definition">The target assembly definition.</param>
      <param name="outputStream">The destination file stream.</param>
    </member>
    <member name="T:LinFu.Reflection.Emit.CilWorkerExtensions">
      <summary>
            A class that extends the <see cref="T:Mono.Cecil.Cil.CilWorker" /> class
            with helper methods that make it easier to save
            information about the method currently being implemented.
            </summary>
    </member>
    <member name="M:LinFu.Reflection.Emit.CilWorkerExtensions.EmitWriteLineIfNull(Mono.Cecil.Cil.CilWorker,System.String,Mono.Cecil.Cil.VariableDefinition)">
      <summary>
            Emits a Console.WriteLine call to using the current CilWorker that will only be called if the contents
            of the target variable are null at runtime.
            </summary>
      <param name="IL">The target CilWorker.</param>
      <param name="text">The text that will be written to the console.</param>
      <param name="targetVariable">The target variable that will be checked for null at runtime.</param>
    </member>
    <member name="M:LinFu.Reflection.Emit.CilWorkerExtensions.EmitWriteLine(Mono.Cecil.Cil.CilWorker,System.String)">
      <summary>
            Emits a Console.WriteLine call using the current CilWorker.
            </summary>
      <param name="IL">The target CilWorker.</param>
      <param name="text">The text that will be written to the console.</param>
    </member>
    <member name="M:LinFu.Reflection.Emit.CilWorkerExtensions.PushMethod(Mono.Cecil.Cil.CilWorker,Mono.Cecil.MethodReference,Mono.Cecil.ModuleDefinition)">
      <summary>
            Pushes the current <paramref name="method" /> onto the stack.
            </summary>
      <param name="IL">The <see cref="T:Mono.Cecil.Cil.CilWorker" /> that will be used to create the instructions.</param>
      <param name="method">The method that represents the <see cref="T:System.Reflection.MethodInfo" /> that will be pushed onto the stack.</param>
      <param name="module">The module that contains the host method.</param>
    </member>
    <member name="M:LinFu.Reflection.Emit.CilWorkerExtensions.GetDeclaringType(Mono.Cecil.MethodReference)">
      <summary>
            Gets the declaring type for the target method.
            </summary>
      <param name="method">The target method.</param>
      <returns>The declaring type.</returns>
    </member>
    <member name="M:LinFu.Reflection.Emit.CilWorkerExtensions.PushType(Mono.Cecil.Cil.CilWorker,Mono.Cecil.TypeReference,Mono.Cecil.ModuleDefinition)">
      <summary>
            Pushes a <paramref name="Type" /> instance onto the stack.
            </summary>
      <param name="IL">The <see cref="T:Mono.Cecil.Cil.CilWorker" /> that will be used to create the instructions.</param>
      <param name="type">The type that represents the <see cref="T:System.Type" /> that will be pushed onto the stack.</param>
      <param name="module">The module that contains the host method.</param>
    </member>
    <member name="M:LinFu.Reflection.Emit.CilWorkerExtensions.PushField(Mono.Cecil.Cil.CilWorker,Mono.Cecil.FieldReference,Mono.Cecil.ModuleDefinition)">
      <summary>
            Pushes the current <paramref name="field" /> onto the stack.
            </summary>
      <param name="IL">The <see cref="T:Mono.Cecil.Cil.CilWorker" /> that will be used to create the instructions.</param>
      <param name="field">The field that represents the <see cref="T:System.Reflection.FieldInfo" /> that will be pushed onto the stack.</param>
      <param name="module">The module that contains the target field.</param>
    </member>
    <member name="M:LinFu.Reflection.Emit.CilWorkerExtensions.PushArguments(Mono.Cecil.Cil.CilWorker,Mono.Cecil.IMethodSignature,Mono.Cecil.ModuleDefinition,Mono.Cecil.Cil.VariableDefinition)">
      <summary>
            Pushes the arguments of a method onto the stack.
            </summary>
      <param name="IL">The <see cref="T:Mono.Cecil.Cil.CilWorker" /> that will be used to create the instructions.</param>
      <param name="module">The module that contains the host method.</param>
      <param name="method">The target method.</param>
      <param name="arguments">The <see cref="T:Mono.Cecil.Cil.VariableDefinition">local variable</see> that will hold the array of arguments.</param>
    </member>
    <member name="M:LinFu.Reflection.Emit.CilWorkerExtensions.PushStackTrace(Mono.Cecil.Cil.CilWorker,Mono.Cecil.ModuleDefinition)">
      <summary>
            Pushes the stack trace of the currently executing method onto the stack.
            </summary>
      <param name="IL">The <see cref="T:Mono.Cecil.Cil.CilWorker" /> that will be used to create the instructions.</param>
      <param name="module">The module that contains the host method.</param>
    </member>
    <member name="M:LinFu.Reflection.Emit.CilWorkerExtensions.PushGenericArguments(Mono.Cecil.Cil.CilWorker,Mono.Cecil.IGenericParameterProvider,Mono.Cecil.ModuleDefinition,Mono.Cecil.Cil.VariableDefinition)">
      <summary>
            Saves the generic type arguments that were used to construct the method.
            </summary>
      <param name="IL">The <see cref="T:Mono.Cecil.Cil.CilWorker" /> that will be used to create the instructions.</param>
      <param name="method">The target method whose generic type arguments (if any) will be saved into the <paramref name="typeArguments">local variable</paramref>.</param>
      <param name="module">The module that contains the host method.</param>
      <param name="typeArguments">The local variable that will store the resulting array of <see cref="T:System.Type" /> objects.</param>
    </member>
    <member name="M:LinFu.Reflection.Emit.CilWorkerExtensions.SaveParameterTypes(Mono.Cecil.Cil.CilWorker,Mono.Cecil.MethodReference,Mono.Cecil.ModuleDefinition,Mono.Cecil.Cil.VariableDefinition)">
      <summary>
            Saves the current method signature of a method into an array
            of <see cref="T:System.Type" /> objects. This can be used to determine the
            signature of methods with generic type parameters or methods that have
            parameters that are generic parameters specified by the type itself.
            </summary>
      <param name="IL">The <see cref="T:Mono.Cecil.Cil.CilWorker" /> that will be used to create the instructions.</param>
      <param name="method">The target method whose generic type arguments (if any) will be saved into the local variable .</param>
      <param name="module">The module that contains the host method.</param>
      <param name="parameterTypes">The local variable that will store the current method signature.</param>
    </member>
    <member name="M:LinFu.Reflection.Emit.CilWorkerExtensions.PackageReturnValue(Mono.Cecil.Cil.CilWorker,Mono.Cecil.ModuleDefinition,Mono.Cecil.TypeReference)">
      <summary>
            Converts the return value of a method into the <paramref name="returnType">target type</paramref>.
            If the target type is void, then the value will simply be popped from the stack.
            </summary>
      <param name="IL">The <see cref="T:Mono.Cecil.Cil.CilWorker" /> that will be used to create the instructions.</param>
      <param name="module">The module that contains the host method.</param>
      <param name="returnType">The method return type itself.</param>
    </member>
    <member name="M:LinFu.Reflection.Emit.CilWorkerExtensions.Stind(Mono.Cecil.Cil.CilWorker,Mono.Cecil.TypeReference)">
      <summary>
            Emits the proper Stind (store indirect) IL instruction for the <paramref name="currentType" />.
            </summary>
      <param name="IL">The target <see cref="T:Mono.Cecil.Cil.CilWorker" /> that will emit the IL.</param>
      <param name="currentType">The type of data being stored.</param>
    </member>
    <member name="M:LinFu.Reflection.Emit.CilWorkerExtensions.PushParameter(Mono.Cecil.Cil.CilWorker,System.Int32,Mono.Cecil.Cil.VariableDefinition,Mono.Cecil.ParameterDefinition)">
      <summary>
            Stores the <paramref name="param">current parameter value</paramref>
            into the array of method <paramref name="arguments" />.
            </summary>
      <param name="IL">The <see cref="T:Mono.Cecil.Cil.CilWorker" /> that will be used to create the instructions.</param>
      <param name="arguments">The local variable that will store the method arguments.</param>
      <param name="index">The array index that indicates where the parameter value will be stored in the array of arguments.</param>
      <param name="param">The current argument value being stored.</param>
    </member>
    <member name="M:LinFu.Reflection.Emit.CilWorkerExtensions.GetMethod(Mono.Cecil.Cil.CilWorker)">
      <summary>
            Obtains the method definition that contains the current <see cref="T:Mono.Cecil.Cil.CilWorker" />.
            </summary>
      <param name="IL">The <see cref="T:Mono.Cecil.Cil.CilWorker" /> responsible for the method body.</param>
      <returns>A method definition.</returns>
    </member>
    <member name="M:LinFu.Reflection.Emit.CilWorkerExtensions.GetModule(Mono.Cecil.Cil.CilWorker)">
      <summary>
            Obtains the module that contains the current <see cref="T:Mono.Cecil.Cil.CilWorker" />.
            </summary>
      <param name="IL">The <see cref="T:Mono.Cecil.Cil.CilWorker" /> responsible for the method body.</param>
      <returns>The host module.</returns>
    </member>
    <member name="M:LinFu.Reflection.Emit.CilWorkerExtensions.GetDeclaringType(Mono.Cecil.TypeReference)">
      <summary>
            Obtains the declaring type for a given type reference.
            </summary>
      <param name="declaringType">The declaring ty pe.</param>
      <returns>The actual declaring type.</returns>
    </member>
    <member name="T:LinFu.Reflection.Emit.Interfaces.ITypeBuilder">
      <summary>
            Represents a type that can construct <see cref="T:Mono.Cecil.TypeDefinition" />
            types.
            </summary>
    </member>
    <member name="M:LinFu.Reflection.Emit.Interfaces.ITypeBuilder.Construct(Mono.Cecil.ModuleDefinition,Mono.Cecil.TypeDefinition)">
      <summary>
            Constructs a <paramref name="targetType" /> using
            the given <see cref="T:Mono.Cecil.ModuleDefinition" /> instance.
            </summary>
      <param name="module">The module that will hold the actual type.</param>
      <param name="targetType">The type being constructed.</param>
    </member>
    <member name="T:LinFu.Reflection.Emit.MethodDefinitionExtensions">
      <summary>
            A class that extends the <see cref="T:Mono.Cecil.MethodDefinition" />
            class with features similar to the features in the
            System.Reflection.Emit namespace.
            </summary>
    </member>
    <member name="M:LinFu.Reflection.Emit.MethodDefinitionExtensions.GetILGenerator(Mono.Cecil.MethodDefinition)">
      <summary>
            Returns the <see cref="T:Mono.Cecil.Cil.CilWorker" /> instance
            associated with the body of the <paramref name="method">target method</paramref>.
            </summary>
      <param name="method">The target method to be modified.</param>
      <returns>The <see cref="T:Mono.Cecil.Cil.CilWorker" /> instance that points to the instructions of the method body.</returns>
    </member>
    <member name="M:LinFu.Reflection.Emit.MethodDefinitionExtensions.AddLocal(Mono.Cecil.MethodDefinition,System.Type)">
      <summary>
            Adds a <see cref="T:Mono.Cecil.Cil.VariableDefinition">local variable</see>
            instance to the target <paramref name="methodDef">method definition</paramref>.
            </summary>
      <param name="methodDef">The <paramref name="methodDef" /> instance which will contain the local variable.</param>
      <param name="localType">The object <see cref="T:System.Type">type</see> that describes the type of objects that will be stored by the local variable.</param>
      <returns>A <see cref="T:Mono.Cecil.Cil.VariableDefinition" /> that represents the local variable itself.</returns>
    </member>
    <member name="M:LinFu.Reflection.Emit.MethodDefinitionExtensions.AddLocal(Mono.Cecil.MethodDefinition,System.String,System.Type)">
      <summary>
            Adds a named <see cref="T:Mono.Cecil.Cil.VariableDefinition">local variable</see>
            instance to the target <paramref name="method">method definition</paramref>.
            </summary>
      <param name="method">The <paramref name="method" /> instance which will contain the local variable.</param>
      <param name="variableName">The name of the local variable.</param>
      <param name="variableType">The object <see cref="T:System.Type">type</see> that describes the type of objects that will be stored by the local variable.</param>
      <returns>
      </returns>
    </member>
    <member name="M:LinFu.Reflection.Emit.MethodDefinitionExtensions.AddParameters(Mono.Cecil.MethodDefinition,System.Type[])">
      <summary>
            Adds a set of parameter types to the target <paramref name="method" />.
            </summary>
      <param name="method">The target method.</param>
      <param name="parameterTypes">The list of types that describe the method signature.</param>
    </member>
    <member name="M:LinFu.Reflection.Emit.MethodDefinitionExtensions.SetReturnType(Mono.Cecil.MethodDefinition,System.Type)">
      <summary>
            Assigns the <paramref name="returnType" /> for the target method.
            </summary>
      <param name="method">The target method.</param>
      <param name="returnType">The <see cref="T:System.Type" /> instance that describes the return type.</param>
    </member>
    <member name="M:LinFu.Reflection.Emit.MethodDefinitionExtensions.AddGenericParameter(Mono.Cecil.MethodDefinition,System.Type)">
      <summary>
            Adds a generic parameter type to the <paramref name="method" />.
            </summary>
      <param name="method">The target method.</param>
      <param name="parameterType">The parameter type.</param>
      <returns>A <see cref="T:Mono.Cecil.TypeReference" /> that represents the generic parameter type.</returns>
    </member>
    <member name="M:LinFu.Reflection.Emit.MethodDefinitionExtensions.AddLocal``1(Mono.Cecil.MethodDefinition)">
      <summary>
            Adds a <see cref="T:Mono.Cecil.Cil.VariableDefinition">local variable</see>
            instance to the target <paramref name="methodDef">method definition</paramref>.
            </summary>
      <typeparam name="T">The object <see cref="T:System.Type">type</see> that describes the type of objects that will be stored by the local variable.</typeparam>
      <param name="methodDef">The <paramref name="methodDef" /> instance which will contain the local variable.</param>
      <returns>A <see cref="T:Mono.Cecil.Cil.VariableDefinition" /> that represents the local variable itself.</returns>
    </member>
    <member name="M:LinFu.Reflection.Emit.MethodDefinitionExtensions.AddLocal``1(Mono.Cecil.MethodDefinition,System.String)">
      <summary>
            Adds a named <see cref="T:Mono.Cecil.Cil.VariableDefinition">local variable</see>
            instance to the target <paramref name="methodDef">method definition</paramref>.
            </summary>
      <typeparam name="T">The object <see cref="T:System.Type">type</see> that describes the type of objects that will be stored by the local variable.</typeparam>
      <param name="methodDef">The <paramref name="methodDef" /> instance which will contain the local variable.</param>
      <param name="variableName">The name of the local variable.</param>
      <returns>A <see cref="T:Mono.Cecil.Cil.VariableDefinition" /> that represents the local variable itself.</returns>
    </member>
    <member name="T:LinFu.Reflection.Emit.ModuleDefinitionExtensions">
      <summary>
            A class that provides helper extension methods
            for the <see cref="T:Mono.Cecil.ModuleDefinition" /> class.
            </summary>
    </member>
    <member name="M:LinFu.Reflection.Emit.ModuleDefinitionExtensions.DefineClass(Mono.Cecil.ModuleDefinition,System.String,System.String,Mono.Cecil.TypeAttributes,Mono.Cecil.TypeReference)">
      <summary>
            Defines a new class and adds it to the <paramref name="mainModule" /> module.
            </summary>
      <param name="mainModule">The module which will hold the new created type.</param>
      <param name="typeName">The name of the class to create.</param>
      <param name="namespaceName">The namespace that will contain the new class.</param>
      <param name="attributes">The <see cref="T:Mono.Cecil.TypeAttributes" /> for the given type.</param>
      <param name="baseType">The base class of the new type.</param>
      <returns>A <see cref="T:Mono.Cecil.TypeDefinition" /> representing the new class being created.</returns>
    </member>
    <member name="M:LinFu.Reflection.Emit.ModuleDefinitionExtensions.ImportConstructor``1(Mono.Cecil.ModuleDefinition,System.Type[])">
      <summary>
            Imports a constructor with the given <paramref name="constructorParameters" />
            into the target <paramref name="module" />.
            </summary>
      <typeparam name="T">The type that holds the target constructor</typeparam>
      <param name="module">The <see cref="T:Mono.Cecil.ModuleDefinition" /> that will import the target constructor.</param>
      <param name="constructorParameters">The list of <see cref="T:System.Type" /> objects that describe the signature of the constructor.</param>
      <returns>A <see cref="T:Mono.Cecil.MethodReference" /> that represents the constructor itself.</returns>
    </member>
    <member name="M:LinFu.Reflection.Emit.ModuleDefinitionExtensions.ImportMethod(Mono.Cecil.ModuleDefinition,System.String,System.Type)">
      <summary>
            Imports a method with a particular <paramref name="methodName" /> from the <paramref name="declaringType" />
            into the <paramref name="module">target module</paramref>.
            </summary>
      <param name="module">The <see cref="T:Mono.Cecil.ModuleDefinition" /> instance that will import the actual method.</param>
      <param name="methodName">The name of the method being imported.</param>
      <param name="declaringType">The <see cref="T:System.Type" /> instance that holds the target method.</param>
      <returns>A <see cref="T:Mono.Cecil.MethodReference" /> that represents the method being imported.</returns>
    </member>
    <member name="M:LinFu.Reflection.Emit.ModuleDefinitionExtensions.ImportMethod(Mono.Cecil.ModuleDefinition,System.String,System.Type,System.Reflection.BindingFlags)">
      <summary>
            Imports a method with a particular <paramref name="methodName" /> and <see cref="T:System.Reflection.BindingFlags" /> from the <paramref name="declaringType" />
            into the <paramref name="module">target module</paramref>.
            </summary>
      <param name="module">The <see cref="T:Mono.Cecil.ModuleDefinition" /> instance that will import the actual method.</param>
      <param name="methodName">The name of the method being imported.</param>
      <param name="declaringType">The <see cref="T:System.Type" /> instance that holds the target method.</param>
      <param name="flags">The <see cref="T:System.Reflection.BindingFlags" /> that describes the visibility and behavior of the target method.</param>
      <returns>A <see cref="T:Mono.Cecil.MethodReference" /> that represents the method being imported.</returns>
    </member>
    <member name="M:LinFu.Reflection.Emit.ModuleDefinitionExtensions.ImportMethod``1(Mono.Cecil.ModuleDefinition,System.String)">
      <summary>
            Imports a method with a particular <paramref name="methodName" /> and <see cref="T:System.Reflection.BindingFlags" /> from the <paramref name="declaringType" />
            into the <paramref name="module">target module</paramref>.
            </summary>
      <typeparam name="T">The target type that holds the target method.</typeparam>
      <param name="module">The <see cref="T:Mono.Cecil.ModuleDefinition" /> instance that will import the actual method.</param>
      <param name="methodName">The name of the method being imported.</param>
      <returns>A <see cref="T:Mono.Cecil.MethodReference" /> that represents the method being imported.</returns>
    </member>
    <member name="M:LinFu.Reflection.Emit.ModuleDefinitionExtensions.ImportMethod``1(Mono.Cecil.ModuleDefinition,System.String,System.Type[])">
      <summary>
            Imports a method with a particular <paramref name="methodName" />, <paramref name="parameterTypes" />, and <see cref="T:System.Reflection.BindingFlags" /> from the <paramref name="declaringType" />
            into the <paramref name="module">target module</paramref>.
            </summary>
      <typeparam name="T">The target type that holds the target method.</typeparam>
      <param name="parameterTypes">The list of <see cref="T:System.Type" /> objects that describe the method signature.</param>
      <param name="module">The <see cref="T:Mono.Cecil.ModuleDefinition" /> instance that will import the actual method.</param>
      <param name="methodName">The name of the method being imported.</param>
      <returns>A <see cref="T:Mono.Cecil.MethodReference" /> that represents the method being imported.</returns>
    </member>
    <member name="M:LinFu.Reflection.Emit.ModuleDefinitionExtensions.ImportMethod``1(Mono.Cecil.ModuleDefinition,System.String,System.Reflection.BindingFlags)">
      <summary>
            Imports a method with a particular <paramref name="methodName" /> and <see cref="T:System.Reflection.BindingFlags" /> from the <paramref name="declaringType" />
            into the <paramref name="module">target module</paramref>.
            </summary>
      <typeparam name="T">The target type that holds the target method itself.</typeparam>
      <param name="module">The <see cref="T:Mono.Cecil.ModuleDefinition" /> instance that will import the actual method.</param>
      <param name="methodName">The name of the method being imported.</param>
      <param name="flags">The <see cref="T:System.Reflection.BindingFlags" /> that describes the visibility and behavior of the target method.</param>
      <returns>A <see cref="T:Mono.Cecil.MethodReference" /> that represents the method being imported.</returns>
    </member>
    <member name="M:LinFu.Reflection.Emit.ModuleDefinitionExtensions.ImportType``1(Mono.Cecil.ModuleDefinition)">
      <summary>
            Imports a target of type <typeparamref name="T" /> into the
            <paramref name="module" /> instance.
            </summary>
      <typeparam name="T">The type that will be imported into the <see cref="T:Mono.Cecil.ModuleDefinition" /> instance itself.</typeparam>
      <param name="module">The module that will store the imported type.</param>
      <returns>A <see cref="T:Mono.Cecil.TypeReference" /> instance that represents the imported type.</returns>
    </member>
    <member name="M:LinFu.Reflection.Emit.ModuleDefinitionExtensions.ImportType(Mono.Cecil.ModuleDefinition,System.Type)">
      <summary>
            Imports a <paramref name="targetType">target type</paramref> into the
            <paramref name="module" /> instance.
            </summary>
      <param name="targetType">The type that will be imported into the <see cref="T:Mono.Cecil.ModuleDefinition" /> instance itself.</param>
      <param name="module">The module that will store the imported type.</param>
      <returns>A <see cref="T:Mono.Cecil.TypeDefinition" /> instance that represents the imported type.</returns>
    </member>
    <member name="M:LinFu.Reflection.Emit.ModuleDefinitionExtensions.GetType(Mono.Cecil.ModuleDefinition,System.String)">
      <summary>
            Returns a <see cref="T:Mono.Cecil.TypeDefinition" /> that matches the given <paramref name="typeName" />.
            </summary>
      <param name="module">The target module to search.</param>
      <param name="typeName">The name of the target type.</param>
      <returns>A type that matches the given type name. If the type cannot be found, then this method will return <c>null</c>.</returns>
    </member>
    <member name="T:LinFu.Reflection.Emit.ParameterDefinitionExtensions">
      <summary>
            A class that extends the <see cref="T:Mono.Cecil.ParameterDefinition" /> class
            to emulate features found in the System.Reflection.Emit namespace.
            </summary>
    </member>
    <member name="M:LinFu.Reflection.Emit.ParameterDefinitionExtensions.IsByRef(Mono.Cecil.ParameterDefinition)">
      <summary>
            Determines whether or not a parameter is passed by reference.
            </summary>
      <param name="parameter">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:LinFu.Reflection.Emit.TypeDefinitionExtensions">
      <summary>
            A class that extends the <see cref="T:Mono.Cecil.TypeDefinition" />
            class with features similar to the features in the
            System.Reflection.Emit namespace.
            </summary>
    </member>
    <member name="M:LinFu.Reflection.Emit.TypeDefinitionExtensions.DefineMethod(Mono.Cecil.TypeDefinition,System.String,Mono.Cecil.MethodAttributes,Mono.Cecil.MethodCallingConvention,System.Type,System.Type[])">
      <summary>
            Adds a new method to the <paramref name="typeDef">target type</paramref>.
            </summary>
      <param name="typeDef">The type that will hold the newly-created method.</param>
      <param name="attributes">The <see cref="T:Mono.Cecil.MethodAttributes" /> parameter that describes the characteristics of the method.</param>
      <param name="methodName">The name to be given to the new method.</param>
      <param name="returnType">The method return type.</param>
      <param name="callingConvention">The calling convention of the method being created.</param>
      <param name="parameterTypes">The list of argument types that will be used to define the method signature.</param>
      <returns>A <see cref="T:Mono.Cecil.MethodDefinition" /> instance that represents the newly-created method.</returns>
    </member>
    <member name="M:LinFu.Reflection.Emit.TypeDefinitionExtensions.DefineMethod(Mono.Cecil.TypeDefinition,System.String,Mono.Cecil.MethodAttributes,System.Type,System.Type[],System.Type[])">
      <summary>
            Adds a new method to the <paramref name="typeDef">target type</paramref>.
            </summary>
      <param name="typeDef">The type that will hold the newly-created method.</param>
      <param name="attributes">The <see cref="T:Mono.Cecil.MethodAttributes" /> parameter that describes the characteristics of the method.</param>
      <param name="methodName">The name to be given to the new method.</param>
      <param name="returnType">The method return type.</param>
      <param name="parameterTypes">The list of argument types that will be used to define the method signature.</param>
      <param name="genericParameterTypes">The list of generic argument types that will be used to define the method signature.</param>
      <returns>A <see cref="T:Mono.Cecil.MethodDefinition" /> instance that represents the newly-created method.</returns>
    </member>
    <member name="M:LinFu.Reflection.Emit.TypeDefinitionExtensions.AddDefaultConstructor(Mono.Cecil.TypeDefinition)">
      <summary>
            Adds a default constructor to the target type.
            </summary>
      <param name="targetType">The type that will contain the default constructor.</param>
      <returns>The default constructor.</returns>
    </member>
    <member name="M:LinFu.Reflection.Emit.TypeDefinitionExtensions.AddDefaultConstructor(Mono.Cecil.TypeDefinition,System.Type)">
      <summary>
            Adds a default constructor to the target type.
            </summary>
      <param name="parentType">The base class that contains the default constructor that will be used for constructor chaining..</param>
      <param name="targetType">The type that will contain the default constructor.</param>
      <returns>The default constructor.</returns>
    </member>
    <member name="M:LinFu.Reflection.Emit.TypeDefinitionExtensions.AddProperty(Mono.Cecil.TypeDefinition,System.String,System.Type)">
      <summary>
            Adds a rewritable property to the <paramref name="typeDef">target type</paramref>.
            </summary>
      <param name="typeDef">The target type that will hold the newly-created property.</param>
      <param name="propertyName">The name of the property itself.</param>
      <param name="propertyType">The <see cref="T:System.Type" /> instance that describes the property type.</param>
    </member>
    <member name="M:LinFu.Reflection.Emit.TypeDefinitionExtensions.AddProperty(Mono.Cecil.TypeDefinition,System.String,Mono.Cecil.TypeReference)">
      <summary>
            Adds a rewritable property to the <paramref name="typeDef">target type</paramref>.
            </summary>
      <param name="typeDef">The target type that will hold the newly-created property.</param>
      <param name="propertyName">The name of the property itself.</param>
      <param name="propertyType">The <see cref="T:Mono.Cecil.TypeReference" /> instance that describes the property type.</param>
    </member>
    <member name="M:LinFu.Reflection.Emit.TypeDefinitionExtensions.AddProperty(Mono.Cecil.TypeDefinition,System.String,Mono.Cecil.TypeReference,Mono.Cecil.MethodDefinition,Mono.Cecil.MethodDefinition)">
      <summary>
            Adds a rewriteable property to the <paramref name="typeDef">target type</paramref>
            using an existing <paramref name="getter" /> and <paramref name="setter" />.
            </summary>
      <param name="typeDef">The target type that will hold the newly-created property.</param>
      <param name="propertyName">The name of the property itself.</param>
      <param name="propertyType">The <see cref="T:Mono.Cecil.TypeReference" /> instance that describes the property type.</param>
      <param name="getter">The property getter method.</param>
      <param name="setter">The property setter method.</param>
    </member>
    <member name="M:LinFu.Reflection.Emit.TypeDefinitionExtensions.GetMethod(Mono.Cecil.TypeDefinition,System.String)">
      <summary>
            Retrieves the method that matches the given <paramref name="methodName" />.
            </summary>
      <param name="typeDef">The target type to search.</param>
      <param name="methodName">The name of the target method.</param>
      <returns>A method that matches the given <paramref name="methodName" />. If the method is not found, then it will return a <c>null</c> value. </returns>
    </member>
    <member name="M:LinFu.Reflection.Emit.TypeDefinitionExtensions.GetBackingField(System.String,Mono.Cecil.TypeDefinition,Mono.Cecil.TypeReference)">
      <summary>
            Resolves the backing field for a generic type declaration.
            </summary>
      <param name="fieldName">The name of the field to reference.</param>
      <param name="typeDef">The type that holds the actual field.</param>
      <param name="propertyType">The <see cref="T:Mono.Cecil.TypeReference" /> that describes the property type being referenced.</param>
      <returns>A <see cref="T:Mono.Cecil.FieldReference" /> that points to the actual backing field.</returns>
    </member>
    <member name="M:LinFu.Reflection.Emit.TypeDefinitionExtensions.AddPropertyGetter(Mono.Cecil.TypeReference,System.String,Mono.Cecil.MethodAttributes,Mono.Cecil.FieldReference)">
      <summary>
            Creates a property getter method implementation with the
            <paramref name="propertyType" /> as the return type.
            </summary>
      <param name="propertyType">Represents the <see cref="T:Mono.Cecil.TypeReference">return type</see> for the getter method.</param>
      <param name="getterName">The getter method name.</param>
      <param name="attributes">The method attributes associated with the getter method.</param>
      <param name="backingField">The field that will store the instance that the getter method will retrieve.</param>
      <returns>A <see cref="T:Mono.Cecil.MethodDefinition" /> representing the getter method itself.</returns>
    </member>
    <member name="M:LinFu.Reflection.Emit.TypeDefinitionExtensions.AddPropertySetter(Mono.Cecil.TypeReference,Mono.Cecil.MethodAttributes,Mono.Cecil.FieldReference,System.String,Mono.Cecil.TypeReference)">
      <summary>
            Creates a property setter method implementation with the
            <paramref name="propertyType" /> as the setter parameter.
            </summary>
      <param name="propertyType">Represents the <see cref="T:Mono.Cecil.TypeReference">parameter type</see> for the setter method.</param>
      <param name="attributes">The method attributes associated with the setter method.</param>
      <param name="backingField">The field that will store the instance for the setter method.</param>
      <param name="setterName">The method name of the setter method.</param>
      <param name="voidType">The <see cref="T:Mono.Cecil.TypeReference" /> that represents <see cref="T:System.Void" />.</param>
      <returns>A <see cref="T:Mono.Cecil.MethodDefinition" /> that represents the setter method itself.</returns>
    </member>
  </members>
</doc>