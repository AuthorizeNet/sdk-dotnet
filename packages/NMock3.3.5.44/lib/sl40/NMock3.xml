<?xml version="1.0"?>
<doc>
  <assembly>
    <name>NMock3</name>
  </assembly>
  <members>
    <member name="T:NMock.Signal">
      <summary>
            Defines that an <see cref="M:NMock.Signal.EventWaitHandle(System.Threading.EventWaitHandle)" /> should be signaled.
            </summary>
    </member>
    <member name="M:NMock.Signal.EventWaitHandle(System.Threading.EventWaitHandle)">
      <summary>
            Signals an <see cref="M:NMock.Signal.EventWaitHandle(System.Threading.EventWaitHandle)" /> to synchronizes threads.
            </summary>
      <param name="signal">The signal to set.</param>
      <returns>Action that signals an <see cref="M:NMock.Signal.EventWaitHandle(System.Threading.EventWaitHandle)" />.</returns>
    </member>
    <member name="T:NMock.ISelfDescribing">
      <summary>
            This interface is used to get a description of the implementator.
            </summary>
    </member>
    <member name="M:NMock.ISelfDescribing.DescribeTo(System.IO.TextWriter)">
      <summary>
            Describes this object.
            </summary>
      <param name="writer">The text writer the description is added to.</param>
    </member>
    <member name="T:NMock.Monitoring.Invocation">
      <summary>
            Represents the invocation of a method on an object (receiver).
            </summary>
    </member>
    <member name="F:NMock.Monitoring.Invocation.exception">
      <summary>
            Holds the exception to be thrown. When this field has been set, <see cref="P:NMock.Monitoring.Invocation.IsThrowing" /> will become true.
            </summary>
    </member>
    <member name="F:NMock.Monitoring.Invocation.result">
      <summary>
            Holds the result of the invocation.
            </summary>
    </member>
    <member name="M:NMock.Monitoring.Invocation.#ctor(System.Object,System.Reflection.MethodBase,System.Object[])">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Monitoring.Invocation" /> class.
            </summary>
      <param name="receiver">The receiver providing the method.</param>
      <param name="method">The method.</param>
      <param name="arguments">The parameters passed to the method..</param>
    </member>
    <member name="M:NMock.Monitoring.Invocation.InvokeOn(System.Object)">
      <summary>
            Invokes this invocation on the specified receiver and stores the result and exception
            returns/thrown by the invocation.
            </summary>
      <param name="receiver">The receiver.</param>
    </member>
    <member name="M:NMock.Monitoring.Invocation.ValidateReturnType(System.Object)">
      <summary>
            Checks the returnType of the initialized method if it is valid to be mocked.
            </summary>
      <param name="value">The return value to be checked.</param>
    </member>
    <member name="M:NMock.Monitoring.Invocation.IsProperty">
      <summary>
            Determines whether the initialized method is a property.
            </summary>
      <returns>
            Returns true if initialized method is a property; false otherwise.
            </returns>
    </member>
    <member name="M:NMock.Monitoring.Invocation.IsIndexerGetter">
      <summary>
            Determines whether the initialized method is an index getter.
            </summary>
      <returns>
            Returns true if initialized method is an index getter; false otherwise.
            </returns>
    </member>
    <member name="M:NMock.Monitoring.Invocation.IsIndexerSetter">
      <summary>
            Determines whether the initialized method is an index setter.
            </summary>
      <returns>
            Returns true if initialized method is an index setter; false otherwise.
            </returns>
    </member>
    <member name="M:NMock.Monitoring.Invocation.DescribeAsProperty(System.IO.TextWriter)">
      <summary>
            Describes the property with parameters to the specified <paramref name="writer" />.
            </summary>
      <param name="writer">The writer where the description is written to.</param>
    </member>
    <member name="M:NMock.Monitoring.Invocation.DescribeAsIndexerGetter(System.IO.TextWriter)">
      <summary>
            Describes the index setter with parameters to the specified <paramref name="writer" />.
            </summary>
      <param name="writer">The writer where the description is written to.</param>
    </member>
    <member name="M:NMock.Monitoring.Invocation.DescribeAsIndexerSetter(System.IO.TextWriter)">
      <summary>
            Describes the index setter with parameters to the specified <paramref name="writer" />.
            </summary>
      <param name="writer">The writer where the description is written to.</param>
    </member>
    <member name="M:NMock.Monitoring.Invocation.DescribeNormalMethod(System.IO.TextWriter)">
      <summary>
            Describes the method with parameters to the specified <paramref name="writer" />.
            </summary>
      <param name="writer">The writer where the description is written to.</param>
    </member>
    <member name="M:NMock.Monitoring.Invocation.WriteTypeParams(System.IO.TextWriter)">
      <summary>
            Writes the generic parameters of the method to the specified <paramref name="writer" />.
            </summary>
      <param name="writer">The writer where the description is written to.</param>
    </member>
    <member name="M:NMock.Monitoring.Invocation.WriteParameterList(System.IO.TextWriter,System.Int32)">
      <summary>
            Writes the parameter list to the specified <paramref name="writer" />.
            </summary>
      <param name="writer">The writer where the description is written to.</param>
      <param name="count">The count of parameters to describe.</param>
    </member>
    <member name="M:NMock.Monitoring.Invocation.DescribeAsEventAdder(System.IO.TextWriter)">
      <summary>
            Describes the event adder to the specified <paramref name="writer" />.
            </summary>
      <param name="writer">The writer where the description is written to.</param>
    </member>
    <member name="M:NMock.Monitoring.Invocation.DescribeAsEventRemover(System.IO.TextWriter)">
      <summary>
            Describes the event remover to the specified <paramref name="writer" />.
            </summary>
      <param name="writer">The writer where the description is written to.</param>
    </member>
    <member name="P:NMock.Monitoring.Invocation.Receiver">
      <summary>
            Holds the receiver providing the method.
            </summary>
    </member>
    <member name="P:NMock.Monitoring.Invocation.MockObject">
      <summary>
            Returns the Receiver as an <see cref="T:NMock.IMockObject" /></summary>
    </member>
    <member name="P:NMock.Monitoring.Invocation.MethodBase">
      <summary>
            Gets the <see cref="P:NMock.Monitoring.Invocation.MethodBase" /> that was passed into the constructor of this <see cref="T:NMock.Monitoring.Invocation" /></summary>
    </member>
    <member name="P:NMock.Monitoring.Invocation.Method">
      <summary>
            Holds the method that is being invoked.
            </summary>
    </member>
    <member name="P:NMock.Monitoring.Invocation.MethodName">
      <summary>
            Gets the name of method or property specified by the <see cref="T:NMock.Monitoring.Invocation" /></summary>
    </member>
    <member name="P:NMock.Monitoring.Invocation.MethodSignature">
      <summary>
            Gets a string that represents the signature of the <see cref="P:NMock.Monitoring.Invocation.Method" /></summary>
    </member>
    <member name="P:NMock.Monitoring.Invocation.MethodSignatureForSetter">
      <summary>
            Gets a string that represents the signature of the property setter
            </summary>
    </member>
    <member name="P:NMock.Monitoring.Invocation.MethodReturnType">
      <summary>
            Gets the return type of the method specified by the <see cref="T:NMock.Monitoring.Invocation" /></summary>
    </member>
    <member name="P:NMock.Monitoring.Invocation.MethodParameters">
      <summary>
            Gets the parameters of the method specified by the <see cref="T:NMock.Monitoring.Invocation" /></summary>
    </member>
    <member name="P:NMock.Monitoring.Invocation.Arguments">
      <summary>
            Gets the arguments passed into the constructor of this <see cref="T:NMock.Monitoring.Invocation" /></summary>
    </member>
    <member name="P:NMock.Monitoring.Invocation.Parameters">
      <summary>
            Holds the parameterlist of the invocation.
            </summary>
    </member>
    <member name="P:NMock.Monitoring.Invocation.Result">
      <summary>
            Gets or sets the result of the invocation.
            </summary>
      <value>The result.</value>
    </member>
    <member name="P:NMock.Monitoring.Invocation.SetterResult">
      <summary>
            Stores the value being assigned in a setter.
            </summary>
      <remarks>
            Used internally to store a setter value to return in an automatic getter.
            </remarks>
    </member>
    <member name="P:NMock.Monitoring.Invocation.Exception">
      <summary>
            Gets or sets the exception that is thrown on the invocation.
            </summary>
      <value>The exception.</value>
    </member>
    <member name="P:NMock.Monitoring.Invocation.IsThrowing">
      <summary>
            Gets a value indicating whether an exception is thrown an this invocation.
            </summary>
      <value>
        <c>true</c> if this invocation is throwing an exception; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:NMock.Monitoring.Invocation.IsEventAdder">
      <summary>
            Determines whether the initialized method is an event adder.
            </summary>
      <returns>
            Returns true if initialized method is an event adder; false otherwise.
            </returns>
    </member>
    <member name="P:NMock.Monitoring.Invocation.IsEventRemover">
      <summary>
            Determines whether the initialized method is an event remover.
            </summary>
      <returns>
            Returns true if initialized method is an event remover; false otherwise.
            </returns>
    </member>
    <member name="P:NMock.Monitoring.Invocation.IsEventAccessor">
      <summary>
            Gets a value indicating if this <see cref="T:NMock.Monitoring.Invocation" /> is an event
            </summary>
    </member>
    <member name="P:NMock.Monitoring.Invocation.IsPropertyAccessor">
      <summary>
            Gets a value indicating if this <see cref="T:NMock.Monitoring.Invocation" /> is a property
            </summary>
    </member>
    <member name="P:NMock.Monitoring.Invocation.IsPropertySetAccessor">
      <summary>
            Gets a value indicating if this <see cref="T:NMock.Monitoring.Invocation" /> is a property setter
            </summary>
    </member>
    <member name="P:NMock.Monitoring.Invocation.IsPropertyGetAccessor">
      <summary>
            Gets a value indicating if this <see cref="T:NMock.Monitoring.Invocation" /> is a property getter
            </summary>
    </member>
    <member name="P:NMock.Monitoring.Invocation.IsMethod">
      <summary>
            Gets a value indicating if this <see cref="T:NMock.Monitoring.Invocation" /> is a method.
            </summary>
    </member>
    <member name="T:NMock.Matcher">
      <summary>
            A matcher is used to match objects against it.
            </summary>
    </member>
    <member name="M:NMock.Matcher.#ctor">
      <summary>
            Initializes an instance of the <see cref="T:NMock.Matcher" /> class with an empty <see cref="P:NMock.Matcher.Description" /></summary>
    </member>
    <member name="M:NMock.Matcher.#ctor(System.String)">
      <summary>
            Initialized an instance of the <see cref="T:NMock.Matcher" /> class with the description argument.
            </summary>
      <param name="description">The value used when calling the <see cref="M:NMock.Matcher.DescribeTo(System.IO.TextWriter)" /> method.</param>
    </member>
    <member name="M:NMock.Matcher.DescribeTo(System.IO.TextWriter)">
      <summary>
            Describes this matcher.
            </summary>
      <param name="writer">The text writer the description is added to.</param>
    </member>
    <member name="M:NMock.Matcher.op_BitwiseAnd(NMock.Matcher,NMock.Matcher)">
      <summary>
            Logical and of to matchers.
            </summary>
      <param name="m1">First matcher.</param>
      <param name="m2">Second matcher.</param>
      <returns>Matcher combining the two operands.</returns>
    </member>
    <member name="M:NMock.Matcher.op_BitwiseOr(NMock.Matcher,NMock.Matcher)">
      <summary>
            Logical or of to matchers.
            </summary>
      <param name="m1">First matcher.</param>
      <param name="m2">Second matcher.</param>
      <returns>Matcher combining the two operands.</returns>
    </member>
    <member name="M:NMock.Matcher.op_LogicalNot(NMock.Matcher)">
      <summary>
            Negation of a matcher.
            </summary>
      <param name="m">Matcher to negate.</param>
      <returns>Negation of the specified matcher.</returns>
    </member>
    <member name="M:NMock.Matcher.Matches(System.Object)">
      <summary>
            Matches the specified object to this matcher and returns whether it matches.
            </summary>
      <param name="o">The object to match.</param>
      <returns>Whether the object matches.</returns>
    </member>
    <member name="M:NMock.Matcher.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </summary>
      <returns>
            A <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </returns>
    </member>
    <member name="P:NMock.Matcher.Description">
      <summary>
            A default description used when calling <see cref="M:NMock.Matcher.DescribeTo(System.IO.TextWriter)" /></summary>
    </member>
    <member name="T:NMock.Matchers.NotMatcher">
      <summary>
            Matcher that negates another matcher.
            </summary>
    </member>
    <member name="F:NMock.Matchers.NotMatcher.negated">
      <summary>
            Holds the matcher to negate.
            </summary>
    </member>
    <member name="M:NMock.Matchers.NotMatcher.#ctor(NMock.Matcher)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Matchers.NotMatcher" /> class.
            </summary>
      <param name="negated">The matcher to negate.</param>
    </member>
    <member name="M:NMock.Matchers.NotMatcher.Matches(System.Object)">
      <summary>
            Matches the specified object to this matcher and returns whether it matches.
            </summary>
      <param name="o">The object to match.</param>
      <returns>Whether the object does not matche the wrapped matcher.</returns>
    </member>
    <member name="M:NMock.Matchers.NotMatcher.DescribeTo(System.IO.TextWriter)">
      <summary>
            Describes this matcher.
            </summary>
      <param name="writer">The text writer to which the description is added.</param>
    </member>
    <member name="T:NMock.IMockDefinition">
      <summary>
            The definition of a mock object.
            </summary>
      <remarks>
            Implementations of this interface encapsulate the details of
            how a mock object is defined, and provide the ability to be able to
            instantiate an instance of it.
            </remarks>
    </member>
    <member name="M:NMock.IMockDefinition.Create(System.Type,NMock.MockFactory,NMock.Proxy.IMockObjectFactory)">
      <summary>
            This method supports NMock infrastructure and is not intended to be called directly from your code.
            </summary>
      <param name="primaryType">The primary type that is being mocked.</param>
      <param name="mockFactory">The current <see cref="T:NMock.MockFactory" /> instance.</param>
      <param name="mockObjectFactory">An <see cref="T:NMock.Proxy.IMockObjectFactory" /> to use when creating the mock.</param>
      <returns>A new mock instance.</returns>
    </member>
    <member name="T:NMock.Syntax.IMockDefinitionSyntax">
      <summary>
            Syntax describing the initial characteristics of a new mock object.
            </summary>
    </member>
    <member name="M:NMock.Syntax.IMockDefinitionSyntax.Implementing``1">
      <summary>
            Specifies a type that this mock should implement. This may be a class or interface,
            but there can only be a maximum of one class implemented by a mock.
            </summary>
      <typeparam name="T">The type to implement.</typeparam>
      <returns>The mock object definition.</returns>
    </member>
    <member name="M:NMock.Syntax.IMockDefinitionSyntax.Implementing(System.Type[])">
      <summary>
            Specifies the types that this mock should implement. These may be a class or interface,
            but there can only be a maximum of one class implemented by a mock.
            </summary>
      <param name="additionalTypesToMock">The types to implement.</param>
      <returns>The mock object definition.</returns>
    </member>
    <member name="M:NMock.Syntax.IMockDefinitionSyntax.OfStyle(NMock.MockStyle)">
      <summary>
            Specifies how the mock object should behave when first created.
            It is invalid to set the MockStyle of a mock more than once.
            </summary>
      <param name="style">A MockStyle value.</param>
      <returns>The mock object definition.</returns>
    </member>
    <member name="M:NMock.Syntax.IMockDefinitionSyntax.WithArgs(System.Object[])">
      <summary>
            Specifies the arguments for the constructor of the class to be mocked.
            Only applicable when mocking a class with a non-default constructor.
            It is invalid to specify the constructor arguments of a mock more than once.
            </summary>
      <param name="args">The arguments for the class constructor.</param>
      <returns>The mock object definition.</returns>
    </member>
    <member name="M:NMock.Syntax.IMockDefinitionSyntax.Named(System.String)">
      <summary>
            Specifies a name for the mock. This will be used in error messages,
            and as the return value of ToString() if not mocking a class.
            It is invalid to specify the name of a mock more than once.
            </summary>
      <param name="name">The name for the mock.</param>
      <returns>The mock object definition.</returns>
    </member>
    <member name="T:NMock.Internal.MockBuilder">
      <summary>
            Allows a mock object to be incrementally defined, and then finally created.
            </summary>
    </member>
    <member name="F:NMock.Internal.MockBuilder.EmptyArgsArray">
      <summary>
            A single empty array instance that is used as a default value
            for constructor arguments.
            </summary>
    </member>
    <member name="F:NMock.Internal.MockBuilder._types">
      <summary>
            The types that the mock object needs to implement.
            </summary>
    </member>
    <member name="F:NMock.Internal.MockBuilder._constructorArgs">
      <summary>
            Constructor arguments for any class type that this mock might subclass.
            If not subclassing, or if using a default constructor, then this should
            be an empty array.
            </summary>
    </member>
    <member name="F:NMock.Internal.MockBuilder._mockStyle">
      <summary>
            The MockStyle for the mock. If not specified, this will ultimately be
            assumed to be MockStyle.Default.
            </summary>
    </member>
    <member name="F:NMock.Internal.MockBuilder._name">
      <summary>
            The name of the mock object. Null is a valid value.
            </summary>
    </member>
    <member name="M:NMock.Internal.MockBuilder.Implementing``1">
      <summary>
            Specifies a type that this mock should implement. This may be a class or interface,
            but there can only be a maximum of one class implemented by a mock.
            </summary>
      <typeparam name="T">The type to implement.</typeparam>
      <returns>The mock object definition.</returns>
    </member>
    <member name="M:NMock.Internal.MockBuilder.Implementing(System.Type[])">
      <summary>
            Specifies the types that this mock should implement. These may be a class or interface,
            but there can only be a maximum of one class implemented by a mock.
            </summary>
      <param name="additionalTypesToMock">The types to implement.</param>
      <returns>The mock object definition.</returns>
    </member>
    <member name="M:NMock.Internal.MockBuilder.OfStyle(NMock.MockStyle)">
      <summary>
            Specifies how the mock object should behave when first created.
            It is invalid to set the MockStyle of a mock more than once.
            </summary>
      <param name="mockStyle">A MockStyle value.</param>
      <returns>The mock object definition.</returns>
    </member>
    <member name="M:NMock.Internal.MockBuilder.WithArgs(System.Object[])">
      <summary>
            Specifies the arguments for the constructor of the class to be mocked.
            Only applicable when mocking a class with a non-default constructor.
            It is invalid to specify the constructor arguments of a mock more than once.
            </summary>
      <param name="args">The arguments for the class constructor.</param>
      <returns>The mock object definition.</returns>
    </member>
    <member name="M:NMock.Internal.MockBuilder.Named(System.String)">
      <summary>
            Specifies a name for the mock. This will be used in error messages,
            and as the return value of ToString() if not mocking a class.
            It is invalid to specify the name of a mock more than once.
            </summary>
      <param name="name">The name for the mock.</param>
      <returns>The mock object definition.</returns>
    </member>
    <member name="M:NMock.Internal.MockBuilder.Create(System.Type,NMock.MockFactory,NMock.Proxy.IMockObjectFactory)">
      <summary>
            This method supports NMock infrastructure and is not intended to be called directly from your code.
            </summary>
      <param name="primaryType">The primary type that is being mocked.</param>
      <param name="mockFactory">The current <see cref="T:NMock.MockFactory" /> instance.</param>
      <param name="mockObjectFactory">An <see cref="T:NMock.Proxy.IMockObjectFactory" /> to use when creating the mock.</param>
      <returns>A new mock instance.</returns>
    </member>
    <member name="M:NMock.Internal.MockBuilder.CheckInterfacesDoNotContainToStringMethodDeclaration(NMock.Proxy.CompositeType)">
      <summary>
            Checks that interfaces do not contain ToString method declarations.
            </summary>
      <param name="mockedTypes">The types that are to be mocked.</param>
    </member>
    <member name="T:NMock.Syntax.IValueSyntax">
      <summary>
            Syntax defining a value.
            </summary>
    </member>
    <member name="M:NMock.Syntax.IValueSyntax.To(NMock.Matcher)">
      <summary>
            Defines a value.
            </summary>
      <param name="valueMatcher">The value matcher.</param>
      <returns>Match syntax defining the behavior of the value.</returns>
    </member>
    <member name="T:NMock.Syntax.ICommentSyntax">
      <summary>
            Syntax for adding an explanation for the expectation.
            </summary>
    </member>
    <member name="M:NMock.Syntax.ICommentSyntax.Comment(System.String)">
      <summary>
            Adds a comment for the expectation that is added to the error message if the expectation is not met.
            </summary>
      <param name="comment">The comment that is shown in the error message if this expectation is not met.
            You can describe here why this expectation has to be met.</param>
    </member>
    <member name="T:NMock.EventInvokerBase">
      <summary>
            Base class for Invoker classes that raise events.
            </summary>
    </member>
    <member name="M:NMock.EventInvokerBase.MockEventHookup.#ctor(NMock.EventInvokerBase,System.Boolean)">
      <summary>
            Constructor
            </summary>
      <param name="invoker">
      </param>
      <param name="isDelegate">
      </param>
    </member>
    <member name="F:NMock.EventInvokerBase.Handler">
      <summary>
            Holds a reference to the delegate that will be invoked.
            </summary>
    </member>
    <member name="M:NMock.EventInvokerBase.Comment(System.String)">
      <summary>
            Adds a comment for the expectation that is added to the error message if the expectation is not met.
            </summary>
      <param name="comment">The comment that is shown in the error message if this expectation is not met.
            You can describe here why this expectation has to be met.</param>
    </member>
    <member name="M:NMock.EventInvokerBase.Hookup(System.Boolean)">
      <summary>
            Hooks up with the action that will be taken once a handler is added to the event.
            </summary>
      <returns>The action to hook the incoming handler to the event.</returns>
    </member>
    <member name="M:NMock.EventInvokerBase.RaiseEvent(System.Object[])">
      <summary>
            Raises the event that created the expectations.
            </summary>
      <param name="args">Arguments for the event.</param>
    </member>
    <member name="T:NMock.IAction">
      <summary>
            An action defines something that has to be done.
            For example the action to return a result value.
            </summary>
    </member>
    <member name="M:NMock.IAction.Invoke(NMock.Monitoring.Invocation)">
      <summary>
            Invokes this object.
            </summary>
      <param name="invocation">The invocation.</param>
    </member>
    <member name="T:NMock.EventInvoker`1">
      <summary>
            Can mock invoke any event it is feed with.
            </summary>
      <remarks>
            Code by Magnus Mårtensson
            http://blog.noop.se/archive/2007/08/17.aspx
            </remarks>
    </member>
    <member name="M:NMock.EventInvoker`1.Invoke(`0)">
      <summary>
      </summary>
      <param name="e">
      </param>
    </member>
    <member name="M:NMock.EventInvoker`1.Invoke(System.Object,`0)">
      <summary>
            Invoke the event and send in parameter.
            </summary>
      <param name="sender">The sender of the event.</param>
      <param name="e">The arguments of the call.</param>
    </member>
    <member name="T:NMock.EventInvoker">
      <summary>
            EventInvoker is used to invoke events that definded by the <see cref="T:System.EventHandler" />.
            </summary>
      <remarks>
            An EventInvoker is created as a result of a call to the <see cref="M:NMock.Syntax.IStubSyntax`1.EventBinding(System.Action{`0})" /> method.
            </remarks>
    </member>
    <member name="M:NMock.EventInvoker.Invoke">
      <summary>
            Invokes the referenced event
            </summary>
    </member>
    <member name="T:NMock.Actions.GetArgumentsAction">
      <summary>
            Action that executes the delegate passed to the constructor to get argments of executed method.
            </summary>
    </member>
    <member name="M:NMock.Actions.GetArgumentsAction.#ctor(System.Action{NMock.Monitoring.ParameterList})">
      <summary>
            constustor of GetArgumentsAction
            </summary>
      <param name="handler">delegate used to get argments of executed method</param>
    </member>
    <member name="T:NMock.Actions.CollectAction">
      <summary>
            Action that returns the n-th element of the arguments to an invocation.
            </summary>
    </member>
    <member name="F:NMock.Actions.CollectAction.argumentIndex">
      <summary>
            Stores the index of the argument.
            </summary>
    </member>
    <member name="F:NMock.Actions.CollectAction.collectedArgumentValue">
      <summary>
            Stores the parameter when this action gets invoked.
            </summary>
    </member>
    <member name="M:NMock.Actions.CollectAction.#ctor(System.Int32)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Actions.CollectAction" /> class.
            </summary>
      <param name="argumentIndex">Index of the argument to collect.</param>
    </member>
    <member name="P:NMock.Actions.CollectAction.Parameter">
      <summary>
            Gets the collected parameter.
            </summary>
      <value>The collected parameter (n-th parameter of parameter list of the method's call.</value>
    </member>
    <member name="T:NMock.Matchers.PropertyMatcher">
      <summary>
            Matcher that checks whether the actual object has a property with the specified name 
            and its value matches the specified matcher.
            </summary>
    </member>
    <member name="M:NMock.Matchers.PropertyMatcher.#ctor(System.String,NMock.Matcher)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Matchers.PropertyMatcher" /> class.
            </summary>
      <param name="propertyName">Name of the property.</param>
      <param name="valueMatcher">The value matcher.</param>
    </member>
    <member name="M:NMock.Matchers.PropertyMatcher.Matches(System.Object)">
      <summary>
            Matches the specified object to this matcher and returns whether it matches.
            </summary>
      <param name="o">The object to match.</param>
      <returns>Whether the object has a property with the expected name and expected value.</returns>
    </member>
    <member name="M:NMock.Matchers.PropertyMatcher.DescribeTo(System.IO.TextWriter)">
      <summary>
            Describes this matcher.
            </summary>
      <param name="writer">The text writer to which the description is added.</param>
    </member>
    <member name="T:NMock.Matchers.ElementMatcher">
      <summary>
            Matcher that checks whether a single object is in a collection of elements.
            </summary>
    </member>
    <member name="M:NMock.Matchers.ElementMatcher.#ctor(System.Collections.ICollection)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Matchers.ElementMatcher" /> class.
            </summary>
      <param name="collection">The collection to match against.</param>
    </member>
    <member name="M:NMock.Matchers.ElementMatcher.Matches(System.Object)">
      <summary>
            Matches the specified object to this matcher and returns whether it matches.
            </summary>
      <param name="actual">The object to match.</param>
      <returns>Whether to object matches.</returns>
    </member>
    <member name="M:NMock.Matchers.ElementMatcher.DescribeTo(System.IO.TextWriter)">
      <summary>
            Describes this matcher.
            </summary>
      <param name="writer">The text writer to which the description is added.</param>
    </member>
    <member name="T:NMock.IExpectation">
      <summary>
            Represents an expectation.
            </summary>
    </member>
    <member name="M:NMock.IExpectation.Matches(NMock.Monitoring.Invocation)">
      <summary>
            Checks whether stored expectations matches the specified invocation.
            </summary>
      <param name="invocation">The invocation to check.</param>
      <returns>Returns whether one of the stored expectations has met the specified invocation.</returns>
    </member>
    <member name="M:NMock.IExpectation.MatchesIgnoringIsActive(NMock.Monitoring.Invocation)">
      <summary>
            Matcheses the ignoring is active.
            </summary>
      <param name="invocation">The invocation.</param>
      <returns>
      </returns>
    </member>
    <member name="M:NMock.IExpectation.Perform(NMock.Monitoring.Invocation)">
      <summary>
            Performs the specified invocation.
            </summary>
      <param name="invocation">The invocation.</param>
      <returns>A value indicating if the <paramref name="invocation" /> was successfully performed.</returns>
    </member>
    <member name="M:NMock.IExpectation.DescribeActiveExpectationsTo(System.IO.TextWriter)">
      <summary>
            Describes the active expectations to.
            </summary>
      <param name="writer">The writer.</param>
    </member>
    <member name="M:NMock.IExpectation.DescribeUnmetExpectationsTo(System.IO.TextWriter)">
      <summary>
            Describes the unmet expectations to.
            </summary>
      <param name="writer">The writer.</param>
    </member>
    <member name="M:NMock.IExpectation.QueryExpectationsBelongingTo(NMock.IMockObject,System.Collections.Generic.IList{NMock.IExpectation})">
      <summary>
            Adds all expectations to <paramref name="result" /> that are associated to <paramref name="mock" />.
            </summary>
      <param name="mock">The mock for which expectations are queried.</param>
      <param name="result">The result to add matching expectations to.</param>
    </member>
    <member name="M:NMock.IExpectation.ValidationErrors">
      <summary>
            Returns a list of expectation validation errors
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:NMock.IExpectation.IsActive">
      <summary>
            Gets a value indicating whether this instance is active.
            </summary>
      <value>
        <c>true</c> if this instance is active; otherwise, <c>false</c>.</value>
    </member>
    <member name="P:NMock.IExpectation.HasBeenMet">
      <summary>
            Gets a value indicating whether this instance has been met.
            </summary>
      <value>
        <c>true</c> if this instance has been met; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:NMock.IExpectation.IsValid">
      <summary>
            Gets a value indicating that the expectation is valid.
            </summary>
    </member>
    <member name="P:NMock.IExpectation.Parent">
      <summary>
            Gets or sets the <see cref="T:NMock.IExpectationList" /> that contains this <see cref="T:NMock.IExpectationList" /></summary>
    </member>
    <member name="T:NMock.IExpectationList">
      <summary>
            Represents an ExpectationList
            </summary>
    </member>
    <member name="M:NMock.IExpectationList.AddExpectation(NMock.IExpectation)">
      <summary>
            Adds an expectation.
            </summary>
      <param name="expectation">The expectation to add.</param>
    </member>
    <member name="M:NMock.IExpectationList.RemoveExpectation(NMock.IExpectation)">
      <summary>
            Removes the specified expectation.
            </summary>
      <param name="expectation">The expectation to remove.</param>
    </member>
    <member name="M:NMock.IExpectationList.ContainsOrderedExpectationFor(NMock.Monitoring.Invocation)">
      <summary>
            Determines if the <see cref="T:NMock.Monitoring.Invocation" /> is in an ordered list.
            </summary>
      <param name="invocation">The <see cref="T:NMock.Monitoring.Invocation" /> to look for.</param>
      <returns>
      </returns>
    </member>
    <member name="P:NMock.IExpectationList.Root">
      <summary>
            Gets the root <see cref="T:NMock.IExpectationList" /> for the <see cref="T:NMock.MockFactory" /></summary>
    </member>
    <member name="P:NMock.IExpectationList.Depth">
      <summary>
            The nesting level of this <see cref="T:NMock.IExpectationList" /></summary>
    </member>
    <member name="F:NMock.Internal.ExpectationListBase.depth">
      <summary>
            Stores the calling depth for the document writer output.
            </summary>
    </member>
    <member name="M:NMock.Internal.ExpectationListBase.QueryExpectationsBelongingTo(NMock.IMockObject,System.Collections.Generic.IList{NMock.IExpectation})">
      <summary>
            Adds all expectations to <paramref name="result" /> that are associated to <paramref name="mock" />.
            </summary>
      <param name="mock">The mock for which expectations are queried.</param>
      <param name="result">The result to add matching expectations to.</param>
    </member>
    <member name="P:NMock.Internal.ExpectationListBase.Parent">
      <summary>
            Gets or sets the expectation list that contains this ordering
            </summary>
    </member>
    <member name="P:NMock.Internal.ExpectationListBase.Root">
      <summary>
            Gets the root <see cref="T:NMock.IExpectationList" /> for the <see cref="T:NMock.MockFactory" /></summary>
    </member>
    <member name="P:NMock.Internal.ExpectationListBase.HasBeenMet">
      <summary>
            Gets a value indicating whether this instance has been met.
            </summary>
      <value>
        <c>true</c> if this instance has been met; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="M:NMock.Internal.OrderedExpectationList.#ctor(NMock.IExpectationList)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Internal.OrderedExpectationList" /> class.
            </summary>
      <param name="parent">The parent <see cref="T:NMock.IExpectationList" /> of this <see cref="T:NMock.Internal.OrderedExpectationList" /></param>
    </member>
    <member name="M:NMock.Internal.OrderedExpectationList.Matches(NMock.Monitoring.Invocation)">
      <summary>
            Checks whether stored expectations matches the specified invocation.
            </summary>
      <param name="invocation">The invocation to check.</param>
      <returns>Returns whether one of the stored expectations has met the specified invocation.</returns>
    </member>
    <member name="P:NMock.Internal.OrderedExpectationList.CurrentExpectation">
      <summary>
            Gets the current expectation.
            </summary>
      <value>The current expectation.</value>
    </member>
    <member name="P:NMock.Internal.OrderedExpectationList.HasNextExpectation">
      <summary>
            Gets a value indicating whether this instance has next expectation.
            </summary>
      <value>
        <c>true</c> if this instance has next expectation; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:NMock.Internal.OrderedExpectationList.NextExpectation">
      <summary>
            Gets the next expectation.
            </summary>
      <value>The next expectation.</value>
    </member>
    <member name="P:NMock.Internal.OrderedExpectationList.IsActive">
      <summary>
            Gets a value indicating whether this instance is active.
            </summary>
      <value>
        <c>true</c> if this instance is active; otherwise, <c>false</c>.</value>
    </member>
    <member name="F:NMock.Internal.IndexGetterBuilder.builder">
      <summary>
            Holds the instance to the <see cref="T:NMock.Internal.ExpectationBuilder" />.
            </summary>
    </member>
    <member name="M:NMock.Internal.IndexGetterBuilder.#ctor(NMock.Internal.BuildableExpectation,NMock.Internal.ExpectationBuilder)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Internal.IndexGetterBuilder" /> class.
            </summary>
      <param name="expectation">The expectation.</param>
      <param name="builder">The builder.</param>
    </member>
    <member name="T:NMock.Matchers.CallbackListMatcher`1">
      <summary>
            A matcher that stores a list of delegates to call back to later.
            </summary>
      <typeparam name="T">Typically a <see cref="T:System.Action" />, <see cref="T:System.Predicate`1" />, <see cref="T:System.Func`1" />, or their equivalents.</typeparam>
    </member>
    <member name="M:NMock.Matchers.CallbackListMatcher`1.Matches(System.Object)">
      <summary>
            Determines if the parameter is the same type as <typeparamref name="T" />.
            </summary>
      <param name="o">The value the matcher will evaluate.</param>
      <returns>A value indicating if the parameter matches or not.</returns>
    </member>
    <member name="M:NMock.Matchers.CallbackListMatcher`1.DescribeTo(System.IO.TextWriter)">
      <summary>
            Describes this matcher.
            </summary>
      <param name="writer">The text writer to which the description is added.</param>
    </member>
    <member name="P:NMock.Matchers.CallbackListMatcher`1.Callbacks">
      <summary>
            Gets a list of references to the callbacks assigned during the matching operation of the expectation.
            </summary>
    </member>
    <member name="T:NMock.Matchers.ObjectMatcher">
      <summary>
            Matches 2 objects using IComparable
            </summary>
    </member>
    <member name="M:NMock.Matchers.ObjectMatcher.#ctor(System.Object)">
      <summary>
      </summary>
      <param name="o">
      </param>
    </member>
    <member name="M:NMock.Matchers.ObjectMatcher.Matches(System.Object)">
      <summary>
            Compares 2 objects using IComparable
            </summary>
      <param name="o">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NMock.Matchers.ObjectMatcher.DescribeTo(System.IO.TextWriter)">
      <summary>
            Describes this matcher.
            </summary>
      <param name="writer">The text writer to which the description is added.</param>
    </member>
    <member name="T:NMock.Matchers.ArgumentsMatcher">
      <summary>
            Matcher that checks whether parameters of a method match with the specified list of matchers.
            </summary>
    </member>
    <member name="T:NMock.Matchers.ArgumentsMatcher.OutMatcher">
      <summary>
            Matcher that matches method out parameters. 
            </summary>
    </member>
    <member name="M:NMock.Matchers.ArgumentsMatcher.OutMatcher.Matches(System.Object)">
      <summary>
            Matches the specified object to this matcher and returns whether it matches.
            </summary>
      <param name="o">The object to match.</param>
      <returns>Whether the object mached is an out parameter.</returns>
    </member>
    <member name="M:NMock.Matchers.ArgumentsMatcher.OutMatcher.DescribeTo(System.IO.TextWriter)">
      <summary>
            Describes this object.
            </summary>
      <param name="writer">The text writer the description is added to.</param>
    </member>
    <member name="F:NMock.Matchers.ArgumentsMatcher.OutParameter">
      <summary>
            Stores the out parameter.
            </summary>
    </member>
    <member name="F:NMock.Matchers.ArgumentsMatcher.valueMatchers">
      <summary>
            Stores the valuematchers given at initialization.
            </summary>
    </member>
    <member name="M:NMock.Matchers.ArgumentsMatcher.#ctor">
      <summary>
            Creates an instance of the <see cref="T:NMock.Matchers.ArgumentsMatcher" /> class.
            </summary>
    </member>
    <member name="M:NMock.Matchers.ArgumentsMatcher.#ctor(NMock.Matcher[])">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Matchers.ArgumentsMatcher" /> class.
            </summary>
      <param name="valueMatchers">The value matchers. This is an ordered list of matchers, each matching a single method argument.</param>
    </member>
    <member name="M:NMock.Matchers.ArgumentsMatcher.AddMatcher(NMock.Matcher)">
      <summary>
            Adds a matcher to the arguments matcher
            </summary>
      <param name="matcher">
      </param>
    </member>
    <member name="M:NMock.Matchers.ArgumentsMatcher.Matches(System.Object)">
      <summary>
            Matches the specified object to this matcher and returns whether it matches.
            </summary>
      <param name="o">The object to match.</param>
      <returns>Whether the object is an <see cref="T:NMock.Monitoring.Invocation" /> and all method arguments match their corresponding matcher.</returns>
    </member>
    <member name="M:NMock.Matchers.ArgumentsMatcher.DescribeTo(System.IO.TextWriter)">
      <summary>
            Describes this matcher.
            </summary>
      <param name="writer">The text writer to which the description is added.</param>
    </member>
    <member name="M:NMock.Matchers.ArgumentsMatcher.LastMatcher">
      <summary>
            Returns the last argument matcher.
            </summary>
      <returns>Argument matcher</returns>
    </member>
    <member name="M:NMock.Matchers.ArgumentsMatcher.WriteListOfMatchers(System.Int32,System.IO.TextWriter)">
      <summary>
            Writes the list of matchers to a <see cref="T:System.IO.TextWriter" />.
            </summary>
      <param name="listLength">Length of the list.</param>
      <param name="writer">The writer.</param>
    </member>
    <member name="P:NMock.Matchers.ArgumentsMatcher.Count">
      <summary>
            The number of value matchers
            </summary>
    </member>
    <member name="P:NMock.Matchers.ArgumentsMatcher.Item(System.Int32)">
      <summary>
            Gets a value matcher by index
            </summary>
      <param name="index">The index of the item to return</param>
      <returns>A value matcher</returns>
    </member>
    <member name="T:NMock.Syntax.IActionSyntax">
      <summary>
            Syntax for defining actions.
            </summary>
    </member>
    <member name="M:NMock.Syntax.IActionSyntax.Will(NMock.IAction[])">
      <summary>
            Creates the expectation of what to do when this member is called.
            </summary>
      <param name="actions">Common <see cref="T:NMock.IAction" />s can be found in the <see cref="T:NMock.Return" /> and <see cref="T:NMock.Throw" /> classes.</param>
      <returns>Returns the comment syntax defined after will.</returns>
      <remarks>
            For void methods this action does not need to be used.
            For non-void methods this action is typically set to use the <see cref="T:NMock.Return" /> class.
            For all methods this action can be used to throw an exception using the <see cref="T:NMock.Throw" /> class.
            </remarks>
    </member>
    <member name="T:NMock.Syntax.IAutoActionSyntax`1">
      <summary>
            Extends the <see cref="T:NMock.Syntax.IArgumentSyntax" /> interface to include the <see cref="M:NMock.Syntax.IAutoActionSyntax`1.WillReturn(`0)" /> method.
            </summary>
    </member>
    <member name="M:NMock.Syntax.IAutoActionSyntax`1.WillReturn(`0)">
      <summary>
            This is the strongly-typed version of the <see cref="M:NMock.Syntax.IActionSyntax.Will(NMock.IAction[])" /> method.  Use this method when
            the value to return <b>is</b> this value (and not a matcher).
            </summary>
      <param name="actualValue">
      </param>
      <returns>
      </returns>
      <remarks>
            This version of the "Will" methods is used in place of <c>.Will(Return.Value(obj))</c> when <c>obj</c> is known
            and should be checked at compile time.  The benefit is that the method takes a strongly-typed argument.  The 
            drawback is that you can't specify a matcher.
            </remarks>
    </member>
    <member name="T:NMock.Syntax.IAutoArgumentSyntax`1">
      <summary>
            This interface provides the syntax used for "Method" methods on the <see cref="T:NMock.Syntax.IMethodSyntax`1" />
            interface that don't return void and don't use argument values explicitly.
            </summary>
      <typeparam name="TResult">The return type of the method.</typeparam>
      <remarks>
            This interface provides the syntax needed to specify method arguments or match
            method arguments.
            </remarks>
    </member>
    <member name="M:NMock.Syntax.IAutoArgumentSyntax`1.With(System.Object[])">
      <summary>
            Defines the arguments that are expected on the method call.
            </summary>
      <param name="expectedArguments">The expected arguments.</param>
      <returns>Matcher syntax.</returns>
    </member>
    <member name="M:NMock.Syntax.IAutoArgumentSyntax`1.WithNoArguments">
      <summary>
            Defines that no arguments are expected on the method call.
            </summary>
      <returns>Matcher syntax.</returns>
    </member>
    <member name="M:NMock.Syntax.IAutoArgumentSyntax`1.WithAnyArguments">
      <summary>
            Defines that all arguments are allowed on the method call.
            </summary>
      <returns>Matcher syntax.</returns>
    </member>
    <member name="M:NMock.Syntax.IAutoArgumentSyntax`1.WithArguments(NMock.Matcher[])">
      <summary>
            Defines matching criteria for arguments.
            </summary>
      <param name="argumentMatchers">A list of matchers to match the arguments of a method.</param>
      <returns>Action syntax defining the action to take.</returns>
      <remarks>
            The matchers will be automatically wrapped in an ArgumentsMatcher.
            </remarks>
    </member>
    <member name="T:NMock.Monitoring.IInvokable">
      <summary>
            IInvokable objects can be invoked.
            </summary>
    </member>
    <member name="M:NMock.Monitoring.IInvokable.Invoke(NMock.Monitoring.Invocation)">
      <summary>
            Invokes this object.
            </summary>
      <param name="invocation">The invocation.</param>
    </member>
    <member name="T:NMock.IMockObject">
      <summary>
            Interface for mocks.
            </summary>
    </member>
    <member name="M:NMock.IMockObject.GetMethodsMatching(NMock.Matcher)">
      <summary>
            Retrieves all matching methods on this mock. 
            </summary>
      <param name="methodMatcher">A Matcher to use in identifying the methods.</param>
      <returns>A list of zero or more matching MethodInfo instances.</returns>
    </member>
    <member name="M:NMock.IMockObject.AddExpectation(NMock.IExpectation)">
      <summary>
            Adds an expectation to this mock.
            </summary>
      <param name="expectation">The expectation to add.</param>
    </member>
    <member name="M:NMock.IMockObject.RaiseEvent(System.String,System.Object[])">
      <summary>
            Raises an event on this mock.
            </summary>
      <param name="eventName">Name of the event to fire.</param>
      <param name="args">The arguments passed to the event.</param>
    </member>
    <member name="M:NMock.IMockObject.ProcessEventHandlers(NMock.Monitoring.Invocation)">
      <summary>
      </summary>
      <param name="invocation">
      </param>
    </member>
    <member name="P:NMock.IMockObject.MockName">
      <summary>
            Gets the name of the mock instance. This is often used in error messages
            to identify a specific mock instance.
            </summary>
    </member>
    <member name="P:NMock.IMockObject.MockedTypes">
      <summary>
            Gets a <see cref="T:NMock.Proxy.CompositeType" /> that represents all types to be mocked.
            </summary>
    </member>
    <member name="P:NMock.IMockObject.IgnoreUnexpectedInvocations">
      <summary>
            Gets or sets a value indicating if this <see cref="T:NMock.Mock`1" /> should ignore unexpected invocations to properties, methods, or events.
            </summary>
      <remarks>
            Use the property to have a Mock ignore calls with no expectations.  By default, this works fine for property setters, void methods,
            and events.  Property getters and non-void methods will need to indicate how they will be implemented as they <i>need</i> to return
            a value.
            </remarks>
    </member>
    <member name="P:NMock.IMockObject.InterceptedValues">
      <summary>
            A <see cref="T:System.Collections.Generic.Dictionary`2" /> that stores property values from internal operations.
            </summary>
    </member>
    <member name="T:NMock.Internal.MockObject">
      <summary>
      </summary>
    </member>
    <member name="F:NMock.Internal.MockObject.assignedPropertyResults">
      <summary>
            Results that have been explicitly assigned via a call to a property setter.
            These will be returned for all subsequent calls to the matching property getter.
            </summary>
    </member>
    <member name="F:NMock.Internal.MockObject.eventHandlers">
      <summary>
            Stores the event handlers that could be added to the mock object.
            </summary>
    </member>
    <member name="F:NMock.Internal.MockObject.rememberedMethodResults">
      <summary>
            Results that have been generated for methods or property getters.
            These will be returned for all subsequent calls to the same member.
            </summary>
    </member>
    <member name="M:NMock.Internal.MockObject.#ctor(NMock.MockFactory,NMock.Proxy.CompositeType,System.String,NMock.MockStyle)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Internal.MockObject" /> class.
            </summary>
      <param name="mockFactory">The mockFactory.</param>
      <param name="mockedType">Type of the mocked.</param>
      <param name="name">The name.</param>
      <param name="mockStyle">The mock style.</param>
    </member>
    <member name="M:NMock.Internal.MockObject.GetStubResult(NMock.Monitoring.Invocation)">
      <summary>
            Gets the default result for an invocation.
            </summary>
      <param name="invocation">The invocation.</param>
      <returns>The default value to return as result of the invocation. 
            <see cref="F:System.Reflection.Missing.Value" /> if no default value was provided.</returns>
    </member>
    <member name="M:NMock.Internal.MockObject.GetMemberName(NMock.ISelfDescribing)">
      <summary>
            Gets the name of the member to be used as the name for a mock returned an a call to a stub.
            </summary>
      <param name="invocation">The invocation.</param>
      <returns>Name of the mock created as a result value on a call to a stub.</returns>
    </member>
    <member name="P:NMock.Internal.MockObject.MockStyle">
      <summary>
            Gets the mock style of this mock.
            </summary>
    </member>
    <member name="T:NMock.Syntax.IMatchSyntax">
      <summary>
            Syntax defining matching criterias.
            </summary>
    </member>
    <member name="M:NMock.Syntax.IMatchSyntax.Matching(NMock.Matcher)">
      <summary>
            Defines a matching criteria.
            </summary>
      <param name="matcher">The matcher.</param>
      <returns>Action syntax defining the action to take.</returns>
    </member>
    <member name="T:NMock.DelegateInvoker">
      <summary>
      </summary>
    </member>
    <member name="M:NMock.DelegateInvoker.Invoke(System.Object[])">
      <summary>
            Invokes the delegate with the specified parameters.
            </summary>
      <exception cref="T:System.InvalidOperationException" />
    </member>
    <member name="T:NMock.Actions.SetNamedParameterAction">
      <summary>
            Action that sets the parameter of the invocation with the specified name to the specified value.
            </summary>
    </member>
    <member name="F:NMock.Actions.SetNamedParameterAction.name">
      <summary>
            Stores the name of the parameter when the class gets initialized.
            </summary>
    </member>
    <member name="F:NMock.Actions.SetNamedParameterAction.value">
      <summary>
            Stores the value of the parameter when the class gets initialized.
            </summary>
    </member>
    <member name="M:NMock.Actions.SetNamedParameterAction.#ctor(System.String,System.Object)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Actions.SetNamedParameterAction" /> class.
            </summary>
      <param name="name">The name of the parameter to set.</param>
      <param name="value">The value.</param>
    </member>
    <member name="T:NMock.Actions.SetIndexedParameterAction">
      <summary>
            Action that sets a parameter (method argument) of the invocation to the specified value.
            </summary>
    </member>
    <member name="F:NMock.Actions.SetIndexedParameterAction.index">
      <summary>
            Stores the index of the paremter to set.
            </summary>
    </member>
    <member name="F:NMock.Actions.SetIndexedParameterAction.value">
      <summary>
            Stores the value of the parameter to set.
            </summary>
    </member>
    <member name="M:NMock.Actions.SetIndexedParameterAction.#ctor(System.Int32,System.Object)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Actions.SetIndexedParameterAction" /> class.
            </summary>
      <param name="index">The index of the parameter to set.</param>
      <param name="value">The value.</param>
    </member>
    <member name="T:NMock.Actions.LazyReturnAction">
      <summary>
            Action that sets the result value on an invocation. The value is aquired by calling the delegate specified in the constructor.
            </summary>
    </member>
    <member name="T:NMock.Actions.LazyReturnAction.Evaluate">
      <summary>
            Delegate that is used to get the return value.
            </summary>
      <returns>
            Returns an object...
            </returns>
    </member>
    <member name="F:NMock.Actions.LazyReturnAction.evaluate">
      <summary>
            Stores the evaluate delegate for this action.
            </summary>
    </member>
    <member name="M:NMock.Actions.LazyReturnAction.#ctor(NMock.Actions.LazyReturnAction.Evaluate)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Actions.LazyReturnAction" /> class.
            </summary>
      <param name="evaluate">The delegate used to aquire the return value.</param>
    </member>
    <member name="T:NMock.Stub`1">
      <summary>
            This class represents a stub.
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="P:NMock.Stub`1.Out">
      <summary>
            A syntax property used to stub out data for this instance.
            </summary>
    </member>
    <member name="T:NMock.Matchers.StringContainsMatcher">
      <summary>
            Matcher that checks whether the actual value contains the expected substring.
            </summary>
    </member>
    <member name="M:NMock.Matchers.StringContainsMatcher.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Matchers.StringContainsMatcher" /> class.
            </summary>
      <param name="substring">The substring that is expected.</param>
    </member>
    <member name="M:NMock.Matchers.StringContainsMatcher.Matches(System.Object)">
      <summary>
            Matches the specified object to this matcher and returns whether it matches.
            </summary>
      <param name="o">The object to match.</param>
      <returns>Whether the object is a string and contains the expected substring.</returns>
    </member>
    <member name="M:NMock.Matchers.StringContainsMatcher.DescribeTo(System.IO.TextWriter)">
      <summary>
            Describes this matcher.
            </summary>
      <param name="writer">The text writer to which the description is added.</param>
    </member>
    <member name="T:NMock.Matchers.EqualMatcher">
      <summary>
            Matcher that checks whether the expected and actual value are equal.
            </summary>
    </member>
    <member name="M:NMock.Matchers.EqualMatcher.#ctor(System.Object)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Matchers.EqualMatcher" /> class.
            </summary>
      <param name="expected">The expected value.</param>
    </member>
    <member name="M:NMock.Matchers.EqualMatcher.Matches(System.Object)">
      <summary>
            Matcheses the specified actual.
            </summary>
      <param name="actual">The actual value.</param>
      <returns>Whether the expected value is equal to the actual value.</returns>
    </member>
    <member name="M:NMock.Matchers.EqualMatcher.DescribeTo(System.IO.TextWriter)">
      <summary>
            Describes this matcher.
            </summary>
      <param name="writer">The text writer to which the description is added.</param>
    </member>
    <member name="T:NMock.Syntax.IMethodSyntax">
      <summary>
            Syntax defining a method, property or event (de)registration.
            </summary>
    </member>
    <member name="M:NMock.Syntax.IMethodSyntax.ProtectedMethod(System.String)">
      <summary>
            Sets up an expectation that a protected method will be called.
            </summary>
      <param name="name">The name of the method.</param>
      <returns>
            Argument syntax defining the arguments of the method.
            </returns>
    </member>
    <member name="T:NMock.Matchers.CountMatcher`1">
      <summary>
      </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="M:NMock.Matchers.CountMatcher`1.#ctor(System.Int32)">
      <summary>
      </summary>
      <param name="expectedCount">
      </param>
    </member>
    <member name="T:NMock.Actions.IReturnAction">
      <summary>
            Represents an <see cref="T:NMock.IAction" /> that returns a result.
            </summary>
    </member>
    <member name="P:NMock.Actions.IReturnAction.ReturnType">
      <summary>
            The return type of this <see cref="T:NMock.IAction" /></summary>
    </member>
    <member name="T:NMock.Actions.QueueAction`1">
      <summary>
            Action that returns an item from the queue 
            </summary>
    </member>
    <member name="M:NMock.Actions.QueueAction`1.#ctor(System.Collections.Generic.Queue{`0})">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Actions.QueueAction`1" /> class with the queue of values.
            </summary>
      <param name="queue">
      </param>
    </member>
    <member name="T:NMock.Actions.DelegateReturnAction`1">
      <summary>
            Represents an <see cref="T:NMock.Actions.IReturnAction" /> that can call a delegate to provide the return value.
            </summary>
      <typeparam name="T">The type to return.</typeparam>
    </member>
    <member name="M:NMock.Actions.DelegateReturnAction`1.#ctor(System.Func{`0})">
      <summary>
            Creates an instance of this class with a <see cref="T:System.Func`1" /> to call during invocation.
            </summary>
      <param name="func">The <see cref="T:System.Func`1" /> to invoke.</param>
    </member>
    <member name="M:NMock.Actions.DelegateReturnAction`1.#ctor(System.Func{NMock.Monitoring.Invocation,`0})">
      <summary>
            Creates an instance of this class with a <see cref="T:System.Func`1" /> to call during invocation.
            </summary>
      <param name="func">The <see cref="T:System.Func`1" /> to invoke.</param>
    </member>
    <member name="T:NMock.Matchers.NullMatcher">
      <summary>
            Matcher that checks whether to actual value is equal to null.
            </summary>
    </member>
    <member name="M:NMock.Matchers.NullMatcher.#ctor">
      <summary>
            Initializes an instance of the <see cref="T:NMock.Matchers.NullMatcher" /> class with a description of null.
            </summary>
    </member>
    <member name="M:NMock.Matchers.NullMatcher.Matches(System.Object)">
      <summary>
            Matches the specified object to this matcher and returns whether it matches.
            </summary>
      <param name="o">The object to match.</param>
      <returns>Whether the object is equal to null.</returns>
    </member>
    <member name="T:NMock.Internal.DescriptionWriter">
      <summary>
            Used to describe Matchers and other classes for exception handling.
            </summary>
    </member>
    <member name="M:NMock.Internal.DescriptionWriter.Write(System.Object)">
      <summary>
            Writes the text representation of an object to the text stream by calling ToString on that object.
            </summary>
      <param name="value">The object to write.</param>
      <exception cref="T:System.ObjectDisposedException">
            The <see cref="T:System.IO.TextWriter" /> is closed.
            </exception>
      <exception cref="T:System.IO.IOException">
            An I/O error occurs.
            </exception>
    </member>
    <member name="M:NMock.Internal.DescriptionWriter.FormatValue(System.Object)">
      <summary>
            Formats the given <paramref name="value" /> depending on null and the type of the value.
            </summary>
      <param name="value">The value to format.</param>
      <returns>Returns the formatted string.</returns>
    </member>
    <member name="M:NMock.Internal.DescriptionWriter.FormatString(System.String)">
      <summary>
            Replaces backslashes with three escaped backslashes.
            </summary>
      <param name="s">The string to replace backslashes.</param>
      <returns>Returns the escaped string.</returns>
    </member>
    <member name="T:NMock.Proxy.InterfaceMockBase">
      <summary>
            Used as a base for interface mocks in order to provide a holder
            for a meaningful ToString() value.
            </summary>
    </member>
    <member name="M:NMock.Proxy.InterfaceMockBase.#ctor">
      <summary>
            Default constructor used by Castle.DynamicProxy.
            </summary>
      <remarks>Do not remove.  This is needed by Castle.</remarks>
    </member>
    <member name="M:NMock.Proxy.InterfaceMockBase.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Proxy.InterfaceMockBase" /> class.
            </summary>
      <param name="name">The name of this instance.</param>
    </member>
    <member name="M:NMock.Proxy.InterfaceMockBase.ToString">
      <summary>
            Returns the name of this instance.
            </summary>
      <returns>The name of this instance.</returns>
    </member>
    <member name="M:NMock.Proxy.InterfaceMockBase.Equals(System.Object)">
      <summary>
            Determines whether the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />.
            </summary>
      <param name="obj">The <see cref="T:System.Object" /> to compare with the current <see cref="T:System.Object" />.</param>
      <returns>true if the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />; otherwise, false.</returns>
    </member>
    <member name="M:NMock.Proxy.InterfaceMockBase.GetHashCode">
      <summary>
            Serves as a hash function for a particular type.
            </summary>
      <returns>A hash code for the current System.Object.</returns>
    </member>
    <member name="T:NMock.Actions.FireAction">
      <summary>
            Action that fires an event.
            </summary>
    </member>
    <member name="F:NMock.Actions.FireAction.eventArgs">
      <summary>
            Stores the event arguments.
            </summary>
    </member>
    <member name="F:NMock.Actions.FireAction.eventName">
      <summary>
            Stores the name of the event to fire.
            </summary>
    </member>
    <member name="M:NMock.Actions.FireAction.#ctor(System.String,System.Object[])">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Actions.FireAction" /> class.
            </summary>
      <param name="eventName">Name of the event.</param>
      <param name="eventArgs">The event args.</param>
    </member>
    <member name="T:NMock.MockStyle">
      <summary>
            Specifies how a mock object should behave when it is first created.
            </summary>
    </member>
    <member name="F:NMock.MockStyle.Default">
      <summary>
            Calls to members that do not have expectations set will
            result in ExpectationExceptions.
            </summary>
    </member>
    <member name="F:NMock.MockStyle.Transparent">
      <summary>
            Calls to members that do not have expectations set will
            pass through to the underlying implementation on the class
            being mocked.
            </summary>
    </member>
    <member name="F:NMock.MockStyle.Stub">
      <summary>
            Calls to members that do not have expectations set will
            be ignored. Default values are used for return values 
            (default value of the return type, stub or empty enumerable)
            and the same value is returned on every call to the same member.
            </summary>
    </member>
    <member name="F:NMock.MockStyle.RecursiveStub">
      <summary>
            Calls to members that do not have expectations set will
            be ignored. Default values are used for return values 
            (default value of the return type, stub or empty enumerable)
            and the same value is returned on every call to the same member.
            </summary>
    </member>
    <member name="T:NMock.Matchers.TypeMatcher">
      <summary>
            Matcher that checks whether the actual object can be assigned to the expected type.
            </summary>
    </member>
    <member name="M:NMock.Matchers.TypeMatcher.#ctor(System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Matchers.TypeMatcher" /> class.
            </summary>
      <param name="type">The expected type.</param>
    </member>
    <member name="M:NMock.Matchers.TypeMatcher.Matches(System.Object)">
      <summary>
            Matches the specified object to this matcher and returns whether it matches.
            </summary>
      <param name="o">The object to match.</param>
      <returns>Whether the object castable to the expected type.</returns>
    </member>
    <member name="M:NMock.Matchers.TypeMatcher.DescribeTo(System.IO.TextWriter)">
      <summary>
            Describes this matcher.
            </summary>
      <param name="writer">The text writer to which the description is added.</param>
    </member>
    <member name="T:NMock.Matchers.IndexGetterArgumentsMatcher">
      <summary>
            Matcher for indexer getters. Checks that the arguments passed to the indexer match.
            </summary>
    </member>
    <member name="M:NMock.Matchers.IndexGetterArgumentsMatcher.#ctor(NMock.Matcher[])">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Matchers.IndexGetterArgumentsMatcher" /> class.
            </summary>
      <param name="valueMatchers">The value matchers. This is an ordered list of matchers, each matching a single method argument.</param>
    </member>
    <member name="M:NMock.Matchers.IndexGetterArgumentsMatcher.DescribeTo(System.IO.TextWriter)">
      <summary>
            Describes this matcher.
            </summary>
      <param name="writer">The text writer to which the description is added.</param>
    </member>
    <member name="T:NMock.Syntax.IAutoPropertyActionSyntax`1">
      <summary>
            This interface adds a special method for property expectations.
            </summary>
      <typeparam name="TResult">
      </typeparam>
    </member>
    <member name="M:NMock.Syntax.IAutoPropertyActionSyntax`1.WillReturnSetterValue">
      <summary>
            Sets up an expectation that calls an action to return the value of the property
            that was previously set in code or prior expectation.
            </summary>
      <returns>
      </returns>
      <remarks>
            It is useful in cases where a value is assigned to a property internally in a method
            and only a <see cref="T:NMock.Matchers.TypeMatcher" /> could be used to match the assignment.  This method
            is called on a getter expectation to get that underlying value.
            </remarks>
    </member>
    <member name="T:NMock.Expect">
      <summary>
            Used to set up expectations on types that are not mocks.
            </summary>
    </member>
    <member name="M:NMock.Expect.That(System.Action)">
      <summary>
            Creates an expectation related to the type of <see cref="T:System.Exception" /> thrown.
            </summary>
      <param name="action">The method that should cause the exception.  Hint: use () =&gt; to convert a method to an action.</param>
      <returns>An object to complete the expectation</returns>
      <remarks>Use this in place of a [ExpectedException] unit test attribute.</remarks>
    </member>
    <member name="M:NMock.Expect.On``1(``0)">
      <summary>
            Default expectation, specifies that a method, property, etc. that has to be called at least once.
            </summary>
      <param name="receiver">The receiver.</param>
      <returns>Returns a receiver of a method, property, etc. that has to be called at least once.</returns>
    </member>
    <member name="T:NMock.Actions.InvokeAction">
      <summary>
            An <see cref="T:NMock.IAction" /> that can invoke an <see cref="T:System.Action" /> when the expectation is met.
            </summary>
    </member>
    <member name="M:NMock.Actions.InvokeAction.#ctor(System.Action)">
      <summary>
            Creates an <see cref="T:NMock.IAction" /> that will invoke the <paramref name="action" />.
            </summary>
      <param name="action">The action to invoke.</param>
    </member>
    <member name="T:NMock.Syntax.Invoke">
      <summary>
            A syntax class to create an <see cref="T:NMock.Actions.InvokeAction" /> in a easy to read way.
            </summary>
    </member>
    <member name="M:NMock.Syntax.Invoke.Action(System.Action)">
      <summary>
            A syntax method to create an <see cref="T:NMock.Actions.InvokeAction" /> class.
            </summary>
      <param name="action">The <see cref="M:NMock.Syntax.Invoke.Action(System.Action)" /> to invoke when the <see cref="T:NMock.IAction" /> in invoked.</param>
      <returns>An instance of an <see cref="T:NMock.Actions.InvokeAction" />class.</returns>
    </member>
    <member name="T:NMock.Has">
      <summary>
            Provides shortcuts to matchers.
            </summary>
    </member>
    <member name="M:NMock.Has.ToString(NMock.Matcher)">
      <summary>
            Returns a matcher for testing string representation of objects.
            </summary>
      <param name="matcher">The wrapped matcher.</param>
      <returns>Returns a <see cref="T:NMock.Matchers.ToStringMatcher" /> for testing string representation of objects.</returns>
    </member>
    <member name="M:NMock.Has.Property(System.String,NMock.Matcher)">
      <summary>
            Returns a matcher for checking property values.
            </summary>
      <param name="propertyName">Name of the property.</param>
      <param name="valueMatcher">The value matcher.</param>
      <returns>Returns a <see cref="T:NMock.Matchers.PropertyMatcher" /> for checking property values.</returns>
    </member>
    <member name="M:NMock.Has.Field(System.String,NMock.Matcher)">
      <summary>
            Returns a matcher for checking field values.
            </summary>
      <param name="fieldName">Name of the field.</param>
      <param name="valueMatcher">The value matcher.</param>
      <returns>Returns a <see cref="T:NMock.Matchers.FieldMatcher" /> for checking field values.</returns>
    </member>
    <member name="T:NMock.Matchers.ToStringMatcher">
      <summary>
            Matcher that checks whether the actual value in string representation (actual.ToString())
            matches with the wrapped matcher.
            </summary>
    </member>
    <member name="F:NMock.Matchers.ToStringMatcher.matcher">
      <summary>
            Holds the wrapped matcher.
            </summary>
    </member>
    <member name="M:NMock.Matchers.ToStringMatcher.#ctor(NMock.Matcher)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Matchers.ToStringMatcher" /> class.
            </summary>
      <param name="matcher">The wrapped matcher.</param>
    </member>
    <member name="M:NMock.Matchers.ToStringMatcher.Matches(System.Object)">
      <summary>
            Matches the specified object to this matcher and returns whether it matches.
            </summary>
      <param name="o">The object to match.</param>
      <returns>Whether the object in string representation (o.ToString()) matches the wrapped matcher.</returns>
    </member>
    <member name="M:NMock.Matchers.ToStringMatcher.DescribeTo(System.IO.TextWriter)">
      <summary>
            Describes this matcher.
            </summary>
      <param name="writer">The text writer to which the description is added.</param>
    </member>
    <member name="T:NMock.Matchers.GenericMatcher`1">
      <summary>
            Matcher that checks whether a value matches the check provided as a delegate.
            the expectation.
            </summary>
      <typeparam name="T">The type of the expected value.</typeparam>
    </member>
    <member name="T:NMock.Matchers.GenericMatcher`1.MatchExpression">
      <summary>
            The test that is performed to check if the <paramref name="value" /> matches the expectation.
            </summary>
      <param name="value">The actually received value.</param>
      <returns>True then value matches the expectation.</returns>
    </member>
    <member name="F:NMock.Matchers.GenericMatcher`1.matchExpression">
      <summary>
            The test that is performed to see if the value matches the expectation.
            </summary>
    </member>
    <member name="M:NMock.Matchers.GenericMatcher`1.#ctor(NMock.Matchers.GenericMatcher{`0}.MatchExpression)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Matchers.GenericMatcher`1" /> class.
            </summary>
      <param name="matchExpression">The test that is performed to check if the value matches expectation.</param>
      <exception cref="T:System.ArgumentNullException">
        <c>matchExpression</c> is null.</exception>
    </member>
    <member name="M:NMock.Matchers.GenericMatcher`1.Matches(System.Object)">
      <summary>
            Matches the specified object to this matcher and returns whether it matches.
            </summary>
      <param name="o">The object to match.</param>
      <returns>Whether the object matches.</returns>
    </member>
    <member name="T:NMock.Syntax.IAutoMatchSyntax`1">
      <summary>
            This interface ties together the <see cref="T:NMock.Syntax.IMatchSyntax" /> and <see cref="T:NMock.Syntax.IAutoActionSyntax`1" />
            interfaces to provide syntax on <see cref="M:NMock.Syntax.IStubSyntax`1.GetProperty``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})" />.
            </summary>
      <typeparam name="TProperty">The property type of the lambda expression.</typeparam>
      <remarks>
            This interface doesn't provide any new members.  It is used to tie together two existing
            interfaces so that the <see cref="M:NMock.Syntax.IStubSyntax`1.GetProperty``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})" />
            method will return the right syntax.
            </remarks>
    </member>
    <member name="T:NMock.Matchers.PredicateMatcher`1">
      <summary>
            A matcher that uses lambda expressions to perform matching
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="M:NMock.Matchers.PredicateMatcher`1.#ctor(System.Predicate{`0})">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Matchers.PredicateMatcher`1" /> class with the supplied predicate.
            </summary>
      <param name="matcher">A lambda expression that evaluates to true or false</param>
    </member>
    <member name="M:NMock.Matchers.PredicateMatcher`1.#ctor(System.Predicate{`0},System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Matchers.PredicateMatcher`1" /> class with the supplied predicate.
            </summary>
      <param name="matcher">A lambda expression that evaluates to true or false</param>
      <param name="description">A message to describe the expectation.</param>
    </member>
    <member name="M:NMock.Matchers.PredicateMatcher`1.Matches(System.Object)">
      <summary>
            Matches the specified object to this matcher and returns whether it matches.
            </summary>
      <param name="o">The object to match.</param>
      <returns>Whether the object matches.</returns>
    </member>
    <member name="T:NMock.Monitoring.ParameterList">
      <summary>
            Manages a list of parameters for a mocked method together with the parameter's values.
            </summary>
    </member>
    <member name="F:NMock.Monitoring.ParameterList.isValueSet">
      <summary>
            Holds a boolean for each value if it was set or not.
            </summary>
    </member>
    <member name="F:NMock.Monitoring.ParameterList.method">
      <summary>
            Holds the method to be mocked.
            </summary>
    </member>
    <member name="F:NMock.Monitoring.ParameterList.values">
      <summary>
            An array holding the values of the parameters.
            </summary>
    </member>
    <member name="M:NMock.Monitoring.ParameterList.#ctor(System.Reflection.MethodBase,System.Object[])">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Monitoring.ParameterList" /> class.
            </summary>
      <param name="method">The method to be mocked.</param>
      <param name="values">The values of the parameters.</param>
    </member>
    <member name="M:NMock.Monitoring.ParameterList.IsValueSet(System.Int32)">
      <summary>
            Determines whether the value specified by index was set.
            </summary>
      <param name="index">The index.</param>
      <returns>
            Returns <c>true</c> if value specified by index was set; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:NMock.Monitoring.ParameterList.MarkAllValuesAsSet">
      <summary>
            Marks all values as set.
            </summary>
    </member>
    <member name="M:NMock.Monitoring.ParameterList.CanValueBeSet(System.Int32)">
      <summary>
            Determines whether the parameter specified by index can be set.
            </summary>
      <param name="index">The index of the parameter.</param>
      <returns>
            Returns <c>true</c> if the parameter specified by index can be set; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:NMock.Monitoring.ParameterList.GetParameterName(System.Int32)">
      <summary>
            Gets the parameter name by index.
            </summary>
      <param name="index">The index of the parameter name to get.</param>
      <returns>
            Returns the parameter name with the given index.
            </returns>
    </member>
    <member name="P:NMock.Monitoring.ParameterList.Count">
      <summary>
            Gets the number of values.
            </summary>
      <value>The number of values.</value>
    </member>
    <member name="P:NMock.Monitoring.ParameterList.AsArray">
      <summary>
            Gets the values as array.
            </summary>
      <value>Values as array.</value>
    </member>
    <member name="P:NMock.Monitoring.ParameterList.Item(System.Int32)">
      <summary>
            Gets or sets the <see cref="T:System.Object" /> with the specified index.
            </summary>
      <param name="index">The index of the value to be get or set.</param>
      <value>
            The value of a parameter specified by its <paramref name="index" />.
            </value>
    </member>
    <member name="M:NMock.Internal.UnorderedExpectationList.#ctor(NMock.IExpectationList)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Internal.UnorderedExpectationList" /> class.
            </summary>
      <param name="parent">The parent <see cref="T:NMock.IExpectationList" /> of this instance.</param>
    </member>
    <member name="M:NMock.Internal.UnorderedExpectationList.Matches(NMock.Monitoring.Invocation)">
      <summary>
            Checks whether stored expectations matches the specified invocation.
            </summary>
      <param name="invocation">The invocation to check.</param>
      <returns>Returns whether one of the stored expectations has met the specified invocation.</returns>
    </member>
    <member name="M:NMock.Internal.UnorderedExpectationList.Perform(NMock.Monitoring.Invocation)">
      <summary>
            Performs the specified invocation on the corresponding expectation if a match was found.
            </summary>
      <param name="invocation">The invocation to match.</param>
    </member>
    <member name="P:NMock.Internal.UnorderedExpectationList.IsActive">
      <summary>
            Gets a value indicating whether this instance is active.
            </summary>
      <value>
        <c>true</c> if this instance is active; otherwise, <c>false</c>.</value>
    </member>
    <member name="M:NMock.Internal.BuildableExpectation.#ctor(System.String,NMock.Matcher,NMock.Matcher)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Internal.BuildableExpectation" /> class.
            </summary>
      <param name="expectationDescription">The expectation description.</param>
      <param name="requiredCountMatcher">The required count matcher.</param>
      <param name="matchingCountMatcher">The matching count matcher.</param>
    </member>
    <member name="M:NMock.Internal.BuildableExpectation.Matches(NMock.Monitoring.Invocation)">
      <summary>
            Checks whether stored expectations matches the specified invocation.
            </summary>
      <param name="invocation">The invocation to check.</param>
      <returns>Returns whether one of the stored expectations has met the specified invocation.</returns>
    </member>
    <member name="M:NMock.Internal.BuildableExpectation.QueryExpectationsBelongingTo(NMock.IMockObject,System.Collections.Generic.IList{NMock.IExpectation})">
      <summary>
            Adds itself to the <paramref name="result" /> if the <see cref="P:NMock.Internal.BuildableExpectation.Receiver" /> matches
            the specified <paramref name="mock" />.
            </summary>
      <param name="mock">The mock for which expectations are queried.</param>
      <param name="result">The result to add matching expectations to.</param>
    </member>
    <member name="M:NMock.Internal.BuildableExpectation.ValidationErrors">
      <summary>
            Returns a list of validation errors
            </summary>
      <returns>
      </returns>
    </member>
    <member name="T:NMock.Proxy.IMockObjectFactory">
      <summary>
            Implementations of this interface are responsible for generating runtime
            proxies of classes and interfaces for use as mock objects.
            </summary>
      <remarks>
            Returned instances are expected to implement IMockObject and take care of
            intercepting calls to their public members. Intercepted calls should be
            forwarded on to the supplied MockFactory for processing against expectations.
            </remarks>
    </member>
    <member name="M:NMock.Proxy.IMockObjectFactory.CreateMock(NMock.MockFactory,NMock.Proxy.CompositeType,System.String,NMock.MockStyle,System.Object[])">
      <summary>
            Creates a mock of the specified type(s).
            </summary>
      <param name="mockFactory">The mockFactory used to create this mock instance.</param>
      <param name="typesToMock">The type(s) to include in the mock.</param>
      <param name="name">The name to use for the mock instance.</param>
      <param name="mockStyle">The behaviour of the mock instance when first created.</param>
      <param name="constructorArgs">Constructor arguments for the class to be mocked. Only valid if mocking a class type.</param>
      <returns>A mock instance of the specified type(s).</returns>
    </member>
    <member name="T:NMock.Proxy.MockObjectFactoryBase">
      <summary>
            A base implementation of the <see cref="T:NMock.Proxy.IMockObjectFactory" /> interface
            </summary>
    </member>
    <member name="M:NMock.Proxy.MockObjectFactoryBase.BuildAdditionalTypeArrayForProxyType(NMock.Proxy.CompositeType)">
      <summary>
            Combines the specified types with the <see cref="T:NMock.IMockObject" /> into an array.
            </summary>
      <returns>An array of the specified types and <see cref="T:NMock.IMockObject" />,</returns>
    </member>
    <member name="M:NMock.Proxy.MockObjectFactoryBase.CreateMock(NMock.MockFactory,NMock.Proxy.CompositeType,System.String,NMock.MockStyle,System.Object[])">
      <summary>
            Creates a mock of the specified type(s).
            </summary>
      <param name="mockFactory">The mockFactory used to create this mock instance.</param>
      <param name="typesToMock">The type(s) to include in the mock.</param>
      <param name="name">The name to use for the mock instance.</param>
      <param name="mockStyle">The behaviour of the mock instance when first created.</param>
      <param name="constructorArgs">Constructor arguments for the class to be mocked. Only valid if mocking a class type.</param>
      <returns>A mock instance of the specified type(s).</returns>
    </member>
    <member name="T:NMock.Proxy.CompositeType">
      <summary>
            Represents one or more types that are to be mocked. Provides operations
            that work over top of all the contained types, as well as a means of
            grouping and identifying unique combinations of types.
            </summary>
      <remarks>Duplicate types are ignored when added. Only interface and class types are
            supported, and there may only be a maximum of one class type per CompositeType instance.</remarks>
    </member>
    <member name="M:NMock.Proxy.CompositeType.#ctor(System.Type[])">
      <summary>
            Initializes a new instance of the CompositeType class from the supplied types.
            </summary>
      <param name="types">The types to include in the CompositeType.</param>
    </member>
    <member name="M:NMock.Proxy.CompositeType.#ctor(System.Type,System.Type[])">
      <summary>
            Initializes a new instance of the CompositeType class from the supplied types.
            </summary>
      <param name="type">The first type to include in the CompositeType. This cannot be null.</param>
      <param name="additionalTypesToMock">Zero or more further types to include in the CompositeType.</param>
      <remarks>This constructor is mostly included for convenience.</remarks>
    </member>
    <member name="M:NMock.Proxy.CompositeType.Add(System.Type)">
      <summary>
            Adds a <see cref="T:System.Type" /> to this instance
            </summary>
      <param name="type">
      </param>
    </member>
    <member name="M:NMock.Proxy.CompositeType.Equals(NMock.Proxy.CompositeType)">
      <summary>
            Determines whether the specified CompositeType is equal to the current CompositeType.
            </summary>
      <param name="other">The CompositeType to compare with the current CompositeType.</param>
      <returns>true if the specified CompositeType is equal to the current CompositeType; otherwise, false.</returns>
    </member>
    <member name="M:NMock.Proxy.CompositeType.GetMatchingMethods(NMock.Matcher,System.Boolean)">
      <summary>
            Gets any methods of the contained type(s) that match the specified matcher.
            </summary>
      <param name="matcher">The matcher.</param>
      <param name="firstMatchOnly">if set to <c>true</c> then only the first match is returned.</param>
      <returns>The methods of the contained type(s) that match the specified matcher.</returns>
      <remarks>Only non-private methods can be matched.</remarks>
    </member>
    <member name="M:NMock.Proxy.CompositeType.GetHashCode">
      <summary>
            Returns the hash code for this instance.
            </summary>
      <returns>An Int32 containing the hash code for this instance.</returns>
    </member>
    <member name="M:NMock.Proxy.CompositeType.Equals(System.Object)">
      <summary>
            Determines whether the specified Object is equal to the current CompositeType.
            </summary>
      <param name="obj">The Object to compare with the current CompositeType.</param>
      <returns>true if the specified Object is equal to the current CompositeType; otherwise, false.</returns>
    </member>
    <member name="M:NMock.Proxy.CompositeType.ToString">
      <summary>
            Returns a String that represents the current CompositeType.
            </summary>
      <returns>A String that represents the current CompositeType.</returns>
    </member>
    <member name="M:NMock.Proxy.CompositeType.Initialize(System.Type[])">
      <summary>
            Initializes the specified types.
            </summary>
      <param name="types">The types.</param>
    </member>
    <member name="M:NMock.Proxy.CompositeType.GetInterfacesImplementedByType(System.Type)">
      <summary>
            Gets the interfaces implemented by the specified type.
            </summary>
      <param name="type">The interface type to inspect.</param>
      <returns>The interfaces implemented by the specified type.</returns>
    </member>
    <member name="M:NMock.Proxy.CompositeType.IsMethodVisible(System.Reflection.MethodInfo)">
      <summary>
            Filters out private methods.
            </summary>
      <param name="methodInfo">The method to test for visibility.</param>
      <returns>True if the method is not private, otherwise false.</returns>
    </member>
    <member name="P:NMock.Proxy.CompositeType.PrimaryType">
      <summary>
            Gets the 'primary' type we are mocking. This may be a class or an interface
            and will determine the proxy generation method that will be used.
            </summary>
    </member>
    <member name="P:NMock.Proxy.CompositeType.AdditionalInterfaceTypes">
      <summary>
            Gets any additional types to be mocked. These will always be interfaces.
            </summary>
    </member>
    <member name="P:NMock.Proxy.CompositeType.All">
      <summary>
            Gets all types of this instance.
            </summary>
    </member>
    <member name="M:NMock.Proxy.Castle.MockObjectInterceptor.#ctor(NMock.MockFactory,NMock.Proxy.CompositeType,System.String,NMock.MockStyle)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Proxy.Castle.MockObjectInterceptor" /> class.
            </summary>
      <param name="mockFactory">The mockFactory.</param>
      <param name="mockedType">Type of the mocked.</param>
      <param name="name">The name.</param>
      <param name="mockStyle">The mock style.</param>
    </member>
    <member name="T:NMock.Matchers.MethodNameMatcher">
      <summary>
            Matcher that checks whether the actual object is a <see cref="T:System.Reflection.MethodInfo" /> and its name is equal to the expected name.
            </summary>
    </member>
    <member name="M:NMock.Matchers.MethodNameMatcher.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Matchers.MethodNameMatcher" /> class.
            </summary>
      <param name="methodName">The expected name of the method.</param>
    </member>
    <member name="M:NMock.Matchers.MethodNameMatcher.#ctor(System.String,System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Matchers.MethodNameMatcher" /> class with a method name and declaring type
            </summary>
      <param name="methodName">
      </param>
      <param name="declaringType">
      </param>
    </member>
    <member name="M:NMock.Matchers.MethodNameMatcher.Matches(System.Object)">
      <summary>
            Matches the specified object to this matcher and returns whether it matches.
            </summary>
      <param name="o">The MethodInfo to match.</param>
      <returns>Whether the object is a MethodInfo and its name matches the expected one.</returns>
    </member>
    <member name="T:NMock.Matchers.MethodMatcher">
      <summary>
            Matcher that checks whether the actual object is a <see cref="T:System.Reflection.MethodInfo" /> and its signature matches the expected signature.
            </summary>
    </member>
    <member name="M:NMock.Matchers.MethodMatcher.#ctor(System.Reflection.MethodInfo)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Matchers.MethodMatcher" /> class.
            </summary>
      <param name="methodInfo">The expected method reference.</param>
    </member>
    <member name="M:NMock.Matchers.MethodMatcher.Matches(System.Object)">
      <summary>
            Matches the specified object to this matcher and returns whether it matches.
            </summary>
      <param name="o">The MethodInfo to match.</param>
      <returns>Whether the object is a MethodInfo and its name matches the expected one.</returns>
    </member>
    <member name="T:NMock.Syntax.IStubSyntax`1">
      <summary>
            Syntax methods that are used specifically for stubbing.
            </summary>
      <typeparam name="TInterface">
      </typeparam>
    </member>
    <member name="M:NMock.Syntax.IStubSyntax`1.Method(System.Linq.Expressions.Expression{System.Action{`0}})">
      <summary>
            Creates an expectation for the method specified when the method returns <see langword="void" />.
            The arguments are ignored, use the <see cref="T:NMock.Syntax.IAutoArgumentSyntax`1" /> result of this 
            method to specify the expected arguments.
            </summary>
      <param name="expression">A method call expression that specifies the expected method.</param>
      <returns>An instance of a class used to specify the parameters.</returns>
      <remarks>
        <note type="note">
            This overload is chosen by the compiler when the method specified in the <b>action</b> returns
            <see langword="void" />.
            </note>
        <note type="caution">
            An expectation created with this method will not use the parameters supplied to the method call.
            Parameters must be supplied in order for the code to compile.  Use the <see cref="M:NMock.Syntax.IArgumentSyntax.With(System.Object[])" /> or 
            <see cref="M:NMock.Syntax.IArgumentSyntax.WithAnyArguments" /> methods
            as part of the return type of this method.  As an alternative, use the <see cref="M:NMock.Syntax.IStubSyntax`1.MethodWith(System.Linq.Expressions.Expression{System.Action{`0}})" /> method which
            will use the parameters supplied to the method as part of the expectation.
            </note>
        <note type="tip">
            The <see cref="M:NMock.Syntax.IActionSyntax.Will(NMock.IAction[])" /> method should not be used from this method.  This method
            is used for <see langword="void" /> return types, therefore a return expectation is not needed.
            </note>
      </remarks>
      <seealso cref="M:NMock.Syntax.IStubSyntax`1.MethodWith(System.Linq.Expressions.Expression{System.Action{`0}})" />
      <overloads>
            Creates an expectation for the method specified.
            </overloads>
      <example>
            In this example, the method returns void.
            <code>
            mock.Expects.One.Method(m=&gt;m.MethodName("IgnoredParam")).With("RealParam");
            </code></example>
    </member>
    <member name="M:NMock.Syntax.IStubSyntax`1.Method``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
      <summary>
            Creates an expectation that this method will be called.  The arguments are ignored, use the 
            <see cref="T:NMock.Syntax.IAutoArgumentSyntax`1" /> result of this method to specify the expected arguments.
            </summary>
      <param name="expression">A method call expression that specifies the expected method.</param>
      <returns>An <see cref="T:NMock.Syntax.IAutoArgumentSyntax`1" /> object used to specify expected arguments or return value.</returns>
      <example>
        <code>
            mock.Expects.One.Method(m=&gt;m.MethodName("", 3)).Will(Return.Value(true));
            mock.Expects.One.Method(m=&gt;m.MethodName()).WillReturn(7);
            </code>
      </example>
    </member>
    <member name="M:NMock.Syntax.IStubSyntax`1.MethodWith(System.Linq.Expressions.Expression{System.Action{`0}})">
      <summary>
            Creates an expectation for the method specified when the method returns <see langword="void" />.
            The arguments are used as the expected values.
            </summary>
      <param name="expression">A method call expression that specifies the expected method.</param>
      <returns>An instance of a class used to specify the parameters.</returns>
      <remarks>
        <note type="note">
            This overload is chosen by the compiler when the method specified in the <b>action</b> returns
            <see langword="void" />.
            </note>
        <note type="note">
            An expectation created with this method will use the parameters supplied to the method call.
            </note>
      </remarks>
      <overloads>
            Creates an expectation for the method specified.
            </overloads>
      <example>
            In this example, the method returns void.
            <code>
            mock.Expects.One.MethodWith(m=&gt;m.MethodName("RealParam"));
            </code></example>
    </member>
    <member name="M:NMock.Syntax.IStubSyntax`1.MethodWith``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
      <summary>
            Creates an expectation that this method will be called.  The arguments are used as the expected values.
            </summary>
      <param name="expression">A method call expression that specifies the expected method.</param>
      <returns>An <see cref="T:NMock.Syntax.IAutoActionSyntax`1" /> object used to specify the return value of the method.</returns>
    </member>
    <member name="M:NMock.Syntax.IStubSyntax`1.MethodWith``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},``0)">
      <summary>
            Creates an expectation that this method will be called.  The arguments are used as the expected values.
            </summary>
      <param name="expression">A method call expression that specifies the expected method.</param>
      <param name="returnValue">The value to be returned when the method is called.</param>
      <returns>An <see cref="T:NMock.Syntax.ICommentSyntax" /> object used to specify the explanation for the expectation.</returns>
      <remarks>Compare this method to other versions of this overloaded method in the See Also section.</remarks>
    </member>
    <member name="M:NMock.Syntax.IStubSyntax`1.GetProperty``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
      <summary>
            Creates an expectation that this property will be accessed.
            </summary>
      <typeparam name="TProperty">The property data type.</typeparam>
      <param name="expression">The expression to extract the property name.</param>
      <returns>An <see cref="T:NMock.Syntax.IAutoMatchSyntax`1" /> that can be used to set the return value.</returns>
    </member>
    <member name="M:NMock.Syntax.IStubSyntax`1.GetProperty``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},``0)">
      <summary>
            Creates an expectation that this property will be accessed and it should return the specified value.
            </summary>
      <typeparam name="TProperty">The property data type.</typeparam>
      <param name="expression">A lambda expression to extract the property name.</param>
      <param name="returnValue">The value to be returned when the property is accessed.</param>
      <returns>An object to add comments about this expectation.</returns>
      <remarks>
            Use this method as a shorthand to <see cref="M:NMock.Syntax.IStubSyntax`1.GetProperty``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})" />.
            It sacrifices syntactic sugar but reduces the number of characters to type.
            </remarks>
    </member>
    <member name="M:NMock.Syntax.IStubSyntax`1.DelegateBinding(System.Action{`0})">
      <summary>
            Creates an expectation that a <see cref="T:System.Delegate" /> will be bound to an event.  The type of binding will be infered from the use of += or -=.
            </summary>
      <param name="action">
      </param>
      <returns>
      </returns>
      <remarks>
            If a binding expectation uses <c>null</c>, any arguments will be allowed.
            If a binding references a specific <see cref="T:System.Delegate" />, the expectation will expect that delegate.
            </remarks>
    </member>
    <member name="M:NMock.Syntax.IStubSyntax`1.EventBinding(System.Action{`0})">
      <summary>
            Creates an expectation that an <see cref="T:System.EventHandler" /> will be bound.  The type of binding will be infered from the use of += or -=.
            </summary>
      <param name="action">A lambda expression: e =&gt; e.Event += null</param>
      <returns>
      </returns>
      <remarks>
            Use <see cref="M:NMock.Syntax.IStubSyntax`1.EventBinding``1(System.Action{`0})" /> to bind to <see cref="T:System.EventHandler`1" /> is used.
            </remarks>
    </member>
    <member name="M:NMock.Syntax.IStubSyntax`1.EventBinding``1(System.Action{`0})">
      <summary>
            Creates an expectation that an <see cref="T:System.EventHandler`1" /> will be bound.  The type of binding will be infered from the use of += or -=.
            </summary>
      <param name="action">A lambda expression: e =&gt; e.Event += null</param>
      <typeparam name="TEventArgs">The type of event args for the <see cref="T:System.EventHandler" /></typeparam>
      <returns>
      </returns>
    </member>
    <member name="T:NMock.MockFactory">
      <summary>
            Tracks the expectations created by its <see cref="T:NMock.Mock`1" />s and <see cref="T:NMock.Stub`1" />s.
            </summary>
      <remarks>
            The <b>MockFactory</b> is a main component of the NMock3 API.  It is used to create <see cref="T:NMock.Mock`1" />
            instances and <see cref="T:NMock.Stub`1" /> instances of a <see langword="class" /> or <see langword="interface" />.
            </remarks>
    </member>
    <member name="T:NMock.MockFactory.Popper">
      <summary>
            A popper pops an expectation ordering from the expectations stack on disposal.
            </summary>
    </member>
    <member name="M:NMock.MockFactory.Popper.#ctor(NMock.MockFactory,NMock.IExpectationList)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.MockFactory.Popper" /> class.
            </summary>
      <param name="mockFactory">The mockFactory.</param>
      <param name="previous">The previous.</param>
    </member>
    <member name="M:NMock.MockFactory.Popper.Dispose">
      <summary>
            Pops the expectation ordering from the stack.
            </summary>
    </member>
    <member name="F:NMock.MockFactory.currentMockObjectFactory">
      <summary>
            The mock object factory that is being used by this MockFactory instance.
            </summary>
    </member>
    <member name="F:NMock.MockFactory.stubMockStyleDictionary">
      <summary>
            Holds all mapping from mocks/types to mock styles.
            </summary>
    </member>
    <member name="F:NMock.MockFactory.resolveTypeDelegate">
      <summary>
            The delegate used to resolve the default type returned as return value in calls to mocks with stub behavior.
            </summary>
    </member>
    <member name="F:NMock.MockFactory.thrownUnexpectedInvocationException">
      <summary>
            If an unexpected invocation exception is thrown then it is stored here to re-throw it in the 
            <see cref="M:NMock.MockFactory.VerifyAllExpectationsHaveBeenMet" /> method - exception cannot be swallowed by tested code.
            </summary>
    </member>
    <member name="F:NMock.MockFactory.FirstIncompleteExpectationException">
      <summary>
            A field to store <see cref="T:System.Exception" />s if and Expectation is incomplete
            </summary>
    </member>
    <member name="F:NMock.MockFactory.expectations">
      <summary>
            Expectations at current nesting level.
            </summary>
    </member>
    <member name="M:NMock.MockFactory.#ctor">
      <summary>
            Creates a default <see cref="T:NMock.MockFactory" />.
            </summary>
      <remarks>
            Default <see cref="T:NMock.MockFactory" /> classes do not ignore unexpected incovations.
            </remarks>
    </member>
    <member name="M:NMock.MockFactory.CreateMock``1">
      <summary>
            Creates a <see cref="T:NMock.Mock`1" /> with all of the default values.
            </summary>
      <typeparam name="T">The type of mock to create.</typeparam>
      <returns>
      </returns>
    </member>
    <member name="M:NMock.MockFactory.CreateMock``1(System.String)">
      <summary>
            Creates a <see cref="T:NMock.Mock`1" /> with the specified name.
            </summary>
      <typeparam name="T">The type of mock to create.</typeparam>
      <param name="name">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NMock.MockFactory.CreateMock``1(NMock.MockStyle)">
      <summary>
            Creates a <see cref="T:NMock.Mock`1" /> with the specified <see cref="T:NMock.MockStyle" />.
            </summary>
      <typeparam name="T">The type of mock to create.</typeparam>
      <param name="mockStyle">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NMock.MockFactory.CreateMock``1(NMock.MockStyle,System.Type[])">
      <summary>
            Creates a <see cref="T:NMock.Mock`1" /> with the specified <see cref="T:NMock.MockStyle" /> and additional types.
            </summary>
      <typeparam name="T">The type of mock to create.</typeparam>
      <param name="mockStyle">
      </param>
      <param name="additionalTypesToMock">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NMock.MockFactory.CreateMock``1(System.String,NMock.MockStyle)">
      <summary>
            Creates a <see cref="T:NMock.Mock`1" /> with the specified name and <see cref="T:NMock.MockStyle" />.
            </summary>
      <typeparam name="T">The type of mock to create.</typeparam>
      <param name="name">
      </param>
      <param name="mockStyle">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NMock.MockFactory.CreateMock``1(System.Type[])">
      <summary>
            Creates a <see cref="T:NMock.Mock`1" /> of the primary type and the specified additional types
            </summary>
      <typeparam name="T">The type of mock to create.</typeparam>
      <param name="additionalTypesToMock">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NMock.MockFactory.CreateMock``1(System.Object[])">
      <summary>
            Creates a <see cref="T:NMock.Mock`1" /> with the specified constructor arguments.
            </summary>
      <typeparam name="T">The type of mock to create.</typeparam>
      <param name="constructorArguments">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NMock.MockFactory.CreateMock``1(NMock.IMockDefinition)">
      <summary>
            Creates a <see cref="T:NMock.Mock`1" /> instance.  Use the <see cref="T:NMock.DefinedAs" /> class as a parameter.
            </summary>
      <typeparam name="T">The type of mock to create.</typeparam>
      <param name="mockDefinition">
      </param>
      <returns>
      </returns>
      <remarks>
            This method gives the developer the most control when creating the mock because they can
            specify all parts of the mock definition.
            </remarks>
    </member>
    <member name="M:NMock.MockFactory.CreateMock``1(System.String,NMock.MockStyle,System.Type[],System.Object[])">
      <summary>
            Creates a <see cref="T:NMock.Mock`1" /> using the specified arguments.
            </summary>
      <typeparam name="T">The type of mock to create.</typeparam>
      <param name="name">
      </param>
      <param name="mockStyle">
      </param>
      <param name="additionalTypesToMock">
      </param>
      <param name="constructorArguments">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NMock.MockFactory.CreateInstance``1(NMock.IMockDefinition)">
      <summary>
            Creates a new dynamic mock of the specified type using the supplied definition.
            </summary>
      <typeparam name="TMockedType">The type to mock.</typeparam>
      <param name="definition">An <see cref="T:NMock.IMockDefinition" /> to create the mock from.</param>
      <returns>A dynamic mock for the specified type.</returns>
    </member>
    <member name="M:NMock.MockFactory.CreateInstance``1(System.String)">
      <summary>
            Creates a new dynamic mock of the specified type using the supplied definition.
            </summary>
      <typeparam name="TMockedType">The type to mock.</typeparam>
      <param name="name">The name of the mock.</param>
      <returns>A dynamic mock for the specified type.</returns>
    </member>
    <member name="M:NMock.MockFactory.CreateInstance``1(System.Object[])">
      <summary>
            Creates a new dynamic mock of the specified type.
            </summary>
      <typeparam name="TMockedType">The type to mock.</typeparam>
      <param name="constructorArgs">The arguments for the constructor of the class to be mocked.
            Only applicable when mocking classes with non-default constructors.</param>
      <returns>A dynamic mock for the specified type.</returns>
    </member>
    <member name="M:NMock.MockFactory.CreateInstance``1(NMock.MockStyle,System.Object[])">
      <summary>
            Creates a new dynamic mock of the specified type.
            </summary>
      <typeparam name="TMockedType">The type to mock.</typeparam>
      <param name="mockStyle">Specifies how the mock object should behave when first created.</param>
      <param name="constructorArgs">The arguments for the constructor of the class to be mocked.
            Only applicable when mocking classes with non-default constructors.</param>
      <returns>A dynamic mock for the specified type.</returns>
    </member>
    <member name="M:NMock.MockFactory.Ordered">
      <summary>
            Gets a disposable object and tells the mockFactory that the following expectations are ordered, i.e. they have to be met in the specified order.
            Dispose the returned value to return to previous mode.
            </summary>
      <value>Disposable object. When this object is disposed then the ordered expectation mode is set back to the mode it was previously
            to call to <see cref="M:NMock.MockFactory.Ordered" />.</value>
    </member>
    <member name="M:NMock.MockFactory.Unordered">
      <summary>
            Gets a disposable object and tells the mockFactory that the following expectations are unordered, i.e. they can be met in any order.
            Dispose the returned value to return to previous mode.
            </summary>
      <value>Disposable object. When this object is disposed then the unordered expectation mode is set back to the mode it was previously
            to the call to <see cref="M:NMock.MockFactory.Unordered" />.</value>
    </member>
    <member name="M:NMock.MockFactory.Dispose">
      <summary>
            Disposes the mockFactory be verifying that all expectations were met.
            </summary>
    </member>
    <member name="M:NMock.MockFactory.SuppressUnexpectedAndUnmetExpectations">
      <summary>
            Suppresses when the factory would throw an exception on unmet or unexpected expectations until the next time
            VerifyAllExpectationsHaveBeenMet() is called.
            </summary>
    </member>
    <member name="M:NMock.MockFactory.ChangeDefaultMockObjectFactory(System.Type)">
      <summary>
            Allows the default <see cref="T:NMock.Proxy.IMockObjectFactory" /> to be replaced with a different implementation.
            </summary>
      <param name="factoryType">The System.Type of the <see cref="T:NMock.Proxy.IMockObjectFactory" /> implementation to use.
            This is expected to implement <see cref="T:NMock.Proxy.IMockObjectFactory" /> and have a default constructor.</param>
    </member>
    <member name="M:NMock.MockFactory.ChangeDefaultMockObjectFactory(NMock.Proxy.IMockObjectFactory)">
      <summary>
            Changes the current MockObjectFactory to a user defined one.
            </summary>
      <param name="factory">The new factory</param>
    </member>
    <member name="M:NMock.MockFactory.NewMock(System.Type,System.String,NMock.MockStyle,System.Object[])">
      <summary>
            Creates a new named dynamic mock of the specified type and allows the style
            of the mock to be specified.
            </summary>
      <param name="mockedType">The type to mock.</param>
      <param name="name">A name for the mock that will be used in error messages.</param>
      <param name="mockStyle">Specifies how the mock object should behave when first created.</param>
      <param name="constructorArgs">The arguments for the constructor of the class to be mocked.
            Only applicable when mocking classes with non-default constructors.</param>
      <returns>A named mock.</returns>
    </member>
    <member name="M:NMock.MockFactory.VerifyAllExpectationsHaveBeenMet(System.Boolean)">
      <summary>
            Verifies that all expectations have been met.
            Will be called in <see cref="M:NMock.MockFactory.Dispose" />, too. 
            </summary>
      <param name="rethrowThrownExceptions">A value indicating if exceptions that have already been thrown should be thrown again.</param>
    </member>
    <member name="M:NMock.MockFactory.VerifyAllExpectationsHaveBeenMet">
      <summary>
            Verifies that all expectations have been met.
            Will be called in <see cref="M:NMock.MockFactory.Dispose" />, too. 
            </summary>
    </member>
    <member name="M:NMock.MockFactory.SetResolveTypeHandler(NMock.ResolveTypeDelegate)">
      <summary>
            Sets the resolve type handler used to override default values returned by stubs.
            </summary>
      <param name="resolveTypeHandler">The resolve type handler.</param>
    </member>
    <member name="M:NMock.MockFactory.SetStubMockStyle(System.Object,NMock.MockStyle)">
      <summary>
            Sets the mock style used for all properties and methods returning a value of any type of the <paramref name="mock" />.
            Can be overridden with a type specific mock style with <see cref="M:NMock.MockFactory.SetStubMockStyle``1(System.Object,NMock.MockStyle)" />.
            </summary>
      <param name="mock">The mock (with mock style Stub).</param>
      <param name="nestedMockStyle">The nested mock style.</param>
    </member>
    <member name="M:NMock.MockFactory.SetStubMockStyle``1(System.Object,NMock.MockStyle)">
      <summary>
            Sets the mock style used for all properties and methods returning a value of type <typeparamref name="TStub" />
            of the <paramref name="mock" />.
            </summary>
      <typeparam name="TStub">The type of the stub.</typeparam>
      <param name="mock">The mock (with mock style Stub).</param>
      <param name="nestedMockStyle">The nested mock style.</param>
    </member>
    <member name="M:NMock.MockFactory.SetStubMockStyle(System.Object,System.Type,NMock.MockStyle)">
      <summary>
            Sets the mock style used for all properties and methods returning a value of type <paramref name="nestedMockType" />
            of the <paramref name="mock" />.
            </summary>
      <param name="mock">The mock (with mock style Stub).</param>
      <param name="nestedMockType">Type of the nested mock.</param>
      <param name="nestedMockStyle">The nested mock style.</param>
    </member>
    <member name="M:NMock.MockFactory.ClearExpectations(NMock.IMockObject)">
      <summary>
            Clears all expectation on the specified mock.
            </summary>
      <param name="mockObject">The mock for which all expectations are cleared.</param>
    </member>
    <member name="M:NMock.MockFactory.AddExpectation(NMock.IExpectation)">
      <summary>
            Adds the expectation.
            </summary>
      <param name="expectation">The expectation.</param>
    </member>
    <member name="M:NMock.MockFactory.ResolveType(System.Object,System.Type)">
      <summary>
            Resolves the return value to be used in a call to a mock with stub behavior.
            </summary>
      <param name="mock">The mock on which the call is made.</param>
      <param name="requestedType">The type of the return value.</param>
      <returns>The object to be returned as return value; or <see cref="F:System.Reflection.Missing.Value" />
            if the default value should be used.</returns>
    </member>
    <member name="M:NMock.MockFactory.GetDependencyMockStyle(System.Object,System.Type)">
      <summary>
            Gets the mock style to be used for a mock created for a return value of a call to mock with stub behavior.
            </summary>
      <param name="mock">The mock that wants to create a mock.</param>
      <param name="requestedType">The type of the requested mock.</param>
      <returns>The mock style to use on the created mock. Null if <see cref="F:NMock.MockStyle.Default" /> has to be used.</returns>
    </member>
    <member name="M:NMock.MockFactory.Dispatch(NMock.Monitoring.Invocation)">
      <summary>
            Dispatches the specified invocation.
            </summary>
      <param name="invocation">The invocation.</param>
    </member>
    <member name="M:NMock.MockFactory.HasExpectationFor(NMock.Monitoring.Invocation)">
      <summary>
            Determines whether there exist expectations for the specified invocation.
            </summary>
      <param name="invocation">The invocation.</param>
      <returns>
        <c>true</c> if there exist expectations for the specified invocation; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:NMock.MockFactory.CastToMockObject(System.Object)">
      <summary>
            Casts the argument to <see cref="T:NMock.IMockObject" />.
            </summary>
      <param name="mock">The object to cast.</param>
      <returns>The argument casted to <see cref="T:NMock.IMockObject" /></returns>
      <throws cref="T:System.ArgumentNullException">Thrown if <paramref name="mock" /> is null</throws>
      <throws cref="T:System.ArgumentException">Thrown if <paramref name="mock" /> is not a <see cref="T:NMock.IMockObject" /></throws>
    </member>
    <member name="M:NMock.MockFactory.ClearExpectations">
      <summary>
            Resets the state of the factory.
            </summary>
      <remarks>
            Use this method after expected exceptions.
            </remarks>
    </member>
    <member name="M:NMock.MockFactory.ClearException">
      <summary>
            Clears thrown unexpected exceptions so that a new exception will be thrown.
            </summary>
    </member>
    <member name="M:NMock.MockFactory.Push(NMock.IExpectationList)">
      <summary>
            Pushes the specified new ordering on the expectations stack.
            </summary>
      <param name="newOrdering">The new ordering.</param>
      <returns>Disposable popper.</returns>
    </member>
    <member name="M:NMock.MockFactory.Pop(NMock.IExpectationList)">
      <summary>
            Pops the specified old ordering from the expectations stack.
            </summary>
      <param name="oldOrdering">The old ordering.</param>
    </member>
    <member name="M:NMock.MockFactory.FailUnmetExpectations">
      <summary>
            Throws an exception listing all unmet expectations.
            </summary>
    </member>
    <member name="M:NMock.MockFactory.FailUnexpectedInvocation(NMock.Monitoring.Invocation)">
      <summary>
            Throws an exception indicating that the specified invocation is not expected.
            </summary>
      <param name="invocation">The invocation.</param>
    </member>
    <member name="T:NMock.ResolveTypeDelegate">
      <summary>
            Delegate used to override default type returned in stub behavior.
            </summary>
      <param name="mock">The mock that has to return a value.</param>
      <param name="requestedType">Type of the return value.</param>
      <returns>The object to return as return value for the requested type.</returns>
    </member>
    <member name="T:NMock.Matchers.IndexSetterArgumentsMatcher">
      <summary>
            Matcher for indexer setters. Checks that the arguments passed to the indexer match.
            </summary>
    </member>
    <member name="M:NMock.Matchers.IndexSetterArgumentsMatcher.#ctor(NMock.Matcher[])">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Matchers.IndexSetterArgumentsMatcher" /> class.
            </summary>
      <param name="valueMatchers">The value matchers. This is an ordered list of matchers, each matching a single method argument.</param>
    </member>
    <member name="M:NMock.Matchers.IndexSetterArgumentsMatcher.DescribeTo(System.IO.TextWriter)">
      <summary>
            Describes this matcher.
            </summary>
      <param name="writer">The text writer to which the description is added.</param>
    </member>
    <member name="T:NMock.Matchers.BinaryOperator">
      <summary>
            BinaryOperator is an abstract base class for matchers that combine two matchers into a single matcher. 
            </summary>
    </member>
    <member name="F:NMock.Matchers.BinaryOperator.Left">
      <summary>
            The left hand side of the binary operator.
            </summary>
    </member>
    <member name="F:NMock.Matchers.BinaryOperator.Right">
      <summary>
            The right hand side of the binary operator.
            </summary>
    </member>
    <member name="M:NMock.Matchers.BinaryOperator.#ctor(NMock.Matcher,NMock.Matcher)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Matchers.BinaryOperator" /> class.
            </summary>
      <param name="left">The left operand.</param>
      <param name="right">The right operand.</param>
    </member>
    <member name="T:NMock.Extensions">
      <summary>
            This class contains extension methods to support other classes.
            </summary>
    </member>
    <member name="M:NMock.Extensions.Times(System.Int32)">
      <summary>
            Returns a string representing grammatically correctness of n times depending on the value of <paramref name="count" />.
            </summary>
      <param name="count">An integer value representing n times.</param>
      <returns>The string ' time' or ' times'.</returns>
    </member>
    <member name="M:NMock.Extensions.DefaultNameFor(System.Type)">
      <summary>
            Returns the default name for a type that is used to name mocks.
            </summary>
      <param name="type">The type to get the default name for.</param>
      <returns>Default name for the specified type.</returns>
    </member>
    <member name="M:NMock.Extensions.FirstLowerCaseChar(System.String)">
      <summary>
            Finds the first lower case char in the specified string.
            </summary>
      <param name="s">The string to inspect.</param>
      <returns>the first lower case char in the specified string.</returns>
    </member>
    <member name="T:NMock.Properties.Resources">
      <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
    </member>
    <member name="P:NMock.Properties.Resources.ResourceManager">
      <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
    </member>
    <member name="P:NMock.Properties.Resources.Culture">
      <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
    </member>
    <member name="T:NMock.Matchers.ListMatcher">
      <summary>
            Used by NMock framework to make sure two lists are equal.
            </summary>
    </member>
    <member name="M:NMock.Matchers.ListMatcher.#ctor(System.Collections.IList)">
      <summary>
            Constructor
            </summary>
      <param name="sourceList">The list containing the expected results.</param>
    </member>
    <member name="M:NMock.Matchers.ListMatcher.Matches(System.Object)">
      <summary>
            Called by NMock to verify o corresponds to the source list.
            </summary>
      <param name="o">List to compare against the source list for equality.</param>
      <returns>True: the two lists have the same number of items and their items are equal.</returns>
    </member>
    <member name="M:NMock.Matchers.ListMatcher.DescribeTo(System.IO.TextWriter)">
      <summary>
            Describes this matcher.
            </summary>
      <param name="writer">The text writer to which the description is added.</param>
    </member>
    <member name="T:NMock.Matchers.AndMatcher">
      <summary>
            Matcher that is the logical and combination of two matchers.
            </summary>
    </member>
    <member name="M:NMock.Matchers.AndMatcher.#ctor(NMock.Matcher,NMock.Matcher)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Matchers.AndMatcher" /> class.
            </summary>
      <param name="left">The left operand.</param>
      <param name="right">The right operand.</param>
    </member>
    <member name="M:NMock.Matchers.AndMatcher.Matches(System.Object)">
      <summary>
            Matches the specified object to this matcher and returns whether it matches.
            </summary>
      <param name="o">The object to match.</param>
      <returns>Returns whether the object matches.</returns>
    </member>
    <member name="M:NMock.Matchers.AndMatcher.DescribeTo(System.IO.TextWriter)">
      <summary>
            Describes this matcher.
            </summary>
      <param name="writer">The text writer to which the description is added.</param>
    </member>
    <member name="T:NMock.Syntax.IMethodSyntax`1">
      <summary>
            Contains the methods that define the expectation for either a property, method, or event.
            </summary>
      <typeparam name="TInterface">The interface or class being mocked.</typeparam>
      <remarks>
            This interface defines generic methods that take lambda expressions.
            </remarks>
    </member>
    <member name="M:NMock.Syntax.IMethodSyntax`1.SetProperty``1(System.Func{`0,``0})">
      <summary>
            Creates an expectation that this property will be set to a value specified in the 
            <see cref="T:NMock.Syntax.IAutoValueSyntax`1" /> result of this method.  The value used in the expression
            is ignored.
            </summary>
      <typeparam name="TProperty">
      </typeparam>
      <param name="expression">A set property expression that specifies the property to be set.</param>
      <remarks>
            If the property specified in the expression has a getter, a value isn't required in the expression.
            <code>
            mock.Expects.One.SetProperty(p =&gt; p.Prop)
            </code>
            instead of
            <code>
            mock.Expects.One.SetProperty(p =&gt; p.Prop = "Ignored Value")
            </code>
            The code above only needs to be used in cases where the property is write-only.
            </remarks>
      <returns>
      </returns>
    </member>
    <member name="M:NMock.Syntax.IMethodSyntax`1.SetPropertyTo(System.Action{`0})">
      <summary>
            Creates an expectation that this property will be set to the specified value.
            </summary>
      <param name="action">z =&gt; z.prop = 0</param>
      <returns>An <see cref="T:NMock.Syntax.ICommentSyntax" /> object to specify the comment for the expectation. </returns>
    </member>
    <member name="T:NMock.Mock`1">
      <summary>
            This class represents a mock object of an interface or class.  To create a <see cref="T:NMock.Mock`1" />, 
            use a <see cref="T:NMock.MockFactory" />.
            </summary>
      <typeparam name="T">The type to mock.</typeparam>
      <example>
        <code>
            
            public class TestClass
            {
            	public void TestMethod()
            	{
            		MockFactory factory = new MockFactory();
            		Mock&lt;ISample&gt; mock = factory.CreateMock&lt;ISample&gt;();
            
            		//create an expectation that the property Prop will be set to 3
            		mock.Expects.One.SetPropertyTo(m=&gt;m.Prop=3);
            
            		new Driver(mock.MockObject).Drive(3);
            	}
            }
            
            public interface ISample
            {
            	int Prop {get; set;}
            }
            
            public class Driver
            {
            	public Driver(ISample sample)
            	{
            		Sample = sample;
            	}
            	public int Sample {get;set;}
            	public void Drive(int value)
            	{
            		Sample.Prop = value;
            	}
            }
            
            </code>
      </example>
    </member>
    <member name="M:NMock.Mock`1.#ctor(System.Object,NMock.MockFactory)">
      <summary>
      </summary>
      <param name="proxy">
      </param>
      <param name="factory">
      </param>
      <exception cref="T:System.ArgumentNullException" />
    </member>
    <member name="M:NMock.Mock`1.As``1">
      <summary>
            Duck Typing method: Returns a <see cref="T:NMock.Mock`1" /> instance of the type being specified in <typeparamref name="TType" />.
            </summary>
      <typeparam name="TType">
      </typeparam>
      <returns>
      </returns>
      <remarks>This method will not throw an exception if the cast is not successful.  It will return null.  Use <c cref="M:NMock.Mock`1.As``1(System.Boolean)" /> to specify if an exception should be thrown.</remarks>
    </member>
    <member name="M:NMock.Mock`1.As``1(System.Boolean)">
      <summary>
            Duck Typing method: Returns a <see cref="T:NMock.Mock`1" /> instance of the type being specified in <typeparamref name="TType" />.
            </summary>
      <typeparam name="TType">
      </typeparam>
      <param name="throwException">
      </param>
      <returns>
      </returns>
      <exception cref="T:System.InvalidCastException">
      </exception>
      <remarks>Use this method to specify if an exception should be thrown when a cast is not valid.</remarks>
    </member>
    <member name="M:NMock.Mock`1.ToString">
      <summary>
            Overriden ToString method that throws an exception when called so that the deloper does not
            confuse this ToString with the ToString of the <see cref="P:NMock.Mock`1.MockObject" /> property.
            </summary>
      <returns>The name of the <see cref="T:NMock.Mock`1" /></returns>
      <seealso cref="P:NMock.Mock`1.ThrowToStringException" />
    </member>
    <member name="M:NMock.Mock`1.ClearExpectations">
      <summary>
            Clears all expectations of this mock.
            </summary>
      <remarks>
            Use this method to clear expectations in a test before the test cleanup runs
            to avoid unmet expectations.  It is useful when testing error conditions.
            </remarks>
    </member>
    <member name="P:NMock.Mock`1.MockObject">
      <summary>
            An object of type <typeparamref name="T" /> to be used whenever the Mocked object is needed.
            </summary>
      <remarks>
            This property provides access to the proxy that is mocking the actual type.  Use this property
            when a reference to an object that is of the mocked type is needed.
            </remarks>
      <example>
            This example shows how a presenter needs arguments of the right type during construction.  The
            <c>MockObject</c> property is used because the presenter can't be instantiated with a <see cref="T:NMock.Mock`1" />
            argument.
            <code>
            interface IView { ... }
            interface IModel { ... }
            
            Mock&lt;IView&gt; view = factory.CreateMock&lt;IView&gt;();
            Mock&lt;IModel&gt; view = factory.CreateMock&lt;IModel&gt;();
            
            Presenter p = new Presenter(view.MockObject, model.MockObject);
            </code></example>
    </member>
    <member name="P:NMock.Mock`1.Expects">
      <summary>
            A syntax property used to access members that specify the number of times an expectation could occur.
            </summary>
      <remarks>This would be considered to be the main property of a <see cref="T:NMock.Mock`1" /> class.  This property
            provides access to all other expectation setup methods.</remarks>
      <example>
            In this example:
            <list type="bullet"><item><term><c>mock</c></term><description>is an instance of a <see cref="T:NMock.Mock`1" />.</description></item><item><term><c>Expects</c></term><description>refers to this property.</description></item><item><term><c>One</c></term><description>is the number of times this action is expected.</description></item><item><term><c>SetPropertyTo</c></term><description>is the type of expection.  <see cref="M:NMock.Syntax.IMethodSyntax`1.SetPropertyTo(System.Action{`0})" /> means the mock expects a property to be set to a value.</description></item><item><term><c>m</c></term><description>is the variable in our anonymous method that represents the mocked interface or class.</description></item><item><term><c>Prop</c></term><description>is the property on the mocked interface or class that the expectation is for.  It will be set to the value 3.</description></item></list><code>
            
            //create an expectation that the property Prop will be set to 3
            mock.Expects.One.SetPropertyTo(m=&gt;m.Prop=3);
            
            </code>
            View more of this code in the <see cref="T:NMock.Mock`1" /> example.
            </example>
    </member>
    <member name="P:NMock.Mock`1.Stub">
      <summary>
            A syntax property that returns a <see cref="T:NMock.Stub`1" /> class to stub out a member on the Mock.
            </summary>
    </member>
    <member name="P:NMock.Mock`1.IgnoreUnexpectedInvocations">
      <summary>
            Gets or sets a value indicating if this <see cref="T:NMock.Mock`1" /> should ignore unexpected invocations to properties, methods, or events.
            </summary>
      <remarks>
            Use the property to have a Mock ignore calls with no expectations.  By default, this works fine for property setters, void methods,
            and events.  Property getters and non-void methods will need to indicate how they will be implemented as they <i>need</i> to return
            a value.
            </remarks>
    </member>
    <member name="P:NMock.Mock`1.ThrowToStringException">
      <summary>
            Gets or sets a value indicating if an exception should be thrown when the <see cref="M:NMock.Mock`1.ToString" /> is called.
            </summary>
    </member>
    <member name="P:NMock.Mock`1.Name">
      <summary>
            Returns the name of the underlying proxy
            </summary>
    </member>
    <member name="T:NMock.Matchers.CallbackMatcher`1">
      <summary>
            A matcher that stores a delegate to call back to later.
            </summary>
      <typeparam name="T">Typically a <see cref="T:System.Action" />, <see cref="T:System.Predicate`1" />, <see cref="T:System.Func`1" />, or their equivalents.</typeparam>
    </member>
    <member name="M:NMock.Matchers.CallbackMatcher`1.Matches(System.Object)">
      <summary>
            Determines if the parameter is the same type as <typeparamref name="T" />.
            </summary>
      <param name="o">The value the matcher will evaluate.</param>
      <returns>A value indicating if the parameter matches or not.</returns>
    </member>
    <member name="M:NMock.Matchers.CallbackMatcher`1.DescribeTo(System.IO.TextWriter)">
      <summary>
            Describes this matcher.
            </summary>
      <param name="writer">The text writer to which the description is added.</param>
    </member>
    <member name="P:NMock.Matchers.CallbackMatcher`1.Callback">
      <summary>
            Gets a reference to the callback assigned during the matching operation of the expectation.
            </summary>
    </member>
    <member name="T:NMock.Actions.CollectAction`1">
      <summary>
            Action that calls the collect delegate passed to constructor with the n-th element of the arguments to an invocation.
            </summary>
      <typeparam name="T">Type of the argument to collect.</typeparam>
    </member>
    <member name="T:NMock.Actions.CollectAction`1.Collect">
      <summary>
            Delegate that is called on collecting an argument.
            </summary>
      <param name="collectedParameter">The collected generic parameter.</param>
    </member>
    <member name="F:NMock.Actions.CollectAction`1.argumentIndex">
      <summary>
            Stores the index of the argument.
            </summary>
    </member>
    <member name="F:NMock.Actions.CollectAction`1.collectDelegate">
      <summary>
            Stores the collect delegate.
            </summary>
    </member>
    <member name="M:NMock.Actions.CollectAction`1.#ctor(System.Int32,NMock.Actions.CollectAction{`0}.Collect)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Actions.CollectAction`1" /> class.
            </summary>
      <param name="argumentIndex">Index of the argument.</param>
      <param name="collectDelegate">The collect delegate.</param>
    </member>
    <member name="T:NMock.Throw">
      <summary>
            Defines action for throwing actions.
            </summary>
    </member>
    <member name="M:NMock.Throw.Exception(System.Exception)">
      <summary>
            Throws an exeception when the action is invoked.
            </summary>
      <param name="exception">The exception to throw when invoked.</param>
      <returns>Returns a new instance of the <see cref="T:NMock.Actions.ThrowAction" /> class.</returns>
    </member>
    <member name="T:NMock.Is">
      <summary>
            Provides shortcuts to <see cref="T:NMock.Matcher" />s.
            </summary>
    </member>
    <member name="F:NMock.Is.Anything">
      <summary>
            Matches anything.
            </summary>
    </member>
    <member name="F:NMock.Is.Nothing">
      <summary>
            Matches nothing.
            </summary>
    </member>
    <member name="F:NMock.Is.Null">
      <summary>
            Matches if the value is null.
            </summary>
    </member>
    <member name="F:NMock.Is.NotNull">
      <summary>
            Matches if the value is not null.
            </summary>
    </member>
    <member name="F:NMock.Is.Out">
      <summary>
            Matches out parameters of methods.
            </summary>
    </member>
    <member name="M:NMock.Is.EqualTo(System.Object)">
      <summary>
            Matches objects the are equal to the expected object.
            </summary>
      <param name="expected">The expected.</param>
      <returns>Returns a new instance of the <see cref="T:NMock.Matchers.EqualMatcher" /> class.</returns>
    </member>
    <member name="M:NMock.Is.Same(System.Object)">
      <summary>
            Matches an expected object.
            <seealso cref="M:NMock.Is.EqualTo(System.Object)" /></summary>
      <param name="expected">The expected object.</param>
      <returns>Returns a new instance of the <see cref="T:NMock.Matchers.EqualMatcher" /> class.</returns>
    </member>
    <member name="M:NMock.Is.ComparableTo(System.Object)">
      <summary>
            Matches objects that implement the <see cref="T:System.IComparable" /> interface.
            </summary>
      <param name="expected">The instance to be compared.</param>
      <returns>Returns a new instance of the <see cref="T:NMock.Matchers.ObjectMatcher" /> class.</returns>
    </member>
    <member name="M:NMock.Is.StringContaining(System.String)">
      <summary>
            Matches strings containing the specified <paramref name="substring" />.
            </summary>
      <param name="substring">The substring.</param>
      <returns>Returns a new instance of the <see cref="T:NMock.Matchers.StringContainsMatcher" /> class.</returns>
    </member>
    <member name="M:NMock.Is.GreaterThan(System.IComparable)">
      <summary>
            Matches objects that are greater than <paramref name="value" />.
            </summary>
      <param name="value">The value to compare.</param>
      <returns>Returns a new instance of the <see cref="T:NMock.Matchers.ComparisonMatcher" /> class.</returns>
    </member>
    <member name="M:NMock.Is.AtLeast(System.IComparable)">
      <summary>
            Matches objects that are at least equal to <paramref name="value" />.
            </summary>
      <param name="value">The value to compare.</param>
      <returns>Returns a new instance of the <see cref="T:NMock.Matchers.ComparisonMatcher" /> class.</returns>
    </member>
    <member name="M:NMock.Is.LessThan(System.IComparable)">
      <summary>
            Matches objects less than <paramref name="value" />.
            </summary>
      <param name="value">The value to compare.</param>
      <returns>Returns a new instance of the <see cref="T:NMock.Matchers.ComparisonMatcher" /> class.</returns>
    </member>
    <member name="M:NMock.Is.AtMost(System.IComparable)">
      <summary>
            Matches objects that are less or equal to <paramref name="value" />.
            </summary>
      <param name="value">The value to compare.</param>
      <returns>Returns a new instance of the <see cref="T:NMock.Matchers.ComparisonMatcher" /> class.</returns>
    </member>
    <member name="M:NMock.Is.In(System.Collections.ICollection)">
      <summary>
            Matches objects in the specified collection.
            </summary>
      <param name="collection">The collection with objects to match.</param>
      <returns>Returns a new instance of the <see cref="T:NMock.Matchers.ElementMatcher" /> class.</returns>
    </member>
    <member name="M:NMock.Is.OneOf(System.Object[])">
      <summary>
            Matches objects in the specified elements.
            </summary>
      <param name="elements">The elements to match.</param>
      <returns>Returns a new instance of the <see cref="T:NMock.Matchers.ElementMatcher" /> class.</returns>
    </member>
    <member name="M:NMock.Is.TypeOf(System.Type)">
      <summary>
            Matches objects of the specified type.
            </summary>
      <param name="type">The type to match.</param>
      <returns>Returns a new instance of the <see cref="T:NMock.Matchers.TypeMatcher" /> class.</returns>
    </member>
    <member name="M:NMock.Is.TypeOf``1">
      <summary>
            Matches objects of the specified type.
            </summary>
      <typeparam name="T">The type to match.</typeparam>
      <returns>
            Returns a new instance of the <see cref="T:NMock.Matchers.TypeMatcher" /> class.
            </returns>
    </member>
    <member name="M:NMock.Is.Match``1(System.Predicate{``0})">
      <summary>
            Matches objects against the specified expression.
            </summary>
      <typeparam name="T">Type of the value to match.</typeparam>
      <param name="expression">The match expression.</param>
      <returns>returns a new instance of the <see cref="T:NMock.Matchers.PredicateMatcher`1" />.</returns>
    </member>
    <member name="T:NMock.Syntax.IArgumentSyntax">
      <summary>
            Syntax for defining expected arguments of a method call.
            </summary>
    </member>
    <member name="M:NMock.Syntax.IArgumentSyntax.With(System.Object[])">
      <summary>
            Defines the arguments that are expected on the method call.
            </summary>
      <param name="expectedArguments">The expected arguments.</param>
      <returns>Matcher syntax.</returns>
      <remarks>
            The specified arguments are converted to <see chref="EqualMatcher" />s.  Matchers
            as well as non-Matchers can be used interchangably in the method.
            </remarks>
    </member>
    <member name="M:NMock.Syntax.IArgumentSyntax.WithNoArguments">
      <summary>
            Defines that no arguments are expected on the method call.
            </summary>
      <returns>Matcher syntax.</returns>
    </member>
    <member name="M:NMock.Syntax.IArgumentSyntax.WithAnyArguments">
      <summary>
            Defines that any arguments are allowed on the method call.
            </summary>
      <returns>Matcher syntax.</returns>
    </member>
    <member name="M:NMock.Syntax.IArgumentSyntax.WithArguments(NMock.Matcher[])">
      <summary>
            Defines matching criteria for arguments.
            </summary>
      <param name="argumentMatchers">A list of matchers to match the arguments of a method.</param>
      <returns>Matcher syntax.</returns>
      <remarks>
            The matchers will be automatically wrapped in an ArgumentsMatcher.
            </remarks>
    </member>
    <member name="M:NMock.Internal.ExpectationBuilder.IndexSetterBuilder.#ctor(NMock.Internal.BuildableExpectation,NMock.Internal.ExpectationBuilder)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Internal.ExpectationBuilder.IndexSetterBuilder" /> class.
            </summary>
      <param name="expectation">The expectation.</param>
      <param name="builder">The builder.</param>
    </member>
    <member name="M:NMock.Internal.ExpectationBuilder.PropertyValueBuilder.#ctor(NMock.Internal.ExpectationBuilder)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Internal.ExpectationBuilder.PropertyValueBuilder" /> class.
            </summary>
      <param name="builder">The builder.</param>
    </member>
    <member name="F:NMock.Internal.ExpectationBuilder.UsingMethodWith">
      <summary>
            A flag that specifies if the expectation was set up using 'MethodWith' in which case an ExpectationException is not thrown
            when the method takes no arguments.
            </summary>
    </member>
    <member name="M:NMock.Internal.ExpectationBuilder.#ctor(System.String,NMock.Matcher,NMock.Matcher,System.Object)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Internal.ExpectationBuilder" /> class.
            </summary>
      <param name="description">The description.</param>
      <param name="requiredCountMatcher">The required count matcher.</param>
      <param name="matchingCountMatcher">The matching count matcher.</param>
      <param name="proxy">
      </param>
    </member>
    <member name="M:NMock.Internal.ExpectationBuilder.With(System.Object[])">
      <summary>
            Defines the arguments that are expected on the method call.
            </summary>
      <param name="expectedArguments">The expected arguments.</param>
      <returns>Matcher syntax.</returns>
    </member>
    <member name="M:NMock.Internal.ExpectationBuilder.WithNoArguments">
      <summary>
            Defines that no arguments are expected on the method call.
            </summary>
      <returns>Matcher syntax.</returns>
    </member>
    <member name="M:NMock.Internal.ExpectationBuilder.WithAnyArguments">
      <summary>
            Defines that all arguments are allowed on the method call.
            </summary>
      <returns>Matcher syntax.</returns>
    </member>
    <member name="M:NMock.Internal.ExpectationBuilder.Matching(NMock.Matcher)">
      <summary>
            Defines a matching criteria.
            </summary>
      <param name="matcher">The matcher.</param>
      <returns>
            Action syntax defining the action to take.
            </returns>
    </member>
    <member name="M:NMock.Internal.ExpectationBuilder.Will(NMock.IAction[])">
      <summary>
            Defines what will happen.
            </summary>
      <param name="actions">The actions to take.</param>
      <returns>
            Returns the comment syntax defined after will.
            </returns>
    </member>
    <member name="M:NMock.Internal.ExpectationBuilder.Comment(System.String)">
      <summary>
            Adds a comment for the expectation that is added to the error message if the expectation is not met.
            </summary>
      <param name="comment">The comment that is shown in the error message if this expectation is not met.
            You can describe here why this expectation has to be met.</param>
    </member>
    <member name="M:NMock.Internal.ExpectationBuilder.ProtectedMethod(System.String)">
      <summary>
            Methods the specified method name.
            </summary>
      <param name="methodName">Name of the method.</param>
      <returns>
      </returns>
    </member>
    <member name="M:NMock.Internal.ExpectationBuilder.Method(NMock.Matcher)">
      <summary>
            Defines a method.
            </summary>
      <param name="methodMatcher">Matcher for matching the method on an invocation.</param>
      <returns>
            Argument syntax defining the arguments of the method.
            </returns>
    </member>
    <member name="M:NMock.Internal.ExpectationBuilder.GetProperty(System.String)">
      <summary>
            Gets the property.
            </summary>
      <param name="propertyName">Name of the property.</param>
      <returns>
      </returns>
    </member>
    <member name="M:NMock.Internal.ExpectationBuilder.SetProperty(System.String)">
      <summary>
            Sets the property.
            </summary>
      <param name="propertyName">Name of the property.</param>
      <returns>
      </returns>
    </member>
    <member name="M:NMock.Internal.ExpectationBuilder.On(NMock.IMockObject)">
      <summary>
            Defines the receiver.
            </summary>
      <param name="receiver">The dynamic mock on which the expectation or stub is applied.</param>
      <returns>Method syntax defining the method, property or event.</returns>
    </member>
    <member name="M:NMock.Internal.ExpectationBuilder.ArgumentMatchers(System.Object[])">
      <summary>
            Converts the object array into a List of matchers.
            </summary>
      <param name="expectedArguments">The expected arguments.</param>
      <returns>
      </returns>
    </member>
    <member name="M:NMock.Internal.ExpectationBuilder.EnsureMatchingMethodExistsOnMock(NMock.Matcher,System.String)">
      <summary>
            Ensures the matching method exists on mock.
            </summary>
      <param name="methodMatcher">The method matcher.</param>
      <param name="methodDescription">The method description.</param>
    </member>
    <member name="T:NMock.Collect">
      <summary>
            Gather information about invocations.
            </summary>
    </member>
    <member name="M:NMock.Collect.MethodArgument``1(System.Int32,NMock.Actions.CollectAction{``0}.Collect)">
      <summary>
            Calls the specified <paramref name="collectDelegate" /> with the method argument at index <paramref name="argumentIndex" />.
            Can only be used as action of an expectation on a method call.
            </summary>
      <typeparam name="TArgument">The type of the argument.</typeparam>
      <param name="argumentIndex">Index of the argument.</param>
      <param name="collectDelegate">The collect delegate.</param>
      <returns>Action that collects a method argument.</returns>
    </member>
    <member name="M:NMock.Collect.PropertyValue``1(NMock.Actions.CollectAction{``0}.Collect)">
      <summary>
            Calls the specified <paramref name="collectDelegate" /> with the value that is set to the property.
            Can only be used as action of an expectation on a property setter. 
            </summary>
      <typeparam name="TValue">The type of the value.</typeparam>
      <param name="collectDelegate">The collect delegate.</param>
      <returns>Action that collects a property value.</returns>
    </member>
    <member name="T:NMock.DefinedAs">
      <summary>
            Defines the initial characteristics of a new mock object.
            This is normally used in conjunction with <see cref="M:NMock.MockFactory.CreateMock``1(NMock.IMockDefinition)" /></summary>
    </member>
    <member name="M:NMock.DefinedAs.Implementing``1">
      <summary>
            Specifies a type that this mock should implement. This may be a class or interface,
            but there can only be a maximum of one class implemented by a mock.
            </summary>
      <typeparam name="T">The type to implement.</typeparam>
      <returns>The mock object definition.</returns>
    </member>
    <member name="M:NMock.DefinedAs.Implementing(System.Type[])">
      <summary>
            Specifies the types that this mock should implement. These may be a class or interface,
            but there can only be a maximum of one class implemented by a mock.
            </summary>
      <param name="types">The types to implement.</param>
      <returns>The mock object definition.</returns>
    </member>
    <member name="M:NMock.DefinedAs.OfStyle(NMock.MockStyle)">
      <summary>
            Specifies how the mock object should behave when first created.
            </summary>
      <param name="mockStyle">A MockStyle value.</param>
      <returns>The mock object definition.</returns>
    </member>
    <member name="M:NMock.DefinedAs.WithArgs(System.Object[])">
      <summary>
            Specifies the arguments for the constructor of the class to be mocked.
            Only applicable when mocking a class with a non-default constructor.
            </summary>
      <param name="args">The arguments for the class constructor.</param>
      <returns>The mock object definition.</returns>
    </member>
    <member name="M:NMock.DefinedAs.Named(System.String)">
      <summary>
            Specifies a name for the mock. This will be used in error messages,
            and as the return value of ToString() if not mocking a class.
            </summary>
      <param name="name">The name for the mock.</param>
      <returns>The mock object definition.</returns>
    </member>
    <member name="P:NMock.DefinedAs.Default">
      <summary>
            Returns a default implementation of <see cref="T:NMock.Syntax.IMockDefinitionSyntax" />.
            </summary>
    </member>
    <member name="T:NMock.Actions.DelegateAction">
      <summary>
            Action that executes the delegate passed to the constructor.
            </summary>
    </member>
    <member name="T:NMock.Actions.DelegateAction.Handler">
      <summary>
            Delegate that is executed on invocation of the action.
            </summary>
    </member>
    <member name="F:NMock.Actions.DelegateAction._handler">
      <summary>
            Stores the handler of the delegate action.
            </summary>
    </member>
    <member name="M:NMock.Actions.DelegateAction.#ctor(NMock.Actions.DelegateAction.Handler)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Actions.DelegateAction" /> class.
            </summary>
      <param name="actionHandler">The action handler.</param>
    </member>
    <member name="T:NMock.That">
      <summary>
            A syntax class to setup expectations on methods when they throw exceptions.
            </summary>
    </member>
    <member name="M:NMock.That.#ctor(System.Action)">
      <summary>
            Creates an instance of this class specifying the action that will throw an exception
            </summary>
      <param name="action">
      </param>
    </member>
    <member name="M:NMock.That.Throws">
      <summary>
            Indicates that this method will throw an <see cref="T:System.Exception" />.
            </summary>
    </member>
    <member name="M:NMock.That.Throws(NMock.Matcher[])">
      <summary>
            Indicates that this method will throw an <see cref="T:System.Exception" />.
            </summary>
      <param name="matchers">An array of matchers to match the exception string.</param>
    </member>
    <member name="M:NMock.That.Throws(System.String)">
      <summary>
            Indicates that this method will throw an <see cref="T:System.Exception" />.
            </summary>
      <param name="comment">A description of the reason for this expectation.</param>
    </member>
    <member name="M:NMock.That.Throws(System.String,NMock.Matcher[])">
      <summary>
            Indicates that this method will throw an <see cref="T:System.Exception" />.
            </summary>
      <param name="comment">A description of the reason for this expectation.</param>
      <param name="matchers">An array of matchers to match the exception string.</param>
    </member>
    <member name="M:NMock.That.Throws``1">
      <summary>
            Indicates that this method will throw an <see cref="T:System.Exception" />.
            </summary>
      <typeparam name="T">The type of <see cref="T:System.Exception" /> to throw.</typeparam>
    </member>
    <member name="M:NMock.That.Throws``1(System.String)">
      <summary>
            Indicates that this method will throw an <see cref="T:System.Exception" />.
            </summary>
      <typeparam name="T">The type of <see cref="T:System.Exception" /> to throw.</typeparam>
      <param name="comment">A description of the reason for this expectation.</param>
    </member>
    <member name="M:NMock.That.Throws``1(NMock.Matcher[])">
      <summary>
            Indicates that this method will throw an <see cref="T:System.Exception" />.
            </summary>
      <typeparam name="T">The type of <see cref="T:System.Exception" /> to throw.</typeparam>
      <param name="matchers">An array of matchers to match the exception string.</param>
    </member>
    <member name="M:NMock.That.Throws``1(System.String,NMock.Matcher[])">
      <summary>
            Indicates that this method will throw an <see cref="T:System.Exception" />.
            </summary>
      <typeparam name="T">The type of <see cref="T:System.Exception" /> to throw.</typeparam>
      <param name="comment">A description of the reason for this expectation.</param>
      <param name="matchers">An array of matchers to match the exception string.</param>
    </member>
    <member name="T:NMock.Expects`1">
      <summary>
            This syntax class contains <see cref="T:NMock.Syntax.IMethodSyntax`1" /> properties that control
            the number of expectations added for the referenced <see cref="T:NMock.Mock`1" />.
            </summary>
      <typeparam name="T">The <c>class</c> or <c>interface</c> that is being mocked.</typeparam>
      <remarks>
        <see cref="T:NMock.Expects`1" /> is the return type of the main property used on a <see cref="T:NMock.Mock`1" /> instance.  You
            access it by typing <c>mockObject.Expects</c>.<para>The <see cref="T:NMock.Expects`1" /> class provides access to
            all other methods that help create expectations.</para></remarks>
    </member>
    <member name="M:NMock.Expects`1.#ctor(System.Object)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Expects`1" /> class with the specified type as the template.
            </summary>
      <param name="proxy">
      </param>
    </member>
    <member name="M:NMock.Expects`1.AtLeast(System.Int32)">
      <summary>
            Creates an expectation for at least <c>count</c> number of calls for the referenced member.
            </summary>
      <param name="count">The minimum number of calls expect</param>
      <returns>An <see cref="T:NMock.Syntax.IMethodSyntax`1" /> to reference the expected call.</returns>
    </member>
    <member name="M:NMock.Expects`1.AtMost(System.Int32)">
      <summary>
            Creates an expectation for at most <c>count</c> number of calls for the referenced member.
            </summary>
      <param name="count">The maximum number of calls expect</param>
      <returns>An <see cref="T:NMock.Syntax.IMethodSyntax`1" /> to reference the expected call.</returns>
    </member>
    <member name="M:NMock.Expects`1.Between(System.Int32,System.Int32)">
      <summary>
            Creates an expectation for a range from <c>minCount</c> to <c>maxCount</c> number of calls for the referenced member.
            </summary>
      <param name="minCount">The minimum number of expected calls.</param>
      <param name="maxCount">The maximum number of expected calls.</param>
      <returns>An <see cref="T:NMock.Syntax.IMethodSyntax`1" /> to reference the expected call.</returns>
    </member>
    <member name="M:NMock.Expects`1.Exactly(System.Int32)">
      <summary>
            Creates an expectation for exactly <c>count</c> number of calls for the referenced member.
            </summary>
      <param name="count">The exact number of calls expect</param>
      <returns>An <see cref="T:NMock.Syntax.IMethodSyntax`1" /> to reference the expected call.</returns>
    </member>
    <member name="P:NMock.Expects`1.AtLeastOne">
      <summary>
            Creates an expectation for at least one call of the referenced member.
            </summary>
    </member>
    <member name="P:NMock.Expects`1.AtMostOnce">
      <summary>
            Creates an expectation for at most one call of the referenced member.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:NMock.Expects`1.AtMostOne">
      <summary>
            Creates an expectation for at most one call of the referenced member.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:NMock.Expects`1.No">
      <summary>
            Specifies that there should be no calls to the referenced member.
            </summary>
    </member>
    <member name="P:NMock.Expects`1.One">
      <summary>
            Creates an expectation for one call of the referenced member.
            </summary>
    </member>
    <member name="T:NMock.Matchers.FieldMatcher">
      <summary>
            Matcher that checks whether the specified field of the actual object matches with the specified matcher. 
            </summary>
    </member>
    <member name="F:NMock.Matchers.FieldMatcher.fieldName">
      <summary>
            Name of the field to match against the <seealso cref="F:NMock.Matchers.FieldMatcher.valueMatcher" />.
            </summary>
    </member>
    <member name="F:NMock.Matchers.FieldMatcher.valueMatcher">
      <summary>
            The value <see cref="T:NMock.Matcher" /> used to match the field of the object under investigation.
            </summary>
    </member>
    <member name="M:NMock.Matchers.FieldMatcher.#ctor(System.String,NMock.Matcher)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Matchers.FieldMatcher" /> class.
            </summary>
      <param name="fieldName">Name of the field to match against the <paramref name="valueMatcher" />.</param>
      <param name="valueMatcher">The value matcher.</param>
    </member>
    <member name="M:NMock.Matchers.FieldMatcher.Matches(System.Object)">
      <summary>
            Matches the specified object to this matcher and returns whether it matches.
            </summary>
      <param name="o">The object to match.</param>
      <returns>Whether the object matches.</returns>
    </member>
    <member name="M:NMock.Matchers.FieldMatcher.DescribeTo(System.IO.TextWriter)">
      <summary>
            Describes this matcher.
            </summary>
      <param name="writer">The text writer to which the description is added.</param>
    </member>
    <member name="T:NMock.Matchers.ComparisonMatcher">
      <summary>
            Matcher that checks a value against upper and lower bounds.
            </summary>
    </member>
    <member name="F:NMock.Matchers.ComparisonMatcher.maxComparisonResult">
      <summary>
            Stores the maximum comparison result for a successful match.
            </summary>
    </member>
    <member name="F:NMock.Matchers.ComparisonMatcher.minComparisonResult">
      <summary>
            Stores the minimum comparison result for a successful match.
            </summary>
    </member>
    <member name="F:NMock.Matchers.ComparisonMatcher.value">
      <summary>
            Stores the value to be compared.
            </summary>
    </member>
    <member name="M:NMock.Matchers.ComparisonMatcher.#ctor(System.IComparable,System.Int32,System.Int32)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Matchers.ComparisonMatcher" /> class.
            </summary>
      <param name="value">The value to compare.</param>
      <param name="comparisonResult1">The first allowed comparison result (result of value.CompareTo(other)).</param>
      <param name="comparisonResult2">The second allowed comparison result (result of value.CompareTo(other)).</param>
      <exception cref="T:System.ArgumentException">Thrown when one value is -1 and the other is 1.</exception>
    </member>
    <member name="M:NMock.Matchers.ComparisonMatcher.Matches(System.Object)">
      <summary>
            Matches the specified object to this matcher and returns whether it matches.
            </summary>
      <param name="o">The object to match.</param>
      <returns>Whether the object compared to the value resulted in either of both specified comparison results.</returns>
    </member>
    <member name="M:NMock.Matchers.ComparisonMatcher.DescribeTo(System.IO.TextWriter)">
      <summary>
            Describes this matcher.
            </summary>
      <param name="writer">The text writer to which the description is added.</param>
    </member>
    <member name="T:NMock.Syntax.IAutoValueSyntax`1">
      <summary>
            Extends <see cref="T:NMock.Syntax.IValueSyntax" /> by adding other syntax methods.
            </summary>
    </member>
    <member name="M:NMock.Syntax.IAutoValueSyntax`1.ToAnything">
      <summary>
            Creates an expectation that this property can be set to any value.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NMock.Syntax.IAutoValueSyntax`1.To(`0)">
      <summary>
            Creates an expectation that the property will be set to this value.
            </summary>
      <param name="equalValue">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:NMock.Proxy.Castle.CastleMockObjectFactory">
      <summary>
            Class that creates mocks for interfaces and classes (virtual members only) using the
            Castle proxy generator.
            </summary>
    </member>
    <member name="F:NMock.Proxy.Castle.CastleMockObjectFactory.CachedProxyTypes">
      <summary>
            A collection of types
            </summary>
    </member>
    <member name="M:NMock.Proxy.Castle.CastleMockObjectFactory.#ctor">
      <summary>
            Initializes a new instance of a <see cref="T:NMock.Proxy.Castle.CastleMockObjectFactory" /></summary>
    </member>
    <member name="M:NMock.Proxy.Castle.CastleMockObjectFactory.#ctor(System.Boolean)">
      <summary>
            Initializes a new instance of a <see cref="T:NMock.Proxy.Castle.CastleMockObjectFactory" /></summary>
      <param name="usePersistentProxyBuilder">A value indicating if the ProxyBuilder should be persistent</param>
    </member>
    <member name="M:NMock.Proxy.Castle.CastleMockObjectFactory.CreateMock(NMock.MockFactory,NMock.Proxy.CompositeType,System.String,NMock.MockStyle,System.Object[])">
      <summary>
            Creates a mock of the specified type(s).
            </summary>
      <param name="mockFactory">The mockFactory used to create this mock instance.</param>
      <param name="typesToMock">The type(s) to include in the mock.</param>
      <param name="name">The name to use for the mock instance.</param>
      <param name="mockStyle">The behaviour of the mock instance when first created.</param>
      <param name="constructorArgs">Constructor arguments for the class to be mocked. Only valid if mocking a class type.</param>
      <returns>A mock instance of the specified type(s).</returns>
    </member>
    <member name="T:NMock.Actions.ReturnAction`1">
      <summary>
            Action that sets the result value on an invocation.
            </summary>
    </member>
    <member name="F:NMock.Actions.ReturnAction`1._result">
      <summary>
            Stores the result to set on the invocation as the return value.
            </summary>
    </member>
    <member name="M:NMock.Actions.ReturnAction`1.#ctor(`0)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Actions.ReturnAction" /> class.
            </summary>
      <param name="result">The result to set on the invocation as the return value.</param>
    </member>
    <member name="M:NMock.Actions.ReturnAction`1.Invoke(NMock.Monitoring.Invocation)">
      <summary>
            Invokes this object. Sets the result value of the invocation.
            </summary>
      <param name="invocation">The invocation.</param>
    </member>
    <member name="M:NMock.Actions.ReturnAction`1.DescribeTo(System.IO.TextWriter)">
      <summary>
            Describes this object.
            </summary>
      <param name="writer">The text writer the description is added to.</param>
    </member>
    <member name="P:NMock.Actions.ReturnAction`1.ReturnType">
      <summary>
            Gets the type of the template parameter <typeparamref name="T" />.
            </summary>
    </member>
    <member name="T:NMock.Actions.ReturnAction">
      <summary>
            Action that sets the result value on an invocation.
            </summary>
    </member>
    <member name="M:NMock.Actions.ReturnAction.#ctor(System.Object)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Actions.ReturnAction" /> class.
            </summary>
      <param name="result">The result to set on the invocation as the return value.</param>
    </member>
    <member name="T:NMock.Verify">
      <summary>
            Verify that a condition is met.
            </summary>
    </member>
    <member name="M:NMock.Verify.That(System.Object,NMock.Matcher,System.String,System.Object[])">
      <summary>
            Verifies that the <paramref name="actualValue" /> is matched by the <paramref name="matcher" />.
            </summary>
      <param name="actualValue">The actual value to match.</param>
      <param name="matcher">The matcher.</param>
      <param name="message">The error message.</param>
      <param name="formatArgs">The format args for the error message.</param>
      <exception cref="T:NMock.ExpectationException">Thrown if value does not match.</exception>
    </member>
    <member name="M:NMock.Verify.That(System.Object,NMock.Matcher)">
      <summary>
            Verifies that the <paramref name="actualValue" /> is matched by the <paramref name="matcher" />.
            </summary>
      <param name="actualValue">The actual value.</param>
      <param name="matcher">The matcher.</param>
      <exception cref="T:NMock.ExpectationException">Thrown if value does not match.</exception>
    </member>
    <member name="M:NMock.Verify.WriteDescriptionOfFailedMatch(System.IO.TextWriter,System.Object,NMock.Matcher)">
      <summary>
            Writes the description of a failed match to the specified <paramref name="writer" />.
            </summary>
      <param name="writer">The <see cref="T:System.IO.TextWriter" /> where the description is written to.</param>
      <param name="actualValue">The actual value to be written.</param>
      <param name="matcher">The matcher which is used for the expected value to be written.</param>
    </member>
    <member name="T:NMock.Return">
      <summary>
            Provides shortcuts to <see cref="T:NMock.IAction" />s that return values
            </summary>
    </member>
    <member name="M:NMock.Return.Value(System.Object)">
      <summary>
            Returns the specified value as an object.
            </summary>
      <param name="result">The value to return.</param>
      <returns>An action that returns the specified value.</returns>
    </member>
    <member name="M:NMock.Return.Value``1(``0)">
      <summary>
            Returns the specified value as a strongly-typed value.
            </summary>
      <param name="result">The value to return.</param>
      <returns>An action that returns the specified value.</returns>
    </member>
    <member name="M:NMock.Return.Value``1(System.Func{``0})">
      <summary>
            Calls a method that will provide the return value.
            </summary>
      <typeparam name="T">The type that needs to be returned.</typeparam>
      <param name="delegate">The method that will provide the return value. (anonymous or otherwise)</param>
      <returns>An action that will provide the return value.</returns>
    </member>
    <member name="M:NMock.Return.Value``1(System.Func{NMock.Monitoring.Invocation,``0})">
      <summary>
            Calls a method that will provide the return value.
            </summary>
      <typeparam name="T">The type that needs to be returned.</typeparam>
      <param name="delegate">The method that will provide the return value. (anonymous or otherwise)</param>
      <returns>An action that will provide the return value.</returns>
    </member>
    <member name="M:NMock.Return.Queue``1(System.Collections.Generic.Queue{``0})">
      <summary>
            Specifies a queue of return values to be used for each call to the expectation.
            </summary>
      <typeparam name="T">The type that needs to be returned.</typeparam>
      <param name="queue">The <see cref="M:NMock.Return.Queue``1(System.Collections.Generic.Queue{``0})" /> of items to be returned.</param>
      <returns>An action that will return one value each time the expectation is met.</returns>
    </member>
    <member name="M:NMock.Return.OutValue(System.String,System.Object)">
      <summary>
            Defines the value returned by an out parameter.
            </summary>
      <param name="parameterName">Name of the parameter.</param>
      <param name="value">The value to return.</param>
      <returns>Action defining the value of an out parameter.</returns>
    </member>
    <member name="M:NMock.Return.OutValue(System.Int32,System.Object)">
      <summary>
            Defines the value returned by an out parameter.
            </summary>
      <param name="parameterIndex">Index of the parameter.</param>
      <param name="value">The value to return.</param>
      <returns>Action defining the value of an out parameter.</returns>
    </member>
    <member name="T:NMock.GetArguments">
      <summary>
            short cut to initialize GetArgumentAction
            </summary>
    </member>
    <member name="M:NMock.GetArguments.WhenCalled(System.Action{NMock.Monitoring.ParameterList})">
      <summary>
            Create a GetArgumentAction to get arments of invoked method
            </summary>
      <param name="handler">delegate used to get argments of executed method</param>
      <returns>
      </returns>
    </member>
    <member name="T:NMock.Matchers.OrMatcher">
      <summary>
            Matcher that combines two matcher with a logically or.
            </summary>
    </member>
    <member name="M:NMock.Matchers.OrMatcher.#ctor(NMock.Matcher,NMock.Matcher)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Matchers.OrMatcher" /> class.
            </summary>
      <param name="left">The left operand.</param>
      <param name="right">The right operand.</param>
    </member>
    <member name="M:NMock.Matchers.OrMatcher.Matches(System.Object)">
      <summary>
            Matches the specified object to this matcher and returns whether it matches.
            </summary>
      <param name="o">The object to match.</param>
      <returns>Whether the object matches one of the two combined matchers.</returns>
    </member>
    <member name="M:NMock.Matchers.OrMatcher.DescribeTo(System.IO.TextWriter)">
      <summary>
            Describes this matcher.
            </summary>
      <param name="writer">The text writer to which the description is added.</param>
    </member>
    <member name="T:NMock.Matchers.GenericMethodTypeParametersMatcher">
      <summary>
            Matcher that checks whether parameters of a method match with the specified list of matchers.
            </summary>
    </member>
    <member name="F:NMock.Matchers.GenericMethodTypeParametersMatcher._typeMatchers">
      <summary>
            An ordered list of type <see cref="T:NMock.Matcher" />'s each matching a single method argument.
            </summary>
    </member>
    <member name="M:NMock.Matchers.GenericMethodTypeParametersMatcher.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Matchers.GenericMethodTypeParametersMatcher" /> class and specifies no generic types.
            </summary>
    </member>
    <member name="M:NMock.Matchers.GenericMethodTypeParametersMatcher.#ctor(NMock.Matcher[])">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Matchers.GenericMethodTypeParametersMatcher" /> class.
            </summary>
      <param name="typeMatchers">The value matchers. This is an ordered list of matchers, each matching a single method argument.</param>
    </member>
    <member name="M:NMock.Matchers.GenericMethodTypeParametersMatcher.#ctor(System.Type[])">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Matchers.GenericMethodTypeParametersMatcher" /> class and specifies the types to match.
            </summary>
      <param name="genericTypeParameters">The types to match.  (Typically a result of the <see cref="M:System.Reflection.MethodInfo.GetGenericArguments" /> method.</param>
    </member>
    <member name="M:NMock.Matchers.GenericMethodTypeParametersMatcher.Matches(System.Object)">
      <summary>
            Matches the specified object to this matcher and returns whether it matches.
            </summary>
      <param name="o">The object to match.</param>
      <returns>Whether the object is an <see cref="T:NMock.Monitoring.Invocation" /> and all method arguments match their corresponding matcher.</returns>
    </member>
    <member name="M:NMock.Matchers.GenericMethodTypeParametersMatcher.DescribeTo(System.IO.TextWriter)">
      <summary>
            Describes this matcher.
            </summary>
      <param name="writer">The text writer to which the description is added.</param>
    </member>
    <member name="M:NMock.Matchers.GenericMethodTypeParametersMatcher.WriteListOfMatchers(System.Int32,System.IO.TextWriter)">
      <summary>
            Writes the list of matchers to a <see cref="T:System.IO.TextWriter" />.
            </summary>
      <param name="listLength">Length of the list.</param>
      <param name="writer">The writer.</param>
    </member>
    <member name="M:NMock.Matchers.GenericMethodTypeParametersMatcher.MatchesTypes(System.Reflection.MethodInfo)">
      <summary>
            Determines whether the arguments of the invocation matches the initial arguments.
            </summary>
      <param name="methodInfo">The invocation to match against the initial arguments.</param>
      <returns>
            Returns true if invocation matches the initial arguments; false otherwise.
            </returns>
    </member>
    <member name="M:NMock.Matchers.GenericMethodTypeParametersMatcher.MatchesTypeValues(System.Reflection.MethodBase)">
      <summary>
            Determines whether all argument types of the generic method matches the invocation.
            </summary>
      <param name="methodInfo">The invocation to match against the initial argument types.</param>
      <returns>
            Returns true if invocation types matches the inital argument types; false otherwise.
            </returns>
    </member>
    <member name="T:NMock.Matchers.DescriptionOverride">
      <summary>
            Matcher that is used to change the description the wrapped matcher.
            </summary>
    </member>
    <member name="M:NMock.Matchers.DescriptionOverride.#ctor(System.String,NMock.Matcher)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Matchers.DescriptionOverride" /> class.
            </summary>
      <param name="description">The new description for the wrapped matcher.</param>
      <param name="otherMatcher">The matcher to wrap.</param>
    </member>
    <member name="M:NMock.Matchers.DescriptionOverride.Matches(System.Object)">
      <summary>
            Matches the specified object to this matcher and returns whether it matches.
            </summary>
      <param name="o">The object to match.</param>
      <returns>Whether the wrapped matcher matches.</returns>
    </member>
    <member name="P:NMock.Matchers.DescriptionOverride.WrappedMatcher">
      <summary>
            Stores the matcher to wrap.
            </summary>
    </member>
    <member name="T:NMock.Matchers.AlwaysMatcher">
      <summary>
            A matcher that will always or never match independent of the value matched but depending on how it is initialized.
            </summary>
    </member>
    <member name="M:NMock.Matchers.AlwaysMatcher.#ctor(System.Boolean,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Matchers.AlwaysMatcher" /> class.
            </summary>
      <param name="matches">if set to <c>true</c> the matcher will always match, otherwise it will never match.</param>
      <param name="description">The description which will be printed out when calling <see cref="M:NMock.Matcher.DescribeTo(System.IO.TextWriter)" />.</param>
    </member>
    <member name="M:NMock.Matchers.AlwaysMatcher.Matches(System.Object)">
      <summary>
            Matches the specified object to this matcher and returns whether it matches.
            </summary>
      <param name="o">The object to match.</param>
      <returns>Returns whether the object matches.</returns>
    </member>
    <member name="T:NMock.Actions.ResultSynthesizer">
      <summary>
            Responsible for handling the results of an invocation.
            </summary>
    </member>
    <member name="F:NMock.Actions.ResultSynthesizer.defaultResults">
      <summary>
            Stores the default results.
            </summary>
    </member>
    <member name="F:NMock.Actions.ResultSynthesizer._results">
      <summary>
            Stores the results.
            </summary>
    </member>
    <member name="M:NMock.Actions.ResultSynthesizer.SetResult(System.Type,System.Object)">
      <summary>
            Sets the result of the specified <paramref name="returnType" />.
            </summary>
      <param name="returnType">The type to be returned as a result.</param>
      <param name="result">The result to be set.</param>
    </member>
    <member name="M:NMock.Actions.ResultSynthesizer.NewEmptyArray(System.Type)">
      <summary>
            Gets a new the empty array of the specified <paramref name="arrayType" />.
            </summary>
      <param name="arrayType">Type of the array to be returned.</param>
      <returns>
            Returns a new empty array of the specified <paramref name="arrayType" />.
            </returns>
    </member>
    <member name="T:NMock.Actions.ThrowAction">
      <summary>
            Action that sets the exception of an invocation.
            </summary>
    </member>
    <member name="F:NMock.Actions.ThrowAction.exception">
      <summary>
            Stores the exception to be thrown.
            </summary>
    </member>
    <member name="M:NMock.Actions.ThrowAction.#ctor(System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Actions.ThrowAction" /> class.
            </summary>
      <param name="exception">The exception.</param>
    </member>
    <member name="T:NMock.Internal.StubMockStyleDictionary">
      <summary>
            Provides functionality to map stubs and specific types of a stub to mock styles.
            </summary>
    </member>
    <member name="T:NMock.Internal.StubMockStyleDictionary.Key">
      <summary>
            Key into the <see cref="F:NMock.Internal.StubMockStyleDictionary.mockStyleForType" /> dictionary.
            </summary>
    </member>
    <member name="M:NMock.Internal.StubMockStyleDictionary.Key.#ctor(NMock.IMockObject,System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Internal.StubMockStyleDictionary.Key" /> class.
            </summary>
      <param name="mock">The mock object.</param>
      <param name="nestedMockType">Type of the nested mock.</param>
    </member>
    <member name="M:NMock.Internal.StubMockStyleDictionary.Key.Equals(System.Object)">
      <summary>
            Whether this instance equals the specified other.
            </summary>
      <param name="other">The other to compare to.</param>
      <returns>A value indicating whether both instances are equal.</returns>
    </member>
    <member name="M:NMock.Internal.StubMockStyleDictionary.Key.Equals(NMock.Internal.StubMockStyleDictionary.Key)">
      <summary>
            Whether this instance equals the specified other.
            </summary>
      <param name="other">The other to compare to.</param>
      <returns>A value indicating whether both instances are equal.</returns>
    </member>
    <member name="M:NMock.Internal.StubMockStyleDictionary.Key.GetHashCode">
      <summary>
            Serves as a hash function for a particular type.
            </summary>
      <returns>
            A hash code for the current <see cref="T:System.Object" />.
            </returns>
    </member>
    <member name="P:NMock.Internal.StubMockStyleDictionary.Key.Mock">
      <summary>
            Gets the mock.
            </summary>
      <value>The mock object.</value>
    </member>
    <member name="P:NMock.Internal.StubMockStyleDictionary.Key.NestedMockType">
      <summary>
            Gets the type of the nested mock.
            </summary>
      <value>The type of the nested mock.</value>
    </member>
    <member name="F:NMock.Internal.StubMockStyleDictionary.mockStyleForStub">
      <summary>
            holds mappings from stub to mock style (holds for all types unless there is a mapping defined in <see cref="F:NMock.Internal.StubMockStyleDictionary.mockStyleForType" />.
            </summary>
    </member>
    <member name="F:NMock.Internal.StubMockStyleDictionary.mockStyleForType">
      <summary>
            holds mappings from stub.type to mock style.
            </summary>
    </member>
    <member name="P:NMock.Internal.StubMockStyleDictionary.Item(NMock.IMockObject)">
      <summary>
            Gets or sets the mock style for the specified mock.
            </summary>
      <param name="mock">the mock object</param>
      <value>mock style. null if no value defined.</value>
    </member>
    <member name="P:NMock.Internal.StubMockStyleDictionary.Item(NMock.IMockObject,System.Type)">
      <summary>
            Gets or sets the mock style for the specified mock and type.
            </summary>
      <param name="mock">the mock object</param>
      <param name="nestedMockType">the type of the nested mock.</param>
      <value>mock style. null if no value defined.</value>
    </member>
    <member name="T:NMock.Matchers.DelegateMatcher">
      <summary>
            Represents a delegate in an expectation that can be matched
            </summary>
    </member>
    <member name="M:NMock.Matchers.DelegateMatcher.#ctor(System.MulticastDelegate)">
      <summary>
            Initializes an instance of this class with a <see cref="T:System.MulticastDelegate" /> to match.
            </summary>
      <param name="delegate">
      </param>
    </member>
    <member name="M:NMock.Matchers.DelegateMatcher.Matches(System.Object)">
      <summary>
            Determines if this delegate matches the specified parameter
            </summary>
      <param name="o">The delegate to match</param>
      <returns>true if the delegates match, false if the object is null or does not match</returns>
    </member>
    <member name="T:NMock.ExpectationException">
      <summary>
            Exception representing an expectation exception.
            </summary>
    </member>
    <member name="M:NMock.ExpectationException.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.ExpectationException" /> class.
            </summary>
    </member>
    <member name="M:NMock.ExpectationException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.ExpectationException" /> class.
            </summary>
      <param name="message">The message.</param>
    </member>
    <member name="M:NMock.ExpectationException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.ExpectationException" /> class.
            </summary>
      <param name="message">The message.</param>
      <param name="innerException">The inner exception.</param>
    </member>
    <member name="M:NMock.ExpectationException.ToString">
      <summary>
            Creates and returns a string representation of the current exception.
            </summary>
      <returns>
            A string representation of the current exception.
            </returns>
    </member>
    <member name="T:NMock.UnexpectedInvocationException">
      <summary>
            Represents an unexpected action during the course of exercising a unit test
            </summary>
    </member>
    <member name="M:NMock.UnexpectedInvocationException.#ctor(NMock.MockFactory,NMock.Monitoring.Invocation,NMock.IExpectationList,System.String)">
      <summary>
            Constructs a <see cref="T:NMock.UnexpectedInvocationException" /> with the given parameters.
            </summary>
      <param name="factory">The MockFactory that threw this exception</param>
      <param name="invocation">The unexpected invocation</param>
      <param name="expectations">The expectations collection to describe</param>
      <param name="message">A message to help the user understand what was unexpected</param>
    </member>
    <member name="P:NMock.UnexpectedInvocationException.Message">
      <summary>
            Gets the exception's message
            </summary>
    </member>
    <member name="T:NMock.UnmetExpectationException">
      <summary>
            Represents an expectation that was not met after <see cref="M:NMock.MockFactory.VerifyAllExpectationsHaveBeenMet" /> has been called
            </summary>
    </member>
    <member name="M:NMock.UnmetExpectationException.#ctor(System.String)">
      <summary>
            Initializes the exception with a message
            </summary>
      <param name="message">
      </param>
    </member>
    <member name="M:NMock.UnmetExpectationException.#ctor(System.String,System.Exception)">
      <summary>
            Wraps an exception and provides a message
            </summary>
      <param name="message">
      </param>
      <param name="innerException">
      </param>
    </member>
    <member name="T:NMock.IncompleteExpectationException">
      <summary>
            Represents an expectation that was not completely filled out
            </summary>
    </member>
    <member name="M:NMock.IncompleteExpectationException.#ctor(System.String)">
      <summary>
            Initializes an exception with a message
            </summary>
      <param name="message">
      </param>
    </member>
    <member name="T:NMock.Constants">
      <summary>
            Defines public constants
            </summary>
    </member>
    <member name="F:NMock.Constants.InternalsVisibleToNMock">
      <summary>
            A string that represents the name and Public Key of the NMock assembly.
            </summary>
      <remarks>
            Use this field in your assembly when NMock needs access to internal types
            </remarks>
      <example>
            [assembly: InternalsVisibleTo(NMock.Constants.InternalsVisibleTo)]
            </example>
      <seealso cref="T:System.Runtime.CompilerServices.InternalsVisibleToAttribute" />
    </member>
    <member name="F:NMock.Constants.InternalsVisibleToDynamicProxy">
      <summary>
            A string that represents the name and Public Key of the DynamicProxyGenAssembly assembly.
            </summary>
      <remarks>
            Use this field in your assembly when NMock needs access to internal types
            </remarks>
      <example>
            [assembly: InternalsVisibleTo(NMock.Constants.InternalsVisibleTo)]
            </example>
      <seealso cref="T:System.Runtime.CompilerServices.InternalsVisibleToAttribute" />
    </member>
    <member name="F:NMock.Constants.NMockPublicKey">
      <summary>
            The NMock Public Key string.
            </summary>
      <remarks>
            This string is used internally to reference the public key.
            </remarks>
    </member>
    <member name="T:NMock.Actions.SignalAction">
      <summary>
            Action that signals an event.
            You can use this action to synchronize threads when an expectation is invoked.
            </summary>
    </member>
    <member name="F:NMock.Actions.SignalAction.signal">
      <summary>
            Stores the wait handle to be signalled.
            </summary>
    </member>
    <member name="M:NMock.Actions.SignalAction.#ctor(System.Threading.EventWaitHandle)">
      <summary>
            Initializes a new instance of the <see cref="T:NMock.Actions.SignalAction" /> class.
            </summary>
      <param name="signal">The signal.</param>
    </member>
    <member name="P:NMock.Actions.SignalAction.Signal">
      <summary>
            Gets the signal.
            You can use this signal to wait for this action beeing invoked.
            </summary>
      <value>The signal.</value>
    </member>
    <member name="T:Castle.Core.Pair`2">
      <summary>
            General purpose class to represent a standard pair of values. 
            </summary>
      <typeparam name="TFirst">Type of the first value</typeparam>
      <typeparam name="TSecond">Type of the second value</typeparam>
    </member>
    <member name="M:Castle.Core.Pair`2.#ctor(`0,`1)">
      <summary>
            Constructs a pair with its values
            </summary>
      <param name="first">
      </param>
      <param name="second">
      </param>
    </member>
    <member name="T:Castle.Core.Logging.ILoggerFactory">
      <summary>
              Manages the instantiation of <see cref="T:Castle.Core.Logging.ILogger" />s.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.ILoggerFactory.Create(System.Type)">
      <summary>
              Creates a new logger, getting the logger name from the specified type.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.ILoggerFactory.Create(System.String)">
      <summary>
              Creates a new logger.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.ILoggerFactory.Create(System.Type,Castle.Core.Logging.LoggerLevel)">
      <summary>
              Creates a new logger, getting the logger name from the specified type.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.ILoggerFactory.Create(System.String,Castle.Core.Logging.LoggerLevel)">
      <summary>
              Creates a new logger.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.AbstractLoggerFactory.GetConfigFile(System.String)">
      <summary>
              Gets the configuration file.
            </summary>
      <param name="fileName">i.e. log4net.config</param>
      <returns>
      </returns>
    </member>
    <member name="T:Castle.Core.Logging.NullLogFactory">
      <summary>
            NullLogFactory used when logging is turned off.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.NullLogFactory.Create(System.String)">
      <summary>
              Creates an instance of ILogger with the specified name.
            </summary>
      <param name="name">Name.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Core.Logging.NullLogFactory.Create(System.String,Castle.Core.Logging.LoggerLevel)">
      <summary>
              Creates an instance of ILogger with the specified name and LoggerLevel.
            </summary>
      <param name="name">Name.</param>
      <param name="level">Level.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.DynamicProxy.IProxyTargetAccessor.DynProxyGetTarget">
      <summary>
              Get the proxy target (note that null is a valid target!)
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.DynamicProxy.IProxyTargetAccessor.GetInterceptors">
      <summary>
              Gets the interceptors for the proxy
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.DynamicProxy.SilverlightExtensions.Extensions.IsNested(System.Type)">
      <summary>
            The silverlight System.Type is missing the IsNested property so this exposes similar functionality.
            </summary>
      <param name="type">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:Castle.DynamicProxy.IProxyBuilder">
      <summary>
              Abstracts the implementation of proxy type construction.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.IProxyBuilder.CreateClassProxyType(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)">
      <summary>
              Creates a proxy type for given <paramref name="classToProxy" />, implementing <paramref name="additionalInterfacesToProxy" />, using <paramref name="options" /> provided.
            </summary>
      <param name="classToProxy">The class type to proxy.</param>
      <param name="additionalInterfacesToProxy">Additional interface types to proxy.</param>
      <param name="options">The proxy generation options.</param>
      <returns>The generated proxy type.</returns>
      <remarks>
              Implementers should return a proxy type for the specified class and interfaces.
              Additional interfaces should be only 'mark' interfaces, that is, they should work like interface proxy without target. (See <see cref="M:Castle.DynamicProxy.IProxyBuilder.CreateInterfaceProxyTypeWithoutTarget(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)" /> method.)
            </remarks>
      <exception cref="T:Castle.DynamicProxy.Generators.GeneratorException">Thrown when <paramref name="classToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is a generic type definition.</exception>
      <exception cref="T:Castle.DynamicProxy.Generators.GeneratorException">Thrown when <paramref name="classToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is not public.
              Note that to avoid this exception, you can mark offending type internal, and define <see cref="T:System.Runtime.CompilerServices.InternalsVisibleToAttribute" /> 
              pointing to Castle Dynamic Proxy assembly, in assembly containing that type, if this is appropriate.</exception>
      <seealso cref="T:Castle.DynamicProxy.Generators.ClassProxyGenerator" />
    </member>
    <member name="M:Castle.DynamicProxy.IProxyBuilder.CreateInterfaceProxyTypeWithTarget(System.Type,System.Type[],System.Type,Castle.DynamicProxy.ProxyGenerationOptions)">
      <summary>
              Creates a proxy type that proxies calls to <paramref name="interfaceToProxy" /> members on <paramref name="targetType" />, implementing <paramref name="additionalInterfacesToProxy" />, using <paramref name="options" /> provided.
            </summary>
      <param name="interfaceToProxy">The interface type to proxy.</param>
      <param name="additionalInterfacesToProxy">Additional interface types to proxy.</param>
      <param name="targetType">Type implementing <paramref name="interfaceToProxy" /> on which calls to the interface members should be intercepted.</param>
      <param name="options">The proxy generation options.</param>
      <returns>The generated proxy type.</returns>
      <remarks>
              Implementers should return a proxy type for the specified interface that 'proceeds' executions to the specified target.
              Additional interfaces should be only 'mark' interfaces, that is, they should work like interface proxy without target. (See <see cref="M:Castle.DynamicProxy.IProxyBuilder.CreateInterfaceProxyTypeWithoutTarget(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)" /> method.)
            </remarks>
      <exception cref="T:Castle.DynamicProxy.Generators.GeneratorException">Thrown when <paramref name="interfaceToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is a generic type definition.</exception>
      <exception cref="T:Castle.DynamicProxy.Generators.GeneratorException">Thrown when <paramref name="interfaceToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is not public.
              Note that to avoid this exception, you can mark offending type internal, and define <see cref="T:System.Runtime.CompilerServices.InternalsVisibleToAttribute" /> 
              pointing to Castle Dynamic Proxy assembly, in assembly containing that type, if this is appropriate.</exception>
      <seealso cref="T:Castle.DynamicProxy.Generators.InterfaceProxyWithTargetGenerator" />
    </member>
    <member name="M:Castle.DynamicProxy.IProxyBuilder.CreateInterfaceProxyTypeWithTargetInterface(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)">
      <summary>
              Creates a proxy type for given <paramref name="interfaceToProxy" /> and <parmaref name="additionalInterfacesToProxy" /> that delegates all calls to the provided interceptors and allows interceptors to switch the actual target of invocation.
            </summary>
      <param name="interfaceToProxy">The interface type to proxy.</param>
      <param name="additionalInterfacesToProxy">Additional interface types to proxy.</param>
      <param name="options">The proxy generation options.</param>
      <returns>The generated proxy type.</returns>
      <remarks>
              Implementers should return a proxy type for the specified interface(s) that delegate all executions to the specified interceptors
              and uses an instance of the interface as their targets (i.e. <see cref="P:Castle.DynamicProxy.IInvocation.InvocationTarget" />), rather than a class. All <see cref="T:Castle.DynamicProxy.IInvocation" /> classes should then implement <see cref="T:Castle.DynamicProxy.IChangeProxyTarget" /> interface,
              to allow interceptors to switch invocation target with instance of another type implementing called interface.
            </remarks>
      <exception cref="T:Castle.DynamicProxy.Generators.GeneratorException">Thrown when <paramref name="interfaceToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is a generic type definition.</exception>
      <exception cref="T:Castle.DynamicProxy.Generators.GeneratorException">Thrown when <paramref name="interfaceToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is not public.
              Note that to avoid this exception, you can mark offending type internal, and define <see cref="T:System.Runtime.CompilerServices.InternalsVisibleToAttribute" /> 
              pointing to Castle Dynamic Proxy assembly, in assembly containing that type, if this is appropriate.</exception>
      <seealso cref="T:Castle.DynamicProxy.Generators.InterfaceProxyWithTargetInterfaceGenerator" />
    </member>
    <member name="M:Castle.DynamicProxy.IProxyBuilder.CreateInterfaceProxyTypeWithoutTarget(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)">
      <summary>
              Creates a proxy type for given <paramref name="interfaceToProxy" /> that delegates all calls to the provided interceptors.
            </summary>
      <param name="interfaceToProxy">The interface type to proxy.</param>
      <param name="additionalInterfacesToProxy">Additional interface types to proxy.</param>
      <param name="options">The proxy generation options.</param>
      <returns>The generated proxy type.</returns>
      <remarks>
              Implementers should return a proxy type for the specified interface and additional interfaces that delegate all executions to the specified interceptors.
            </remarks>
      <exception cref="T:Castle.DynamicProxy.Generators.GeneratorException">Thrown when <paramref name="interfaceToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is a generic type definition.</exception>
      <exception cref="T:Castle.DynamicProxy.Generators.GeneratorException">Thrown when <paramref name="interfaceToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is not public.
              Note that to avoid this exception, you can mark offending type internal, and define <see cref="T:System.Runtime.CompilerServices.InternalsVisibleToAttribute" /> 
              pointing to Castle Dynamic Proxy assembly, in assembly containing that type, if this is appropriate.</exception>
      <seealso cref="T:Castle.DynamicProxy.Generators.InterfaceProxyWithoutTargetGenerator" />
    </member>
    <member name="P:Castle.DynamicProxy.IProxyBuilder.Logger">
      <summary>
              Gets or sets the <see cref="T:Castle.Core.Logging.ILogger" /> that this <see cref="T:Castle.DynamicProxy.ProxyGenerator" /> logs to.
            </summary>
    </member>
    <member name="P:Castle.DynamicProxy.IProxyBuilder.ModuleScope">
      <summary>
              Gets the <see cref="P:Castle.DynamicProxy.IProxyBuilder.ModuleScope" /> associated with this builder.
            </summary>
      <value>The module scope associated with this builder.</value>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.IDynamicValue">
      <summary>
            Contract for dynamic value resolution.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.IDynamicValue`1">
      <summary>
            Contract for typed dynamic value resolution.
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="T:Castle.Core.Internal.AttributesUtil">
      <summary>
              Helper class for retrieving attributes.
            </summary>
    </member>
    <member name="M:Castle.Core.Internal.AttributesUtil.GetAttribute``1(System.Reflection.ICustomAttributeProvider)">
      <summary>
              Gets the attribute.
            </summary>
      <param name="member">The member.</param>
      <returns>The member attribute.</returns>
    </member>
    <member name="M:Castle.Core.Internal.AttributesUtil.GetAttributes``1(System.Reflection.ICustomAttributeProvider)">
      <summary>
              Gets the attributes. Does not consider inherited attributes!
            </summary>
      <param name="member">The member.</param>
      <returns>The member attributes.</returns>
    </member>
    <member name="M:Castle.Core.Internal.AttributesUtil.GetTypeAttribute``1(System.Type)">
      <summary>
              Gets the type attribute.
            </summary>
      <param name="type">The type.</param>
      <returns>The type attribute.</returns>
    </member>
    <member name="M:Castle.Core.Internal.AttributesUtil.GetTypeAttributes``1(System.Type)">
      <summary>
              Gets the type attributes.
            </summary>
      <param name="type">The type.</param>
      <returns>The type attributes.</returns>
    </member>
    <member name="M:Castle.Core.Internal.AttributesUtil.GetTypeConverter(System.Reflection.MemberInfo)">
      <summary>
              Gets the type converter.
            </summary>
      <param name="member">The member.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Core.Internal.AttributesUtil.HasAttribute``1(System.Reflection.ICustomAttributeProvider)">
      <summary>
              Gets the attribute.
            </summary>
      <param name="member">The member.</param>
      <returns>The member attribute.</returns>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.IDictionaryBehavior">
      <summary>
            Defines the contract for customizing dictionary access.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IDictionaryBehavior.Copy">
      <summary>
            Copies the dictionary behavior.
            </summary>
      <returns>null if should not be copied.  Otherwise copy.</returns>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.IDictionaryBehavior.ExecutionOrder">
      <summary>
            Determines relative order to apply related behaviors.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.IDictionaryKeyBuilder">
      <summary>
            Defines the contract for building typed dictionary keys.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IDictionaryKeyBuilder.GetKey(Castle.Components.DictionaryAdapter.IDictionaryAdapter,System.String,Castle.Components.DictionaryAdapter.PropertyDescriptor)">
      <summary>
            Builds the specified key.
            </summary>
      <param name="dictionaryAdapter">The dictionary adapter.</param>
      <param name="key">The current key.</param>
      <param name="property">The property.</param>
      <returns>The updated key</returns>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.IDictionaryEdit">
      <summary>
            Contract for editing the Dictionary adapter.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.IDictionaryNotify">
      <summary>
            Contract for managing Dictionary adapter notifications.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.IDictionaryValidate">
      <summary>
            Contract for validating Dictionary adapter.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.IDictionaryCreate">
      <summary>
            Contract for creating additional Dictionary adapters.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.IDictionaryAdapter">
      <summary>
            Contract for manipulating the Dictionary adapter.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.GroupAttribute">
      <summary>
            Assigns a property to a group.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.GroupAttribute.#ctor(System.Object)">
      <summary>
            Constructs a group assignment.
            </summary>
      <param name="group">The group name.</param>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.GroupAttribute.#ctor(System.Object[])">
      <summary>
            Constructs a group assignment.
            </summary>
      <param name="group">The group name.</param>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.GroupAttribute.Group">
      <summary>
            Gets the group the property is assigned to.
            </summary>
    </member>
    <member name="T:Castle.Core.Resource.IResource">
      <summary>
            Represents a 'streamable' resource. Can
            be a file, a resource in an assembly.
            </summary>
    </member>
    <member name="M:Castle.Core.Resource.IResource.GetStreamReader">
      <summary>
            Returns a reader for the stream
            </summary>
      <remarks>
            It's up to the caller to dispose the reader.
            </remarks>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Core.Resource.IResource.GetStreamReader(System.Text.Encoding)">
      <summary>
            Returns a reader for the stream
            </summary>
      <remarks>
            It's up to the caller to dispose the reader.
            </remarks>
      <param name="encoding">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Core.Resource.IResource.CreateRelative(System.String)">
      <summary>
            Returns an instance of <see cref="T:Castle.Core.Resource.IResource" />
            created according to the <c>relativePath</c>
            using itself as the root.
            </summary>
      <param name="relativePath">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:Castle.Core.Resource.IResource.FileBasePath">
      <summary>
      </summary>
      <remarks>
            Only valid for resources that
            can be obtained through relative paths
            </remarks>
    </member>
    <member name="T:Castle.Core.Resource.AbstractStreamResource">
      <summary>
      </summary>
    </member>
    <member name="F:Castle.Core.Resource.AbstractStreamResource.createStream">
      <summary>
            This returns a new stream instance each time it is called.
            It is the responsibility of the caller to dispose of this stream
            </summary>
    </member>
    <member name="T:Castle.DynamicProxy.Generators.Emitters.SimpleAST.IndirectReference">
      <summary>
              Wraps a reference that is passed 
              ByRef and provides indirect load/store support.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.Contributors.MembersCollector.AcceptMethod(System.Reflection.MethodInfo,System.Boolean,Castle.DynamicProxy.IProxyGenerationHook)">
      <summary>
              Performs some basic screening and invokes the <see cref="T:Castle.DynamicProxy.IProxyGenerationHook" />
              to select methods.
            </summary>
      <param name="method">
      </param>
      <param name="onlyVirtuals">
      </param>
      <param name="hook">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.IDictionaryValidator">
      <summary>
            Contract for dictionary validation.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IDictionaryValidator.IsValid(Castle.Components.DictionaryAdapter.IDictionaryAdapter)">
      <summary>
            Determines if <see cref="T:Castle.Components.DictionaryAdapter.IDictionaryAdapter" /> is valid.
            </summary>
      <param name="dictionaryAdapter">The dictionary adapter.</param>
      <returns>true if valid.</returns>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IDictionaryValidator.Validate(Castle.Components.DictionaryAdapter.IDictionaryAdapter)">
      <summary>
            Validates the <see cref="T:Castle.Components.DictionaryAdapter.IDictionaryAdapter" />.
            </summary>
      <param name="dictionaryAdapter">The dictionary adapter.</param>
      <returns>The error summary information.</returns>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IDictionaryValidator.Validate(Castle.Components.DictionaryAdapter.IDictionaryAdapter,Castle.Components.DictionaryAdapter.PropertyDescriptor)">
      <summary>
            Validates the <see cref="T:Castle.Components.DictionaryAdapter.IDictionaryAdapter" /> for a property.
            </summary>
      <param name="dictionaryAdapter">The dictionary adapter.</param>
      <param name="property">The property to validate.</param>
      <returns>The property summary information.</returns>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IDictionaryValidator.Invalidate(Castle.Components.DictionaryAdapter.IDictionaryAdapter)">
      <summary>
            Invalidates any results cached by the validator.
            </summary>
      <param name="dictionaryAdapter">The dictionary adapter.</param>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.IDictionaryAdapterFactory">
      <summary>
            Defines the contract for building typed dictionary adapters.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IDictionaryAdapterFactory.GetAdapter``1(System.Collections.IDictionary)">
      <summary>
            Gets a typed adapter bound to the <see cref="T:System.Collections.IDictionary" />.
            </summary>
      <typeparam name="T">The typed interface.</typeparam>
      <param name="dictionary">The underlying source of properties.</param>
      <returns>An implementation of the typed interface bound to the dictionary.</returns>
      <remarks>
            The type represented by T must be an interface with properties.
            </remarks>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IDictionaryAdapterFactory.GetAdapter(System.Type,System.Collections.IDictionary)">
      <summary>
            Gets a typed adapter bound to the <see cref="T:System.Collections.IDictionary" />.
            </summary>
      <param name="type">The typed interface.</param>
      <param name="dictionary">The underlying source of properties.</param>
      <returns>An implementation of the typed interface bound to the dictionary.</returns>
      <remarks>
            The type represented by T must be an interface with properties.
            </remarks>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IDictionaryAdapterFactory.GetAdapter(System.Type,System.Collections.IDictionary,Castle.Components.DictionaryAdapter.PropertyDescriptor)">
      <summary>
            Gets a typed adapter bound to the <see cref="T:System.Collections.IDictionary" />.
            </summary>
      <param name="type">The typed interface.</param>
      <param name="dictionary">The underlying source of properties.</param>
      <param name="descriptor">The property descriptor.</param>
      <returns>An implementation of the typed interface bound to the dictionary.</returns>
      <remarks>
            The type represented by T must be an interface with properties.
            </remarks>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IDictionaryAdapterFactory.GetAdapterMeta(System.Type)">
      <summary>
            Gets the <see cref="T:Castle.Components.DictionaryAdapter.DictionaryAdapterMeta" /> associated with the type.
            </summary>
      <param name="type">The typed interface.</param>
      <returns>The adapter meta-data.</returns>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IDictionaryAdapterFactory.GetAdapterMeta(System.Type,Castle.Components.DictionaryAdapter.PropertyDescriptor)">
      <summary>
            Gets the <see cref="T:Castle.Components.DictionaryAdapter.DictionaryAdapterMeta" /> associated with the type.
            </summary>
      <param name="type">The typed interface.</param>
      <param name="descriptor">The property descriptor.</param>
      <returns>The adapter meta-data.</returns>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IDictionaryAdapterFactory.GetAdapterMeta(System.Type,Castle.Components.DictionaryAdapter.DictionaryAdapterMeta)">
      <summary>
            Gets the <see cref="T:Castle.Components.DictionaryAdapter.DictionaryAdapterMeta" /> associated with the type.
            </summary>
      <param name="type">The typed interface.</param>
      <param name="other">Another <see cref="T:Castle.Components.DictionaryAdapter.DictionaryAdapterMeta" /> from which to copy behaviors.</param>
      <returns>The adapter meta-data.</returns>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.IDictionaryPropertyGetter">
      <summary>
            Defines the contract for retrieving dictionary values.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IDictionaryPropertyGetter.GetPropertyValue(Castle.Components.DictionaryAdapter.IDictionaryAdapter,System.String,System.Object,Castle.Components.DictionaryAdapter.PropertyDescriptor,System.Boolean)">
      <summary>
            Gets the effective dictionary value.
            </summary>
      <param name="dictionaryAdapter">The dictionary adapter.</param>
      <param name="key">The key.</param>
      <param name="storedValue">The stored value.</param>
      <param name="property">The property.</param>
      <param name="ifExists">true if return only existing.</param>
      <returns>The effective property value.</returns>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.DefaultPropertyGetter">
      <summary>
            Manages conversion between property values.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.DefaultPropertyGetter.#ctor(System.ComponentModel.TypeConverter)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Components.DictionaryAdapter.DefaultPropertyGetter" /> class.
            </summary>
      <param name="converter">The converter.</param>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.DefaultPropertyGetter.GetPropertyValue(Castle.Components.DictionaryAdapter.IDictionaryAdapter,System.String,System.Object,Castle.Components.DictionaryAdapter.PropertyDescriptor,System.Boolean)">
      <summary>
            Gets the effective dictionary value.
            </summary>
      <param name="dictionaryAdapter">The dictionary adapter.</param>
      <param name="key">The key.</param>
      <param name="storedValue">The stored value.</param>
      <param name="property">The property.</param>
      <param name="ifExists">true if return only existing.</param>
      <returns>The effective property value.</returns>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.DefaultPropertyGetter.ExecutionOrder">
      <summary>
      </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.DictionaryBehaviorAttribute">
      <summary>
            Assigns a specific dictionary key.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.IPropertyDescriptorInitializer">
      <summary>
             Contract for property descriptor initialization.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IPropertyDescriptorInitializer.Initialize(Castle.Components.DictionaryAdapter.PropertyDescriptor,System.Object[])">
      <summary>
            Performs any initialization of the <see cref="T:Castle.Components.DictionaryAdapter.PropertyDescriptor" /></summary>
      <param name="propertyDescriptor">The property descriptor.</param>
      <param name="behaviors">The property behaviors.</param>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.SuppressNotificationsAttribute">
      <summary>
            Suppress property change notifications.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.OnDemandAttribute">
      <summary>
            Support for on-demand value resolution.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerationOptions.#ctor(Castle.DynamicProxy.IProxyGenerationHook)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.DynamicProxy.ProxyGenerationOptions" /> class.
            </summary>
      <param name="hook">The hook.</param>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerationOptions.#ctor">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.DynamicProxy.ProxyGenerationOptions" /> class.
            </summary>
    </member>
    <member name="T:Castle.DynamicProxy.Contributors.ITypeContributor">
      <summary>
              Interface describing elements composing generated type
            </summary>
    </member>
    <member name="T:Castle.DynamicProxy.Generators.BaseProxyGenerator">
      <summary>
              Base class that exposes the common functionalities
              to proxy generation.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.BaseProxyGenerator.AddMappingNoCheck(System.Type,Castle.DynamicProxy.Contributors.ITypeContributor,System.Collections.Generic.IDictionary{System.Type,Castle.DynamicProxy.Contributors.ITypeContributor})">
      <summary>
              It is safe to add mapping (no mapping for the interface exists)
            </summary>
      <param name="implementer">
      </param>
      <param name="interface">
      </param>
      <param name="mapping">
      </param>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.BaseProxyGenerator.GenerateParameterlessConstructor(Castle.DynamicProxy.Generators.Emitters.ClassEmitter,System.Type,Castle.DynamicProxy.Generators.Emitters.SimpleAST.FieldReference)">
      <summary>
              Generates a parameters constructor that initializes the proxy
              state with <see cref="T:Castle.DynamicProxy.StandardInterceptor" /> just to make it non-null.
              <para>
                This constructor is important to allow proxies to be XML serializable
              </para></summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.KeySubstitutionAttribute">
      <summary>
            Substitutes part of key with another string.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.KeySubstitutionAttribute.#ctor(System.String,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Components.DictionaryAdapter.KeySubstitutionAttribute" /> class.
            </summary>
      <param name="oldValue">The old value.</param>
      <param name="newValue">The new value.</param>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.AbstractDictionaryAdapter">
      <summary>
            Abstract adapter for the <see cref="T:System.Collections.IDictionary" /> support
            needed by the <see cref="T:Castle.Components.DictionaryAdapter.DictionaryAdapterFactory" /></summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.AbstractDictionaryAdapter.Add(System.Object,System.Object)">
      <summary>
            Adds an element with the provided key and value to the <see cref="T:System.Collections.IDictionary"></see> object.
            </summary>
      <param name="key">The <see cref="T:System.Object"></see> to use as the key of the element to add.</param>
      <param name="value">The <see cref="T:System.Object"></see> to use as the value of the element to add.</param>
      <exception cref="T:System.ArgumentException">An element with the same key already exists in the <see cref="T:System.Collections.IDictionary"></see> object. </exception>
      <exception cref="T:System.ArgumentNullException">key is null. </exception>
      <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.IDictionary"></see> is read-only.-or- The <see cref="T:System.Collections.IDictionary"></see> has a fixed size. </exception>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.AbstractDictionaryAdapter.Clear">
      <summary>
            Removes all elements from the <see cref="T:System.Collections.IDictionary"></see> object.
            </summary>
      <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.IDictionary"></see> object is read-only. </exception>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.AbstractDictionaryAdapter.Contains(System.Object)">
      <summary>
            Determines whether the <see cref="T:System.Collections.IDictionary"></see> object contains an element with the specified key.
            </summary>
      <param name="key">The key to locate in the <see cref="T:System.Collections.IDictionary"></see> object.</param>
      <returns>
            true if the <see cref="T:System.Collections.IDictionary"></see> contains an element with the key; otherwise, false.
            </returns>
      <exception cref="T:System.ArgumentNullException">key is null. </exception>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.AbstractDictionaryAdapter.GetEnumerator">
      <summary>
            Returns an <see cref="T:System.Collections.IDictionaryEnumerator"></see> object for the <see cref="T:System.Collections.IDictionary"></see> object.
            </summary>
      <returns>
            An <see cref="T:System.Collections.IDictionaryEnumerator"></see> object for the <see cref="T:System.Collections.IDictionary"></see> object.
            </returns>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.AbstractDictionaryAdapter.Remove(System.Object)">
      <summary>
            Removes the element with the specified key from the <see cref="T:System.Collections.IDictionary"></see> object.
            </summary>
      <param name="key">The key of the element to remove.</param>
      <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.IDictionary"></see> object is read-only.-or- The <see cref="T:System.Collections.IDictionary"></see> has a fixed size. </exception>
      <exception cref="T:System.ArgumentNullException">key is null. </exception>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.AbstractDictionaryAdapter.CopyTo(System.Array,System.Int32)">
      <summary>
            Copies the elements of the <see cref="T:System.Collections.ICollection"></see> to an <see cref="T:System.Array"></see>, starting at a particular <see cref="T:System.Array"></see> index.
            </summary>
      <param name="array">The one-dimensional <see cref="T:System.Array"></see> that is the destination of the elements copied from <see cref="T:System.Collections.ICollection"></see>. The <see cref="T:System.Array"></see> must have zero-based indexing.</param>
      <param name="index">The zero-based index in array at which copying begins.</param>
      <exception cref="T:System.ArgumentNullException">array is null. </exception>
      <exception cref="T:System.ArgumentException">The type of the source <see cref="T:System.Collections.ICollection"></see> cannot be cast automatically to the type of the destination array. </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">index is less than zero. </exception>
      <exception cref="T:System.ArgumentException">array is multidimensional.-or- index is equal to or greater than the length of array.-or- The number of elements in the source <see cref="T:System.Collections.ICollection"></see> is greater than the available space from index to the end of the destination array. </exception>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.AbstractDictionaryAdapter.IsFixedSize">
      <summary>
            Gets a value indicating whether the <see cref="T:System.Collections.IDictionary"></see> object has a fixed size.
            </summary>
      <value>
      </value>
      <returns>true if the <see cref="T:System.Collections.IDictionary"></see> object has a fixed size; otherwise, false.</returns>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.AbstractDictionaryAdapter.IsReadOnly">
      <summary>
            Gets a value indicating whether the <see cref="T:System.Collections.IDictionary"></see> object is read-only.
            </summary>
      <value>
      </value>
      <returns>true if the <see cref="T:System.Collections.IDictionary"></see> object is read-only; otherwise, false.</returns>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.AbstractDictionaryAdapter.Keys">
      <summary>
            Gets an <see cref="T:System.Collections.ICollection"></see> object containing the keys of the <see cref="T:System.Collections.IDictionary"></see> object.
            </summary>
      <value>
      </value>
      <returns>An <see cref="T:System.Collections.ICollection"></see> object containing the keys of the <see cref="T:System.Collections.IDictionary"></see> object.</returns>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.AbstractDictionaryAdapter.Values">
      <summary>
            Gets an <see cref="T:System.Collections.ICollection"></see> object containing the values in the <see cref="T:System.Collections.IDictionary"></see> object.
            </summary>
      <value>
      </value>
      <returns>An <see cref="T:System.Collections.ICollection"></see> object containing the values in the <see cref="T:System.Collections.IDictionary"></see> object.</returns>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.AbstractDictionaryAdapter.Item(System.Object)">
      <summary>
            Gets or sets the <see cref="T:System.Object" /> with the specified key.
            </summary>
      <value>
      </value>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.AbstractDictionaryAdapter.Count">
      <summary>
            Gets the number of elements contained in the <see cref="T:System.Collections.ICollection"></see>.
            </summary>
      <value>
      </value>
      <returns>The number of elements contained in the <see cref="T:System.Collections.ICollection"></see>.</returns>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.AbstractDictionaryAdapter.IsSynchronized">
      <summary>
            Gets a value indicating whether access to the <see cref="T:System.Collections.ICollection"></see> is synchronized (thread safe).
            </summary>
      <value>
      </value>
      <returns>true if access to the <see cref="T:System.Collections.ICollection"></see> is synchronized (thread safe); otherwise, false.</returns>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.AbstractDictionaryAdapter.SyncRoot">
      <summary>
            Gets an object that can be used to synchronize access to the <see cref="T:System.Collections.ICollection"></see>.
            </summary>
      <value>
      </value>
      <returns>An object that can be used to synchronize access to the <see cref="T:System.Collections.ICollection"></see>.</returns>
    </member>
    <member name="T:Castle.Core.Resource.StaticContentResource">
      <summary>
            Adapts a static string content as an <see cref="T:Castle.Core.Resource.IResource" /></summary>
    </member>
    <member name="T:Castle.Core.Resource.IResourceFactory">
      <summary>
            Depicts the contract for resource factories.
            </summary>
    </member>
    <member name="M:Castle.Core.Resource.IResourceFactory.Accept(Castle.Core.Resource.CustomUri)">
      <summary>
            Used to check whether the resource factory
            is able to deal with the given resource
            identifier.
            </summary>
      <remarks>
            Implementors should return <c>true</c>
            only if the given identifier is supported
            by the resource factory
            </remarks>
      <param name="uri">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Core.Resource.IResourceFactory.Create(Castle.Core.Resource.CustomUri)">
      <summary>
            Creates an <see cref="T:Castle.Core.Resource.IResource" /> instance
            for the given resource identifier
            </summary>
      <param name="uri">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Core.Resource.IResourceFactory.Create(Castle.Core.Resource.CustomUri,System.String)">
      <summary>
            Creates an <see cref="T:Castle.Core.Resource.IResource" /> instance
            for the given resource identifier
            </summary>
      <param name="uri">
      </param>
      <param name="basePath">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:Castle.Core.Logging.IExtendedLoggerFactory">
      <summary>
              Provides a factory that can produce either <see cref="T:Castle.Core.Logging.ILogger" /> or
              <see cref="T:Castle.Core.Logging.IExtendedLogger" /> classes.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.IExtendedLoggerFactory.Create(System.Type)">
      <summary>
              Creates a new extended logger, getting the logger name from the specified type.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.IExtendedLoggerFactory.Create(System.String)">
      <summary>
              Creates a new extended logger.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.IExtendedLoggerFactory.Create(System.Type,Castle.Core.Logging.LoggerLevel)">
      <summary>
              Creates a new extended logger, getting the logger name from the specified type.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.IExtendedLoggerFactory.Create(System.String,Castle.Core.Logging.LoggerLevel)">
      <summary>
              Creates a new extended logger.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.MetaEvent.#ctor(System.String,System.Type,System.Type,Castle.DynamicProxy.Generators.MetaMethod,Castle.DynamicProxy.Generators.MetaMethod,System.Reflection.EventAttributes)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.DynamicProxy.Generators.MetaEvent" /> class.
            </summary>
      <param name="name">The name.</param>
      <param name="declaringType">Type declaring the original event being overriten, or null.</param>
      <param name="eventDelegateType">
      </param>
      <param name="adder">The add method.</param>
      <param name="remover">The remove method.</param>
      <param name="attributes">The attributes.</param>
    </member>
    <member name="T:Castle.DynamicProxy.Generators.Emitters.SimpleAST.NewArrayExpression">
      <summary>
              Summary description for NewArrayExpression.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.ICondition">
      <summary>
            Contract for value matching.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.IDictionaryBehaviorBuilder">
      <summary>
            Defines the contract for building <see cref="T:Castle.Components.DictionaryAdapter.IDictionaryBehavior" />s.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IDictionaryBehaviorBuilder.BuildBehaviors">
      <summary>
            Builds the dictionary behaviors.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.VolatileAttribute">
      <summary>
            Indicates that underlying values are changeable and should not be cached.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.FetchAttribute">
      <summary>
            Identifies an interface or property to be pre-fetched.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.FetchAttribute.#ctor">
      <summary>
            Instructs fetching to occur.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.FetchAttribute.#ctor(System.Boolean)">
      <summary>
            Instructs fetching according to <paramref name="fetch" /></summary>
      <param name="fetch">
      </param>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.FetchAttribute.Fetch">
      <summary>
            Gets whether or not fetching should occur.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.IDictionaryPropertySetter">
      <summary>
            Defines the contract for updating dictionary values.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IDictionaryPropertySetter.SetPropertyValue(Castle.Components.DictionaryAdapter.IDictionaryAdapter,System.String,System.Object@,Castle.Components.DictionaryAdapter.PropertyDescriptor)">
      <summary>
            Sets the stored dictionary value.
            </summary>
      <param name="dictionaryAdapter">The dictionary adapter.</param>
      <param name="key">The key.</param>
      <param name="value">The stored value.</param>
      <param name="property">The property.</param>
      <returns>true if the property should be stored.</returns>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.RemoveIfAttribute">
      <summary>
            Removes a property if matches value.
            </summary>
    </member>
    <member name="T:Castle.DynamicProxy.Generators.Emitters.LdindOpCodesDictionary">
      <summary>
              Provides appropriate Ldind.X opcode for 
              the type of primitive value to be loaded indirectly.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.Internal.TypeUtil.GetAllInterfaces(System.Type[])">
      <summary>
              Returns list of all unique interfaces implemented given types, including their base interfaces.
            </summary>
      <param name="types">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:Castle.DynamicProxy.IProxyGenerationHook">
      <summary>
              Used during the target type inspection process. Implementors have a chance to customize the
              proxy generation process.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.IProxyGenerationHook.MethodsInspected">
      <summary>
              Invoked by the generation process to notify that the whole process has completed.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.IProxyGenerationHook.NonProxyableMemberNotification(System.Type,System.Reflection.MemberInfo)">
      <summary>
              Invoked by the generation process to notify that a member was not marked as virtual.
            </summary>
      <param name="type">The type which declares the non-virtual member.</param>
      <param name="memberInfo">The non-virtual member.</param>
      <remarks>
              This method gives an opportunity to inspect any non-proxyable member of a type that has 
              been requested to be proxied, and if appropriate - throw an exception to notify the caller.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.IProxyGenerationHook.ShouldInterceptMethod(System.Type,System.Reflection.MethodInfo)">
      <summary>
              Invoked by the generation process to determine if the specified method should be proxied.
            </summary>
      <param name="type">The type which declares the given method.</param>
      <param name="methodInfo">The method to inspect.</param>
      <returns>True if the given method should be proxied; false otherwise.</returns>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.KeyPrefixAttribute">
      <summary>
            Assigns a prefix to the keyed properties of an interface.
            </summary>
      <remarks>
            Key prefixes are not inherited by sub-interfaces.
            </remarks>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.KeyPrefixAttribute.#ctor">
      <summary>
            Initializes a default instance of the <see cref="T:Castle.Components.DictionaryAdapter.KeyPrefixAttribute" /> class.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.KeyPrefixAttribute.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Components.DictionaryAdapter.KeyPrefixAttribute" /> class.
            </summary>
      <param name="keyPrefix">The prefix for the keyed properties of the interface.</param>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.KeyPrefixAttribute.KeyPrefix">
      <summary>
            Gets the prefix key added to the properties of the interface.
            </summary>
    </member>
    <member name="T:Castle.Core.Configuration.IConfiguration">
      <summary>
        <see cref="T:Castle.Core.Configuration.IConfiguration" /> is a interface encapsulating a configuration node
            used to retrieve configuration values.
            </summary>
    </member>
    <member name="M:Castle.Core.Configuration.IConfiguration.GetValue(System.Type,System.Object)">
      <summary>
            Gets the value of the node and converts it 
            into specified <see cref="T:System.Type" />.
            </summary>
      <param name="type">The <see cref="T:System.Type" /></param>
      <param name="defaultValue">
            The Default value returned if the conversion fails.
            </param>
      <returns>The Value converted into the specified type.</returns>
    </member>
    <member name="P:Castle.Core.Configuration.IConfiguration.Name">
      <summary>
            Gets the name of the node.
            </summary>
      <value>
            The Name of the node.
            </value>
    </member>
    <member name="P:Castle.Core.Configuration.IConfiguration.Value">
      <summary>
            Gets the value of the node.
            </summary>
      <value>
            The Value of the node.
            </value>
    </member>
    <member name="P:Castle.Core.Configuration.IConfiguration.Children">
      <summary>
            Gets an <see cref="T:Castle.Core.Configuration.ConfigurationCollection" /> of <see cref="T:Castle.Core.Configuration.IConfiguration" />
            elements containing all node children.
            </summary>
      <value>The Collection of child nodes.</value>
    </member>
    <member name="P:Castle.Core.Configuration.IConfiguration.Attributes">
      <summary>
            Gets an <see cref="T:System.Collections.IDictionary" /> of the configuration attributes.
            </summary>
    </member>
    <member name="T:Castle.Core.Configuration.AbstractConfiguration">
      <summary>
              This is an abstract <see cref="T:Castle.Core.Configuration.IConfiguration" /> implementation
              that deals with methods that can be abstracted away
              from underlying implementations.
            </summary>
      <remarks>
        <para>
          <b>AbstractConfiguration</b> makes easier to implementers 
                to create a new version of <see cref="T:Castle.Core.Configuration.IConfiguration" /></para>
      </remarks>
    </member>
    <member name="M:Castle.Core.Configuration.AbstractConfiguration.GetValue(System.Type,System.Object)">
      <summary>
              Gets the value of the node and converts it
              into specified <see cref="T:System.Type" />.
            </summary>
      <param name="type">The <see cref="T:System.Type" /></param>
      <param name="defaultValue">
              The Default value returned if the conversion fails.
            </param>
      <returns>The Value converted into the specified type.</returns>
    </member>
    <member name="P:Castle.Core.Configuration.AbstractConfiguration.Attributes">
      <summary>
              Gets node attributes.
            </summary>
      <value>
              All attributes of the node.
            </value>
    </member>
    <member name="P:Castle.Core.Configuration.AbstractConfiguration.Children">
      <summary>
              Gets all child nodes.
            </summary>
      <value>The <see cref="T:Castle.Core.Configuration.ConfigurationCollection" /> of child nodes.</value>
    </member>
    <member name="P:Castle.Core.Configuration.AbstractConfiguration.Name">
      <summary>
              Gets the name of the <see cref="T:Castle.Core.Configuration.IConfiguration" />.
            </summary>
      <value>
              The Name of the <see cref="T:Castle.Core.Configuration.IConfiguration" />.
            </value>
    </member>
    <member name="P:Castle.Core.Configuration.AbstractConfiguration.Value">
      <summary>
              Gets the value of <see cref="T:Castle.Core.Configuration.IConfiguration" />.
            </summary>
      <value>
              The Value of the <see cref="T:Castle.Core.Configuration.IConfiguration" />.
            </value>
    </member>
    <member name="T:Castle.Core.Configuration.MutableConfiguration">
      <summary>
            Summary description for MutableConfiguration.
            </summary>
    </member>
    <member name="M:Castle.Core.Configuration.MutableConfiguration.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.Configuration.MutableConfiguration" /> class.
            </summary>
      <param name="name">The name.</param>
    </member>
    <member name="P:Castle.Core.Configuration.MutableConfiguration.Value">
      <summary>
            Gets the value of <see cref="T:Castle.Core.Configuration.IConfiguration" />.
            </summary>
      <value>
            The Value of the <see cref="T:Castle.Core.Configuration.IConfiguration" />.
            </value>
    </member>
    <member name="T:Castle.Core.Logging.ILogger">
      <summary>
              Manages logging.
            </summary>
      <remarks>
              This is a facade for the different logging subsystems.
              It offers a simplified interface that follows IOC patterns
              and a simplified priority/level/severity abstraction.
            </remarks>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.CreateChildLogger(System.String)">
      <summary>
              Create a new child logger.
              The name of the child logger is [current-loggers-name].[passed-in-name]
            </summary>
      <param name="loggerName">The Subname of this logger.</param>
      <returns>The New ILogger instance.</returns>
      <exception cref="T:System.ArgumentException">If the name has an empty element name.</exception>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Debug(System.String)">
      <summary>
              Logs a debug message.
            </summary>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Debug(System.Func{System.String})">
      <summary>
              Logs a debug message with lazily constructed message. The message will be constructed only if the <see cref="P:Castle.Core.Logging.ILogger.IsDebugEnabled" /> is true.
            </summary>
      <param name="messageFactory">
      </param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Debug(System.String,System.Exception)">
      <summary>
              Logs a debug message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.DebugFormat(System.String,System.Object[])">
      <summary>
              Logs a debug message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.DebugFormat(System.Exception,System.String,System.Object[])">
      <summary>
              Logs a debug message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.DebugFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
              Logs a debug message.
            </summary>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.DebugFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
              Logs a debug message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Error(System.String)">
      <summary>
              Logs an error message.
            </summary>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Error(System.Func{System.String})">
      <summary>
              Logs an error message with lazily constructed message. The message will be constructed only if the <see cref="P:Castle.Core.Logging.ILogger.IsErrorEnabled" /> is true.
            </summary>
      <param name="messageFactory">
      </param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Error(System.String,System.Exception)">
      <summary>
              Logs an error message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.ErrorFormat(System.String,System.Object[])">
      <summary>
              Logs an error message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.ErrorFormat(System.Exception,System.String,System.Object[])">
      <summary>
              Logs an error message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.ErrorFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
              Logs an error message.
            </summary>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.ErrorFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
              Logs an error message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Fatal(System.String)">
      <summary>
              Logs a fatal message.
            </summary>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Fatal(System.Func{System.String})">
      <summary>
              Logs a fatal message with lazily constructed message. The message will be constructed only if the <see cref="P:Castle.Core.Logging.ILogger.IsFatalEnabled" /> is true.
            </summary>
      <param name="messageFactory">
      </param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Fatal(System.String,System.Exception)">
      <summary>
              Logs a fatal message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.FatalFormat(System.String,System.Object[])">
      <summary>
              Logs a fatal message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.FatalFormat(System.Exception,System.String,System.Object[])">
      <summary>
              Logs a fatal message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.FatalFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
              Logs a fatal message.
            </summary>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.FatalFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
              Logs a fatal message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Info(System.String)">
      <summary>
              Logs an info message.
            </summary>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Info(System.Func{System.String})">
      <summary>
              Logs a info message with lazily constructed message. The message will be constructed only if the <see cref="P:Castle.Core.Logging.ILogger.IsInfoEnabled" /> is true.
            </summary>
      <param name="messageFactory">
      </param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Info(System.String,System.Exception)">
      <summary>
              Logs an info message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.InfoFormat(System.String,System.Object[])">
      <summary>
              Logs an info message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.InfoFormat(System.Exception,System.String,System.Object[])">
      <summary>
              Logs an info message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.InfoFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
              Logs an info message.
            </summary>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.InfoFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
              Logs an info message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Warn(System.String)">
      <summary>
              Logs a warn message.
            </summary>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Warn(System.Func{System.String})">
      <summary>
              Logs a warn message with lazily constructed message. The message will be constructed only if the <see cref="P:Castle.Core.Logging.ILogger.IsWarnEnabled" /> is true.
            </summary>
      <param name="messageFactory">
      </param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Warn(System.String,System.Exception)">
      <summary>
              Logs a warn message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.WarnFormat(System.String,System.Object[])">
      <summary>
              Logs a warn message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.WarnFormat(System.Exception,System.String,System.Object[])">
      <summary>
              Logs a warn message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.WarnFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
              Logs a warn message.
            </summary>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.WarnFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
              Logs a warn message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="P:Castle.Core.Logging.ILogger.IsDebugEnabled">
      <summary>
              Determines if messages of priority "debug" will be logged.
            </summary>
      <value>True if "debug" messages will be logged.</value>
    </member>
    <member name="P:Castle.Core.Logging.ILogger.IsErrorEnabled">
      <summary>
              Determines if messages of priority "error" will be logged.
            </summary>
      <value>True if "error" messages will be logged.</value>
    </member>
    <member name="P:Castle.Core.Logging.ILogger.IsFatalEnabled">
      <summary>
              Determines if messages of priority "fatal" will be logged.
            </summary>
      <value>True if "fatal" messages will be logged.</value>
    </member>
    <member name="P:Castle.Core.Logging.ILogger.IsInfoEnabled">
      <summary>
              Determines if messages of priority "info" will be logged.
            </summary>
      <value>True if "info" messages will be logged.</value>
    </member>
    <member name="P:Castle.Core.Logging.ILogger.IsWarnEnabled">
      <summary>
              Determines if messages of priority "warn" will be logged.
            </summary>
      <value>True if "warn" messages will be logged.</value>
    </member>
    <member name="T:Castle.Core.Logging.IContextProperties">
      <summary>
              Interface for Context Properties implementations
            </summary>
      <remarks>
        <para>
                This interface defines a basic property get set accessor.
              </para>
        <para>
                Based on the ContextPropertiesBase of log4net, by Nicko Cadell.
              </para>
      </remarks>
    </member>
    <member name="P:Castle.Core.Logging.IContextProperties.Item(System.String)">
      <summary>
              Gets or sets the value of a property
            </summary>
      <value>
              The value for the property with the specified key
            </value>
      <remarks>
        <para>
                Gets or sets the value of a property
              </para>
      </remarks>
    </member>
    <member name="M:Castle.Core.Internal.Lock.Create">
      <summary>
            Creates a new lock.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="T:Castle.DynamicProxy.IInvocation">
      <summary>
              Encapsulates an invocation of a proxied method.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.IInvocation.GetArgumentValue(System.Int32)">
      <summary>
              Gets the value of the argument at the specified <paramref name="index" />.
            </summary>
      <param name="index">The index.</param>
      <returns>The value of the argument at the specified <paramref name="index" />.</returns>
    </member>
    <member name="M:Castle.DynamicProxy.IInvocation.GetConcreteMethod">
      <summary>
              Returns the concrete instantiation of the <see cref="P:Castle.DynamicProxy.IInvocation.Method" /> on the proxy, with any generic
              parameters bound to real types.
            </summary>
      <returns>
              The concrete instantiation of the <see cref="P:Castle.DynamicProxy.IInvocation.Method" /> on the proxy, or the <see cref="P:Castle.DynamicProxy.IInvocation.Method" /> if
              not a generic method.
            </returns>
      <remarks>
              Can be slower than calling <see cref="P:Castle.DynamicProxy.IInvocation.Method" />.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.IInvocation.GetConcreteMethodInvocationTarget">
      <summary>
              Returns the concrete instantiation of <see cref="P:Castle.DynamicProxy.IInvocation.MethodInvocationTarget" />, with any
              generic parameters bound to real types.
              For interface proxies, this will point to the <see cref="T:System.Reflection.MethodInfo" /> on the target class.
            </summary>
      <returns>The concrete instantiation of <see cref="P:Castle.DynamicProxy.IInvocation.MethodInvocationTarget" />, or
              <see cref="P:Castle.DynamicProxy.IInvocation.MethodInvocationTarget" /> if not a generic method.</returns>
      <remarks>
              In debug builds this can be slower than calling <see cref="P:Castle.DynamicProxy.IInvocation.MethodInvocationTarget" />.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.IInvocation.Proceed">
      <summary>
              Proceeds the call to the next interceptor in line, and ultimately to the target method.
            </summary>
      <remarks>
              Since interface proxies without a target don't have the target implementation to proceed to,
              it is important, that the last interceptor does not call this method, otherwise a
              <see cref="T:System.NotImplementedException" /> will be thrown.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.IInvocation.SetArgumentValue(System.Int32,System.Object)">
      <summary>
              Overrides the value of an argument at the given <paramref name="index" /> with the
              new <paramref name="value" /> provided.
            </summary>
      <remarks>
              This method accepts an <see cref="T:System.Object" />, however the value provided must be compatible
              with the type of the argument defined on the method, otherwise an exception will be thrown.
            </remarks>
      <param name="index">The index of the argument to override.</param>
      <param name="value">The new value for the argument.</param>
    </member>
    <member name="P:Castle.DynamicProxy.IInvocation.Arguments">
      <summary>
              Gets the arguments that the <see cref="P:Castle.DynamicProxy.IInvocation.Method" /> has been invoked with.
            </summary>
      <value>The arguments the method was invoked with.</value>
    </member>
    <member name="P:Castle.DynamicProxy.IInvocation.GenericArguments">
      <summary>
              Gets the generic arguments of the method.
            </summary>
      <value>The generic arguments, or null if not a generic method.</value>
    </member>
    <member name="P:Castle.DynamicProxy.IInvocation.InvocationTarget">
      <summary>
              Gets the object on which the invocation is performed. This is different from proxy object
              because most of the time this will be the proxy target object.
            </summary>
      <seealso cref="T:Castle.DynamicProxy.IChangeProxyTarget" />
      <value>The invocation target.</value>
    </member>
    <member name="P:Castle.DynamicProxy.IInvocation.Method">
      <summary>
              Gets the <see cref="T:System.Reflection.MethodInfo" /> representing the method being invoked on the proxy.
            </summary>
      <value>The <see cref="T:System.Reflection.MethodInfo" /> representing the method being invoked.</value>
    </member>
    <member name="P:Castle.DynamicProxy.IInvocation.MethodInvocationTarget">
      <summary>
              For interface proxies, this will point to the <see cref="T:System.Reflection.MethodInfo" /> on the target class.
            </summary>
      <value>The method invocation target.</value>
    </member>
    <member name="P:Castle.DynamicProxy.IInvocation.Proxy">
      <summary>
              Gets the proxy object on which the intercepted method is invoked.
            </summary>
      <value>Proxy object on which the intercepted method is invoked.</value>
    </member>
    <member name="P:Castle.DynamicProxy.IInvocation.ReturnValue">
      <summary>
              Gets or sets the return value of the method.
            </summary>
      <value>The return value of the method.</value>
    </member>
    <member name="P:Castle.DynamicProxy.IInvocation.TargetType">
      <summary>
              Gets the type of the target object for the intercepted method.
            </summary>
      <value>The type of the target object.</value>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.IDictionaryAdapterVisitor">
      <summary>
            Conract for traversing a <see cref="T:Castle.Components.DictionaryAdapter.IDictionaryAdapter" />.
            </summary>
    </member>
    <member name="T:Castle.DynamicProxy.IAttributeDisassembler">
      <summary>
              Provides functionality for disassembling instances of attributes to CustomAttributeBuilder form, during the process of emiting new types by Dynamic Proxy.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.IAttributeDisassembler.Disassemble(System.Attribute)">
      <summary>
              Disassembles given attribute instance back to corresponding CustomAttributeBuilder.
            </summary>
      <param name="attribute">An instance of attribute to disassemble</param>
      <returns>
        <see cref="T:System.Reflection.Emit.CustomAttributeBuilder" /> corresponding 1 to 1 to given attribute instance, or null reference.</returns>
      <remarks>
              Implementers should return <see cref="T:System.Reflection.Emit.CustomAttributeBuilder" /> that corresponds to given attribute instance 1 to 1,
              that is after calling specified constructor with specified arguments, and setting specified properties and fields with values specified
              we should be able to get an attribute instance identical to the one passed in <paramref name="attribute" />. Implementer can return null
              if it wishes to opt out of replicating the attribute. Notice however, that for some cases, like attributes passed explicitly by the user
              it is illegal to return null, and doing so will result in exception.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.MixinData.#ctor(System.Collections.Generic.IEnumerable{System.Object})">
      <summary>
              Because we need to cache the types based on the mixed in mixins, we do the following here:
              - Get all the mixin interfaces
              - Sort them by full name
              - Return them by position
            
            The idea is to have reproducible behavior for the case that mixins are registered in different orders.
            This method is here because it is required 
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.StringListAttribute">
      <summary>
            Identifies a property should be represented as a delimited string value.
            </summary>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.StringListAttribute.Separator">
      <summary>
            Gets the separator.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.DictionaryAdapterAttribute">
      <summary>
            Identifies the dictionary adapter types.
            </summary>
    </member>
    <member name="T:Castle.DynamicProxy.Generators.INamingScope">
      <summary>
              Represents the scope of uniquenes of names for types and their members
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.INamingScope.GetUniqueName(System.String)">
      <summary>
              Gets a unique name based on <paramref name="suggestedName" /></summary>
      <param name="suggestedName">Name suggested by the caller</param>
      <returns>Unique name based on <paramref name="suggestedName" />.</returns>
      <remarks>
              Implementers should provide name as closely resembling <paramref name="suggestedName" /> as possible.
              Generally if no collision occurs it is suggested to return suggested name, otherwise append sequential suffix.
              Implementers must return deterministic names, that is when <see cref="M:Castle.DynamicProxy.Generators.INamingScope.GetUniqueName(System.String)" /> is called twice 
              with the same suggested name, the same returned name should be provided each time. Non-deterministic return
              values, like appending random suffices will break serialization of proxies.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.INamingScope.SafeSubScope">
      <summary>
              Returns new, disposable naming scope. It is responsibilty of the caller to make sure that no naming collision
              with enclosing scope, or other subscopes is possible.
            </summary>
      <returns>New naming scope.</returns>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.InvocationTypeGenerator.GetBaseCtorArguments(System.Type,Castle.DynamicProxy.ProxyGenerationOptions,System.Reflection.ConstructorInfo@)">
      <summary>
              Generates the constructor for the class that extends
              <see cref="T:Castle.DynamicProxy.AbstractInvocation" /></summary>
      <param name="targetFieldType">
      </param>
      <param name="proxyGenerationOptions">
      </param>
      <param name="baseConstructor">
      </param>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.IDictionaryMetaInitializer">
      <summary>
             Contract for dictionary meta-data initialization.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IDictionaryMetaInitializer.Initialize(Castle.Components.DictionaryAdapter.IDictionaryAdapterFactory,Castle.Components.DictionaryAdapter.DictionaryAdapterMeta)">
      <summary>
            	Initializes the given <see cref="T:Castle.Components.DictionaryAdapter.DictionaryAdapterMeta" /> object.
            </summary>
      <param name="factory">The dictionary adapter factory.</param>
      <param name="dictionaryMeta">The dictionary adapter meta.</param>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IDictionaryMetaInitializer.ShouldHaveBehavior(System.Object)">
      <summary>
            	Determines whether the given behavior should be included in a new
            	<see cref="T:Castle.Components.DictionaryAdapter.DictionaryAdapterMeta" /> object.
            </summary>
      <param name="behavior">A dictionary behavior or annotation.</param>
      <returns>True if the behavior should be included; otherwise, false.</returns>
      <remarks>
        <see cref="T:Castle.Components.DictionaryAdapter.IDictionaryMetaInitializer" /> behaviors are always included,
            	regardless of the result of this method.
            </remarks>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.IDictionaryInitializer">
      <summary>
             Contract for dictionary initialization.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IDictionaryInitializer.Initialize(Castle.Components.DictionaryAdapter.IDictionaryAdapter,System.Object[])">
      <summary>
            Performs any initialization of the <see cref="T:Castle.Components.DictionaryAdapter.IDictionaryAdapter" /></summary>
      <param name="dictionaryAdapter">The dictionary adapter.</param>
      <param name="behaviors">The dictionary behaviors.</param>
    </member>
    <member name="T:Castle.Core.Resource.UncResource">
      <summary>
            Enable access to files on network shares
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.AbstractExtendedLoggerFactory.Create(System.Type)">
      <summary>
              Creates a new extended logger, getting the logger name from the specified type.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.AbstractExtendedLoggerFactory.Create(System.String)">
      <summary>
              Creates a new extended logger.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.AbstractExtendedLoggerFactory.Create(System.Type,Castle.Core.Logging.LoggerLevel)">
      <summary>
              Creates a new extended logger, getting the logger name from the specified type.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.AbstractExtendedLoggerFactory.Create(System.String,Castle.Core.Logging.LoggerLevel)">
      <summary>
              Creates a new extended logger.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.AbstractExtendedLoggerFactory.GetConfigFile(System.String)">
      <summary>
              Gets the configuration file.
            </summary>
      <param name="fileName">i.e. log4net.config</param>
      <returns>
      </returns>
    </member>
    <member name="T:Castle.DynamicProxy.IInterceptorSelector">
      <summary>
              Provides an extension point that allows proxies to choose specific interceptors on
              a per method basis.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.IInterceptorSelector.SelectInterceptors(System.Type,System.Reflection.MethodInfo,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Selects the interceptors that should intercept calls to the given <paramref name="method" />.
            </summary>
      <param name="type">The type declaring the method to intercept.</param>
      <param name="method">The method that will be intercepted.</param>
      <param name="interceptors">All interceptors registered with the proxy.</param>
      <returns>An array of interceptors to invoke upon calling the <paramref name="method" />.</returns>
      <remarks>
              This method is called only once per proxy instance, upon the first call to the
              <paramref name="method" />. Either an empty array or null are valid return values to indicate
              that no interceptor should intercept calls to the method. Although it is not advised, it is
              legal to return other <see cref="T:Castle.DynamicProxy.IInterceptor" /> implementations than these provided in
              <paramref name="interceptors" />.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.Internal.InternalsUtil.IsInternal(System.Reflection.MethodBase)">
      <summary>
              Determines whether the specified method is internal.
            </summary>
      <param name="method">The method.</param>
      <returns>
        <c>true</c> if the specified method is internal; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Castle.DynamicProxy.Internal.InternalsUtil.IsInternalToDynamicProxy(System.Reflection.Assembly)">
      <summary>
              Determines whether this assembly has internals visible to dynamic proxy.
            </summary>
      <param name="asm">The assembly to inspect.</param>
    </member>
    <member name="M:Castle.DynamicProxy.Internal.InternalsUtil.IsAccessible(System.Reflection.MethodBase)">
      <summary>
              Checks if the method is public or protected.
            </summary>
      <param name="method">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:Castle.DynamicProxy.Generators.Emitters.StindOpCodesDictionary">
      <summary>
              Provides appropriate Stind.X opcode 
              for the type of primitive value to be stored indirectly.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.Emitters.OpCodeUtil.EmitLoadIndirectOpCodeForType(System.Reflection.Emit.ILGenerator,System.Type)">
      <summary>
              Emits a load indirect opcode of the appropriate type for a value or object reference.
              Pops a pointer off the evaluation stack, dereferences it and loads
              a value of the specified type.
            </summary>
      <param name="gen">
      </param>
      <param name="type">
      </param>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.Emitters.OpCodeUtil.EmitLoadOpCodeForConstantValue(System.Reflection.Emit.ILGenerator,System.Object)">
      <summary>
              Emits a load opcode of the appropriate kind for a constant string or
              primitive value.
            </summary>
      <param name="gen">
      </param>
      <param name="value">
      </param>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.Emitters.OpCodeUtil.EmitLoadOpCodeForDefaultValueOfType(System.Reflection.Emit.ILGenerator,System.Type)">
      <summary>
              Emits a load opcode of the appropriate kind for the constant default value of a
              type, such as 0 for value types and null for reference types.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.Emitters.OpCodeUtil.EmitStoreIndirectOpCodeForType(System.Reflection.Emit.ILGenerator,System.Type)">
      <summary>
              Emits a store indirectopcode of the appropriate type for a value or object reference.
              Pops a value of the specified type and a pointer off the evaluation stack, and
              stores the value.
            </summary>
      <param name="gen">
      </param>
      <param name="type">
      </param>
    </member>
    <member name="M:Castle.DynamicProxy.Internal.AttributeUtil.AddDisassembler``1(Castle.DynamicProxy.IAttributeDisassembler)">
      <summary>
              Registers custom disassembler to handle disassembly of specified type of attributes.
            </summary>
      <typeparam name="TAttribute">Type of attributes to handle</typeparam>
      <param name="disassembler">Disassembler converting existing instances of Attributes to CustomAttributeBuilders</param>
      <remarks>
              When disassembling an attribute Dynamic Proxy will first check if an custom disassembler has been registered to handle attributes of that type, 
              and if none is found, it'll use the <see cref="P:Castle.DynamicProxy.Internal.AttributeUtil.FallbackDisassembler" />.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.Internal.AttributeUtil.ShouldSkipAttributeReplication(System.Type)">
      <summary>
              Attributes should be replicated if they are non-inheritable,
              but there are some special cases where the attributes means
              something to the CLR, where they should be skipped.
            </summary>
    </member>
    <member name="T:Castle.Core.Logging.LoggerLevel">
      <summary>
              Supporting Logger levels.
            </summary>
    </member>
    <member name="F:Castle.Core.Logging.LoggerLevel.Off">
      <summary>
              Logging will be off
            </summary>
    </member>
    <member name="F:Castle.Core.Logging.LoggerLevel.Fatal">
      <summary>
              Fatal logging level
            </summary>
    </member>
    <member name="F:Castle.Core.Logging.LoggerLevel.Error">
      <summary>
              Error logging level
            </summary>
    </member>
    <member name="F:Castle.Core.Logging.LoggerLevel.Warn">
      <summary>
              Warn logging level
            </summary>
    </member>
    <member name="F:Castle.Core.Logging.LoggerLevel.Info">
      <summary>
              Info logging level
            </summary>
    </member>
    <member name="F:Castle.Core.Logging.LoggerLevel.Debug">
      <summary>
              Debug logging level
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.PropertyDescriptor">
      <summary>
            Describes a dictionary property.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.PropertyDescriptor.#ctor">
      <summary>
            Initializes an empty <see cref="T:Castle.Components.DictionaryAdapter.PropertyDescriptor" /> class.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.PropertyDescriptor.#ctor(System.Reflection.PropertyInfo,System.Object[])">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Components.DictionaryAdapter.PropertyDescriptor" /> class.
            </summary>
      <param name="property">The property.</param>
      <param name="annotations">The annotations.</param>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.PropertyDescriptor.#ctor(System.Object[])">
      <summary>
            Initializes a new instance <see cref="T:Castle.Components.DictionaryAdapter.PropertyDescriptor" /> class.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.PropertyDescriptor.#ctor(Castle.Components.DictionaryAdapter.PropertyDescriptor,System.Boolean)">
      <summary>
             Copies an existinginstance of the <see cref="T:Castle.Components.DictionaryAdapter.PropertyDescriptor" /> class.
            </summary>
      <param name="source">
      </param>
      <param name="copyBehaviors">
      </param>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.PropertyDescriptor.GetKey(Castle.Components.DictionaryAdapter.IDictionaryAdapter,System.String,Castle.Components.DictionaryAdapter.PropertyDescriptor)">
      <summary>
            Gets the key.
            </summary>
      <param name="dictionaryAdapter">The dictionary adapter.</param>
      <param name="key">The key.</param>
      <param name="descriptor">The descriptor.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.PropertyDescriptor.GetPropertyValue(Castle.Components.DictionaryAdapter.IDictionaryAdapter,System.String,System.Object,Castle.Components.DictionaryAdapter.PropertyDescriptor,System.Boolean)">
      <summary>
            Gets the property value.
            </summary>
      <param name="dictionaryAdapter">The dictionary adapter.</param>
      <param name="key">The key.</param>
      <param name="storedValue">The stored value.</param>
      <param name="descriptor">The descriptor.</param>
      <param name="ifExists">true if return only existing.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.PropertyDescriptor.SetPropertyValue(Castle.Components.DictionaryAdapter.IDictionaryAdapter,System.String,System.Object@,Castle.Components.DictionaryAdapter.PropertyDescriptor)">
      <summary>
            Sets the property value.
            </summary>
      <param name="dictionaryAdapter">The dictionary adapter.</param>
      <param name="key">The key.</param>
      <param name="value">The value.</param>
      <param name="descriptor">The descriptor.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.PropertyDescriptor.AddBehavior(Castle.Components.DictionaryAdapter.IDictionaryBehavior)">
      <summary>
            Adds a single behavior.
            </summary>
      <param name="behavior">The behavior.</param>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.PropertyDescriptor.AddBehaviors(Castle.Components.DictionaryAdapter.IDictionaryBehavior[])">
      <summary>
            Adds the behaviors.
            </summary>
      <param name="behaviors">The behaviors.</param>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.PropertyDescriptor.AddBehaviors(System.Collections.Generic.IEnumerable{Castle.Components.DictionaryAdapter.IDictionaryBehavior})">
      <summary>
            Adds the behaviors.
            </summary>
      <param name="behaviors">The behaviors.</param>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.PropertyDescriptor.CopyBehaviors(Castle.Components.DictionaryAdapter.PropertyDescriptor)">
      <summary>
            Copies the behaviors to the other <see cref="T:Castle.Components.DictionaryAdapter.PropertyDescriptor" /></summary>
      <param name="other">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.PropertyDescriptor.Copy">
      <summary>
            Copies the <see cref="T:Castle.Components.DictionaryAdapter.PropertyDescriptor" /></summary>
      <returns>
      </returns>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.PropertyDescriptor.ExecutionOrder">
      <summary>
      </summary>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.PropertyDescriptor.PropertyName">
      <summary>
            Gets the property name.
            </summary>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.PropertyDescriptor.PropertyType">
      <summary>
            Gets the property type.
            </summary>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.PropertyDescriptor.Property">
      <summary>
            Gets the property.
            </summary>
      <value>The property.</value>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.PropertyDescriptor.IsDynamicProperty">
      <summary>
            Returns true if the property is dynamic.
            </summary>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.PropertyDescriptor.State">
      <summary>
            Gets additional state.
            </summary>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.PropertyDescriptor.Fetch">
      <summary>
            Determines if property should be fetched.
            </summary>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.PropertyDescriptor.IfExists">
      <summary>
            Determines if property must exist first.
            </summary>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.PropertyDescriptor.SuppressNotifications">
      <summary>
            Determines if notifications should occur.
            </summary>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.PropertyDescriptor.Annotations">
      <summary>
            Gets the property behaviors.
            </summary>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.PropertyDescriptor.TypeConverter">
      <summary>
            Gets the type converter.
            </summary>
      <value>The type converter.</value>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.PropertyDescriptor.ExtendedProperties">
      <summary>
            Gets the extended properties.
            </summary>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.PropertyDescriptor.Behaviors">
      <summary>
            Gets the setter.
            </summary>
      <value>The setter.</value>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.PropertyDescriptor.KeyBuilders">
      <summary>
            Gets the key builders.
            </summary>
      <value>The key builders.</value>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.PropertyDescriptor.Setters">
      <summary>
            Gets the setter.
            </summary>
      <value>The setter.</value>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.PropertyDescriptor.Getters">
      <summary>
            Gets the getter.
            </summary>
      <value>The getter.</value>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.PropertyDescriptor.Initializers">
      <summary>
            Gets the initializers.
            </summary>
      <value>The initializers.</value>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.PropertyDescriptor.MetaInitializers">
      <summary>
            Gets the meta-data initializers.
            </summary>
      <value>The meta-data initializers.</value>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.StringValuesAttribute">
      <summary>
            Converts all properties to strings.
            </summary>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.StringValuesAttribute.Format">
      <summary>
            Gets or sets the format.
            </summary>
      <value>The format.</value>
    </member>
    <member name="F:Castle.Core.Internal.InternalsVisible.ToCastleCore">
      <summary>
              Constant to use when making assembly internals visible to Castle.Core 
              <c>[assembly: InternalsVisibleTo(CoreInternalsVisible.ToCastleCore)]</c></summary>
    </member>
    <member name="F:Castle.Core.Internal.InternalsVisible.ToDynamicProxyGenAssembly2">
      <summary>
              Constant to use when making assembly internals visible to proxy types generated by DynamicProxy. Required when proxying internal types.
              <c>[assembly: InternalsVisibleTo(CoreInternalsVisible.ToDynamicProxyGenAssembly2)]</c></summary>
    </member>
    <member name="M:Castle.Core.Internal.CollectionExtensions.IsNullOrEmpty(System.Collections.IEnumerable)">
      <summary>
              Checks whether or not collection is null or empty. Assumes colleciton can be safely enumerated multiple times.
            </summary>
      <param name="this">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:Castle.Core.Logging.IExtendedLogger">
      <summary>
              Provides an interface that supports <see cref="T:Castle.Core.Logging.ILogger" /> and
              allows the storage and retrieval of Contexts. These are supported in
              both log4net and NLog.
            </summary>
    </member>
    <member name="P:Castle.Core.Logging.IExtendedLogger.GlobalProperties">
      <summary>
              Exposes the Global Context of the extended logger.
            </summary>
    </member>
    <member name="P:Castle.Core.Logging.IExtendedLogger.ThreadProperties">
      <summary>
              Exposes the Thread Context of the extended logger.
            </summary>
    </member>
    <member name="P:Castle.Core.Logging.IExtendedLogger.ThreadStacks">
      <summary>
              Exposes the Thread Stack of the extended logger.
            </summary>
    </member>
    <member name="T:Castle.Core.IServiceProviderEx">
      <summary>
            Increments <c>IServiceProvider</c> with a generic service resolution operation.
            </summary>
    </member>
    <member name="T:Castle.Core.IServiceEnabledComponent">
      <summary>
            Defines that the implementation wants a 
            <see cref="T:System.IServiceProvider" /> in order to 
            access other components. The creator must be aware
            that the component might (or might not) implement 
            the interface.
            </summary>
      <remarks>
            Used by Castle Project components to, for example, 
            gather logging factories
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.CacheKey.#ctor(System.Reflection.MemberInfo,System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.DynamicProxy.Generators.CacheKey" /> class.
            </summary>
      <param name="target">Target element. This is either target type or target method for invocation types.</param>
      <param name="type">The type of the proxy. This is base type for invocation types.</param>
      <param name="interfaces">The interfaces.</param>
      <param name="options">The options.</param>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.CacheKey.#ctor(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.DynamicProxy.Generators.CacheKey" /> class.
            </summary>
      <param name="target">Type of the target.</param>
      <param name="interfaces">The interfaces.</param>
      <param name="options">The options.</param>
    </member>
    <member name="T:Castle.DynamicProxy.DefaultProxyBuilder">
      <summary>
              Default implementation of <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> interface producing in-memory proxy assemblies.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.DefaultProxyBuilder.#ctor">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.DynamicProxy.DefaultProxyBuilder" /> class with new <see cref="P:Castle.DynamicProxy.DefaultProxyBuilder.ModuleScope" />.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.DefaultProxyBuilder.#ctor(Castle.DynamicProxy.ModuleScope)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.DynamicProxy.DefaultProxyBuilder" /> class.
            </summary>
      <param name="scope">The module scope for generated proxy types.</param>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.MultiLevelEditAttribute">
      <summary>
            Requests support for multi-level editing.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.IfExistsAttribute">
      <summary>
            Suppresses any on-demand behaviors.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.ReferenceAttribute">
      <summary>
            Specifies assignment by reference rather than by copying.
            </summary>
    </member>
    <member name="T:Castle.DynamicProxy.Tokens.InvocationMethods">
      <summary>
              Holds <see cref="T:System.Reflection.MethodInfo" /> objects representing methods of <see cref="T:Castle.DynamicProxy.AbstractInvocation" /> class.
            </summary>
    </member>
    <member name="T:Castle.DynamicProxy.Generators.MethodFinder">
      <summary>
              Returns the methods implemented by a type. Use this instead of Type.GetMethods() to work around a CLR issue
              where duplicate MethodInfos are returned by Type.GetMethods() after a token of a generic type's method was loaded.
            </summary>
    </member>
    <member name="T:Castle.DynamicProxy.Generators.Emitters.PropertiesCollection">
      <summary>
              Summary description for PropertiesCollection.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.AttributeDisassembler.HandleError(System.Type,System.Exception)">
      <summary>
              Handles error during disassembly process
            </summary>
      <param name="attributeType">Type of the attribute being disassembled</param>
      <param name="exception">Exception thrown during the process</param>
      <returns>usually null, or (re)throws the exception</returns>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.AttributeDisassembler.InitializeConstructorArgs(System.Type,System.Attribute,System.Reflection.ParameterInfo[])">
      <summary>
              Here we try to match a constructor argument to its value.
              Since we can't get the values from the assembly, we use some heuristics to get it.
              a/ we first try to match all the properties on the attributes by name (case insensitive) to the argument
              b/ if we fail we try to match them by property type, with some smarts about convertions (i,e: can use Guid for string).
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.AttributeDisassembler.ReplaceIfBetterMatch(System.Reflection.ParameterInfo,System.Reflection.PropertyInfo,System.Reflection.PropertyInfo)">
      <summary>
              We have the following rules here.
              Try to find a matching type, failing that, if the parameter is string, get the first property (under the assumption that
              we can convert it.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.AttributeDisassembler.ConvertValue(System.Object,System.Type)">
      <summary>
              Attributes can only accept simple types, so we return null for null,
              if the value is passed as string we call to string (should help with converting), 
              otherwise, we use the value as is (enums, integer, etc).
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.StringFormatAttribute">
      <summary>
            Provides simple string formatting from existing properties.
            </summary>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.StringFormatAttribute.Format">
      <summary>
            Gets the string format.
            </summary>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.StringFormatAttribute.Properties">
      <summary>
            Gets the format properties.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.KeyAttribute">
      <summary>
            Assigns a specific dictionary key.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.KeyAttribute.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Components.DictionaryAdapter.KeyAttribute" /> class.
            </summary>
      <param name="key">The key.</param>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.KeyAttribute.#ctor(System.String[])">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Components.DictionaryAdapter.KeyAttribute" /> class.
            </summary>
      <param name="keys">The compound key.</param>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.RemoveIfEmptyAttribute">
      <summary>
            Removes a property if null or empty string, guid or collection.
            </summary>
    </member>
    <member name="T:Castle.Core.Logging.LevelFilteredLogger">
      <summary>
            The Level Filtered Logger class.  This is a base clase which
            provides a LogLevel attribute and reroutes all functions into
            one Log method.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.#ctor">
      <summary>
              Creates a new <c>LevelFilteredLogger</c>.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Debug(System.String)">
      <summary>
              Logs a debug message.
            </summary>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Debug(System.String,System.Exception)">
      <summary>
              Logs a debug message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.DebugFormat(System.String,System.Object[])">
      <summary>
              Logs a debug message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.DebugFormat(System.Exception,System.String,System.Object[])">
      <summary>
              Logs a debug message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.DebugFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
              Logs a debug message.
            </summary>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.DebugFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
              Logs a debug message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Info(System.String)">
      <summary>
              Logs an info message.
            </summary>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Info(System.String,System.Exception)">
      <summary>
              Logs an info message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.InfoFormat(System.String,System.Object[])">
      <summary>
              Logs an info message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.InfoFormat(System.Exception,System.String,System.Object[])">
      <summary>
              Logs an info message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.InfoFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
              Logs an info message.
            </summary>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.InfoFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
              Logs an info message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Warn(System.String)">
      <summary>
              Logs a warn message.
            </summary>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Warn(System.String,System.Exception)">
      <summary>
              Logs a warn message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.WarnFormat(System.String,System.Object[])">
      <summary>
              Logs a warn message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.WarnFormat(System.Exception,System.String,System.Object[])">
      <summary>
              Logs a warn message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.WarnFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
              Logs a warn message.
            </summary>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.WarnFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
              Logs a warn message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Error(System.String)">
      <summary>
              Logs an error message.
            </summary>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Error(System.String,System.Exception)">
      <summary>
              Logs an error message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.ErrorFormat(System.String,System.Object[])">
      <summary>
              Logs an error message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.ErrorFormat(System.Exception,System.String,System.Object[])">
      <summary>
              Logs an error message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.ErrorFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
              Logs an error message.
            </summary>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.ErrorFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
              Logs an error message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Fatal(System.String)">
      <summary>
              Logs a fatal message.
            </summary>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Fatal(System.String,System.Exception)">
      <summary>
              Logs a fatal message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.FatalFormat(System.String,System.Object[])">
      <summary>
              Logs a fatal message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.FatalFormat(System.Exception,System.String,System.Object[])">
      <summary>
              Logs a fatal message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.FatalFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
              Logs a fatal message.
            </summary>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.FatalFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
              Logs a fatal message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Log(Castle.Core.Logging.LoggerLevel,System.String,System.String,System.Exception)">
      <summary>
              Implementors output the log content by implementing this method only.
              Note that exception can be null
            </summary>
      <param name="loggerLevel">
      </param>
      <param name="loggerName">
      </param>
      <param name="message">
      </param>
      <param name="exception">
      </param>
    </member>
    <member name="P:Castle.Core.Logging.LevelFilteredLogger.Level">
      <value>
              The <c>LoggerLevel</c> that this logger
              will be using. Defaults to <c>LoggerLevel.Off</c></value>
    </member>
    <member name="P:Castle.Core.Logging.LevelFilteredLogger.Name">
      <value>
              The name that this logger will be using. 
              Defaults to <c>String.Empty</c></value>
    </member>
    <member name="P:Castle.Core.Logging.LevelFilteredLogger.IsDebugEnabled">
      <summary>
              Determines if messages of priority "debug" will be logged.
            </summary>
      <value>
        <c>true</c> if log level flags include the <see cref="F:Castle.Core.Logging.LoggerLevel.Debug" /> bit</value>
    </member>
    <member name="P:Castle.Core.Logging.LevelFilteredLogger.IsInfoEnabled">
      <summary>
              Determines if messages of priority "info" will be logged.
            </summary>
      <value>
        <c>true</c> if log level flags include the <see cref="F:Castle.Core.Logging.LoggerLevel.Info" /> bit</value>
    </member>
    <member name="P:Castle.Core.Logging.LevelFilteredLogger.IsWarnEnabled">
      <summary>
              Determines if messages of priority "warn" will be logged.
            </summary>
      <value>
        <c>true</c> if log level flags include the <see cref="F:Castle.Core.Logging.LoggerLevel.Warn" /> bit</value>
    </member>
    <member name="P:Castle.Core.Logging.LevelFilteredLogger.IsErrorEnabled">
      <summary>
              Determines if messages of priority "error" will be logged.
            </summary>
      <value>
        <c>true</c> if log level flags include the <see cref="F:Castle.Core.Logging.LoggerLevel.Error" /> bit</value>
    </member>
    <member name="P:Castle.Core.Logging.LevelFilteredLogger.IsFatalEnabled">
      <summary>
              Determines if messages of priority "fatal" will be logged.
            </summary>
      <value>
        <c>true</c> if log level flags include the <see cref="F:Castle.Core.Logging.LoggerLevel.Fatal" /> bit</value>
    </member>
    <member name="T:Castle.Core.Logging.ConsoleLogger">
      <summary>
            The Logger sending everything to the standard output streams.
            This is mainly for the cases when you have a utility that
            does not have a logger to supply.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.ConsoleLogger.#ctor">
      <summary>
              Creates a new ConsoleLogger with the <c>Level</c>
              set to <c>LoggerLevel.Debug</c> and the <c>Name</c>
              set to <c>String.Empty</c>.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.ConsoleLogger.#ctor(Castle.Core.Logging.LoggerLevel)">
      <summary>
              Creates a new ConsoleLogger with the <c>Name</c>
              set to <c>String.Empty</c>.
            </summary>
      <param name="logLevel">The logs Level.</param>
    </member>
    <member name="M:Castle.Core.Logging.ConsoleLogger.#ctor(System.String)">
      <summary>
              Creates a new ConsoleLogger with the <c>Level</c>
              set to <c>LoggerLevel.Debug</c>.
            </summary>
      <param name="name">The logs Name.</param>
    </member>
    <member name="M:Castle.Core.Logging.ConsoleLogger.#ctor(System.String,Castle.Core.Logging.LoggerLevel)">
      <summary>
              Creates a new ConsoleLogger.
            </summary>
      <param name="name">The logs Name.</param>
      <param name="logLevel">The logs Level.</param>
    </member>
    <member name="M:Castle.Core.Logging.ConsoleLogger.Log(Castle.Core.Logging.LoggerLevel,System.String,System.String,System.Exception)">
      <summary>
              A Common method to log.
            </summary>
      <param name="loggerLevel">The level of logging</param>
      <param name="loggerName">The name of the logger</param>
      <param name="message">The Message</param>
      <param name="exception">The Exception</param>
    </member>
    <member name="M:Castle.Core.Logging.ConsoleLogger.CreateChildLogger(System.String)">
      <summary>
              Returns a new <c>ConsoleLogger</c> with the name
              added after this loggers name, with a dot in between.
            </summary>
      <param name="loggerName">The added hierarchical name.</param>
      <returns>A new <c>ConsoleLogger</c>.</returns>
    </member>
    <member name="T:Castle.DynamicProxy.IChangeProxyTarget">
      <summary>
              Exposes means to change target objects of proxies and invocations
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.IChangeProxyTarget.ChangeInvocationTarget(System.Object)">
      <summary>
              Changes the target object (<see cref="P:Castle.DynamicProxy.IInvocation.InvocationTarget" />) of current <see cref="T:Castle.DynamicProxy.IInvocation" />.
            </summary>
      <param name="target">The new value of target of invocation.</param>
      <remarks>
              Although the method takes <see cref="T:System.Object" /> the actual instance must be of type assignable to <see cref="P:Castle.DynamicProxy.IInvocation.TargetType" />, otherwise an <see cref="T:System.InvalidCastException" /> will be thrown.
              Also while it's technically legal to pass null reference (Nothing in Visual Basic) as <paramref name="target" />, for obvious reasons Dynamic Proxy will not be able to call the intercepted method on such target.
              In this case last interceptor in the pipeline mustn't call <see cref="M:Castle.DynamicProxy.IInvocation.Proceed" /> or a <see cref="T:System.NotImplementedException" /> will be throws.
              Also while it's technically legal to pass proxy itself as <paramref name="target" />, this would create stack overflow.
              In this case last interceptor in the pipeline mustn't call <see cref="M:Castle.DynamicProxy.IInvocation.Proceed" /> or a <see cref="T:System.InvalidOperationException" /> will be throws.
            </remarks>
      <exception cref="T:System.InvalidCastException">Thrown when <paramref name="target" /> is not assignable to the proxied type.</exception>
    </member>
    <member name="M:Castle.DynamicProxy.IChangeProxyTarget.ChangeProxyTarget(System.Object)">
      <summary>
              Permanently changes the target object of the proxy. This does not affect target of the current invocation.
            </summary>
      <param name="target">The new value of target of the proxy.</param>
      <remarks>
              Although the method takes <see cref="T:System.Object" /> the actual instance must be of type assignable to proxy's target type, otherwise an <see cref="T:System.InvalidCastException" /> will be thrown.
              Also while it's technically legal to pass null reference (Nothing in Visual Basic) as <paramref name="target" />, for obvious reasons Dynamic Proxy will not be able to call the intercepted method on such target.
              In this case last interceptor in the pipeline mustn't call <see cref="M:Castle.DynamicProxy.IInvocation.Proceed" /> or a <see cref="T:System.NotImplementedException" /> will be throws.
              Also while it's technically legal to pass proxy itself as <paramref name="target" />, this would create stack overflow.
              In this case last interceptor in the pipeline mustn't call <see cref="M:Castle.DynamicProxy.IInvocation.Proceed" /> or a <see cref="T:System.InvalidOperationException" /> will be throws.
            </remarks>
      <exception cref="T:System.InvalidCastException">Thrown when <paramref name="target" /> is not assignable to the proxied type.</exception>
    </member>
    <member name="T:Castle.Core.IServiceProviderExAccessor">
      <summary>
            This interface should be implemented by classes
            that are available in a bigger context, exposing
            the container to different areas in the same application.
            <para>
            For example, in Web application, the (global) HttpApplication
            subclasses should implement this interface to expose 
            the configured container
            </para></summary>
    </member>
    <member name="T:Castle.DynamicProxy.Generators.Emitters.SimpleAST.ReferencesToObjectArrayExpression">
      <summary>
      </summary>
    </member>
    <member name="T:Castle.Core.Configuration.ConfigurationCollection">
      <summary>
            A collection of <see cref="T:Castle.Core.Configuration.IConfiguration" /> objects.
            </summary>
    </member>
    <member name="M:Castle.Core.Configuration.ConfigurationCollection.#ctor">
      <summary>
            Creates a new instance of <c>ConfigurationCollection</c>.
            </summary>
    </member>
    <member name="M:Castle.Core.Configuration.ConfigurationCollection.#ctor(System.Collections.Generic.IEnumerable{Castle.Core.Configuration.IConfiguration})">
      <summary>
            Creates a new instance of <c>ConfigurationCollection</c>.
            </summary>
    </member>
    <member name="T:Castle.Core.Logging.NullLogger">
      <summary>
              The Null Logger class.  This is useful for implementations where you need
              to provide a logger to a utility class, but do not want any output from it.
              It also helps when you have a utility that does not have a logger to supply.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.CreateChildLogger(System.String)">
      <summary>
              Returns this <c>NullLogger</c>.
            </summary>
      <param name="loggerName">Ignored</param>
      <returns>This ILogger instance.</returns>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Debug(System.String)">
      <summary>
              No-op.
            </summary>
      <param name="message">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Debug(System.String,System.Exception)">
      <summary>
              No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="message">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.DebugFormat(System.String,System.Object[])">
      <summary>
              No-op.
            </summary>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.DebugFormat(System.Exception,System.String,System.Object[])">
      <summary>
              No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.DebugFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
              No-op.
            </summary>
      <param name="formatProvider">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.DebugFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
              No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="formatProvider">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Error(System.String)">
      <summary>
              No-op.
            </summary>
      <param name="message">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Error(System.String,System.Exception)">
      <summary>
              No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="message">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.ErrorFormat(System.String,System.Object[])">
      <summary>
              No-op.
            </summary>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.ErrorFormat(System.Exception,System.String,System.Object[])">
      <summary>
              No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.ErrorFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
              No-op.
            </summary>
      <param name="formatProvider">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.ErrorFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
              No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="formatProvider">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Fatal(System.String)">
      <summary>
              No-op.
            </summary>
      <param name="message">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Fatal(System.String,System.Exception)">
      <summary>
              No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="message">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.FatalFormat(System.String,System.Object[])">
      <summary>
              No-op.
            </summary>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.FatalFormat(System.Exception,System.String,System.Object[])">
      <summary>
              No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.FatalFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
              No-op.
            </summary>
      <param name="formatProvider">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.FatalFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
              No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="formatProvider">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Info(System.String)">
      <summary>
              No-op.
            </summary>
      <param name="message">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Info(System.String,System.Exception)">
      <summary>
              No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="message">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.InfoFormat(System.String,System.Object[])">
      <summary>
              No-op.
            </summary>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.InfoFormat(System.Exception,System.String,System.Object[])">
      <summary>
              No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.InfoFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
              No-op.
            </summary>
      <param name="formatProvider">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.InfoFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
              No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="formatProvider">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Warn(System.String)">
      <summary>
              No-op.
            </summary>
      <param name="message">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Warn(System.String,System.Exception)">
      <summary>
              No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="message">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.WarnFormat(System.String,System.Object[])">
      <summary>
              No-op.
            </summary>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.WarnFormat(System.Exception,System.String,System.Object[])">
      <summary>
              No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.WarnFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
              No-op.
            </summary>
      <param name="formatProvider">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.WarnFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
              No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="formatProvider">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="P:Castle.Core.Logging.NullLogger.GlobalProperties">
      <summary>
              Returns empty context properties.
            </summary>
    </member>
    <member name="P:Castle.Core.Logging.NullLogger.ThreadProperties">
      <summary>
              Returns empty context properties.
            </summary>
    </member>
    <member name="P:Castle.Core.Logging.NullLogger.ThreadStacks">
      <summary>
              Returns empty context stacks.
            </summary>
    </member>
    <member name="P:Castle.Core.Logging.NullLogger.IsDebugEnabled">
      <summary>
              No-op.
            </summary>
      <value>false</value>
    </member>
    <member name="P:Castle.Core.Logging.NullLogger.IsErrorEnabled">
      <summary>
              No-op.
            </summary>
      <value>false</value>
    </member>
    <member name="P:Castle.Core.Logging.NullLogger.IsFatalEnabled">
      <summary>
              No-op.
            </summary>
      <value>false</value>
    </member>
    <member name="P:Castle.Core.Logging.NullLogger.IsInfoEnabled">
      <summary>
              No-op.
            </summary>
      <value>false</value>
    </member>
    <member name="P:Castle.Core.Logging.NullLogger.IsWarnEnabled">
      <summary>
              No-op.
            </summary>
      <value>false</value>
    </member>
    <member name="T:Castle.DynamicProxy.IInterceptor">
      <summary>
              New interface that is going to be used by DynamicProxy 2
            </summary>
    </member>
    <member name="T:Castle.DynamicProxy.ModuleScope">
      <summary>
              Summary description for ModuleScope.
            </summary>
    </member>
    <member name="F:Castle.DynamicProxy.ModuleScope.DEFAULT_FILE_NAME">
      <summary>
              The default file name used when the assembly is saved using <see cref="F:Castle.DynamicProxy.ModuleScope.DEFAULT_FILE_NAME" />.
            </summary>
    </member>
    <member name="F:Castle.DynamicProxy.ModuleScope.DEFAULT_ASSEMBLY_NAME">
      <summary>
              The default assembly (simple) name used for the assemblies generated by a <see cref="T:Castle.DynamicProxy.ModuleScope" /> instance.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.ModuleScope.#ctor">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.DynamicProxy.ModuleScope" /> class; assemblies created by this instance will not be saved.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.ModuleScope.#ctor(System.Boolean)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.DynamicProxy.ModuleScope" /> class, allowing to specify whether the assemblies generated by this instance
              should be saved.
            </summary>
      <param name="savePhysicalAssembly">If set to <c>true</c> saves the generated module.</param>
    </member>
    <member name="M:Castle.DynamicProxy.ModuleScope.#ctor(System.Boolean,System.Boolean)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.DynamicProxy.ModuleScope" /> class, allowing to specify whether the assemblies generated by this instance
              should be saved.
            </summary>
      <param name="savePhysicalAssembly">If set to <c>true</c> saves the generated module.</param>
      <param name="disableSignedModule">If set to <c>true</c> disables ability to generate signed module. This should be used in cases where ran under constrained permissions.</param>
    </member>
    <member name="M:Castle.DynamicProxy.ModuleScope.#ctor(System.Boolean,System.Boolean,System.String,System.String,System.String,System.String)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.DynamicProxy.ModuleScope" /> class, allowing to specify whether the assemblies generated by this instance
              should be saved and what simple names are to be assigned to them.
            </summary>
      <param name="savePhysicalAssembly">If set to <c>true</c> saves the generated module.</param>
      <param name="disableSignedModule">If set to <c>true</c> disables ability to generate signed module. This should be used in cases where ran under constrained permissions.</param>
      <param name="strongAssemblyName">The simple name of the strong-named assembly generated by this <see cref="T:Castle.DynamicProxy.ModuleScope" />.</param>
      <param name="strongModulePath">The path and file name of the manifest module of the strong-named assembly generated by this <see cref="T:Castle.DynamicProxy.ModuleScope" />.</param>
      <param name="weakAssemblyName">The simple name of the weak-named assembly generated by this <see cref="T:Castle.DynamicProxy.ModuleScope" />.</param>
      <param name="weakModulePath">The path and file name of the manifest module of the weak-named assembly generated by this <see cref="T:Castle.DynamicProxy.ModuleScope" />.</param>
    </member>
    <member name="M:Castle.DynamicProxy.ModuleScope.#ctor(System.Boolean,System.Boolean,Castle.DynamicProxy.Generators.INamingScope,System.String,System.String,System.String,System.String)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.DynamicProxy.ModuleScope" /> class, allowing to specify whether the assemblies generated by this instance
              should be saved and what simple names are to be assigned to them.
            </summary>
      <param name="savePhysicalAssembly">If set to <c>true</c> saves the generated module.</param>
      <param name="disableSignedModule">If set to <c>true</c> disables ability to generate signed module. This should be used in cases where ran under constrained permissions.</param>
      <param name="namingScope">Naming scope used to provide unique names to generated types and their members (usually via sub-scopes).</param>
      <param name="strongAssemblyName">The simple name of the strong-named assembly generated by this <see cref="T:Castle.DynamicProxy.ModuleScope" />.</param>
      <param name="strongModulePath">The path and file name of the manifest module of the strong-named assembly generated by this <see cref="T:Castle.DynamicProxy.ModuleScope" />.</param>
      <param name="weakAssemblyName">The simple name of the weak-named assembly generated by this <see cref="T:Castle.DynamicProxy.ModuleScope" />.</param>
      <param name="weakModulePath">The path and file name of the manifest module of the weak-named assembly generated by this <see cref="T:Castle.DynamicProxy.ModuleScope" />.</param>
    </member>
    <member name="M:Castle.DynamicProxy.ModuleScope.GetFromCache(Castle.DynamicProxy.Generators.CacheKey)">
      <summary>
              Returns a type from this scope's type cache, or null if the key cannot be found.
            </summary>
      <param name="key">The key to be looked up in the cache.</param>
      <returns>The type from this scope's type cache matching the key, or null if the key cannot be found</returns>
    </member>
    <member name="M:Castle.DynamicProxy.ModuleScope.RegisterInCache(Castle.DynamicProxy.Generators.CacheKey,System.Type)">
      <summary>
              Registers a type in this scope's type cache.
            </summary>
      <param name="key">The key to be associated with the type.</param>
      <param name="type">The type to be stored in the cache.</param>
    </member>
    <member name="M:Castle.DynamicProxy.ModuleScope.GetKeyPair">
      <summary>
              Gets the key pair used to sign the strong-named assembly generated by this <see cref="T:Castle.DynamicProxy.ModuleScope" />.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.DynamicProxy.ModuleScope.ObtainDynamicModule(System.Boolean)">
      <summary>
              Gets the specified module generated by this scope, creating a new one if none has yet been generated.
            </summary>
      <param name="isStrongNamed">If set to true, a strong-named module is returned; otherwise, a weak-named module is returned.</param>
      <returns>A strong-named or weak-named module generated by this scope, as specified by the <paramref name="isStrongNamed" /> parameter.</returns>
    </member>
    <member name="M:Castle.DynamicProxy.ModuleScope.ObtainDynamicModuleWithStrongName">
      <summary>
              Gets the strong-named module generated by this scope, creating a new one if none has yet been generated.
            </summary>
      <returns>A strong-named module generated by this scope.</returns>
    </member>
    <member name="M:Castle.DynamicProxy.ModuleScope.ObtainDynamicModuleWithWeakName">
      <summary>
              Gets the weak-named module generated by this scope, creating a new one if none has yet been generated.
            </summary>
      <returns>A weak-named module generated by this scope.</returns>
    </member>
    <member name="P:Castle.DynamicProxy.ModuleScope.Lock">
      <summary>
              Users of this <see cref="T:Castle.DynamicProxy.ModuleScope" /> should use this lock when accessing the cache.
            </summary>
    </member>
    <member name="P:Castle.DynamicProxy.ModuleScope.StrongNamedModule">
      <summary>
              Gets the strong-named module generated by this scope, or <see langword="null" /> if none has yet been generated.
            </summary>
      <value>The strong-named module generated by this scope, or <see langword="null" /> if none has yet been generated.</value>
    </member>
    <member name="P:Castle.DynamicProxy.ModuleScope.StrongNamedModuleName">
      <summary>
              Gets the file name of the strongly named module generated by this scope.
            </summary>
      <value>The file name of the strongly named module generated by this scope.</value>
    </member>
    <member name="P:Castle.DynamicProxy.ModuleScope.WeakNamedModule">
      <summary>
              Gets the weak-named module generated by this scope, or <see langword="null" /> if none has yet been generated.
            </summary>
      <value>The weak-named module generated by this scope, or <see langword="null" /> if none has yet been generated.</value>
    </member>
    <member name="P:Castle.DynamicProxy.ModuleScope.WeakNamedModuleName">
      <summary>
              Gets the file name of the weakly named module generated by this scope.
            </summary>
      <value>The file name of the weakly named module generated by this scope.</value>
    </member>
    <member name="T:Castle.Core.Resource.FileResource">
      <summary>
      </summary>
    </member>
    <member name="T:Castle.Core.ReflectionBasedDictionaryAdapter">
      <summary>
            Readonly implementation of <see cref="T:System.Collections.IDictionary" /> which uses an anonymous object as its source. Uses names of properties as keys, and property values as... well - values. Keys are not case sensitive.
            </summary>
    </member>
    <member name="M:Castle.Core.ReflectionBasedDictionaryAdapter.#ctor(System.Object)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.Core.ReflectionBasedDictionaryAdapter" /> class.
            </summary>
      <param name="target">The target.</param>
    </member>
    <member name="M:Castle.Core.ReflectionBasedDictionaryAdapter.Add(System.Object,System.Object)">
      <summary>
              Adds an element with the provided key and value to the <see cref="T:System.Collections.IDictionary" /> object.
            </summary>
      <param name="key">The <see cref="T:System.Object" /> to use as the key of the element to add.</param>
      <param name="value">The <see cref="T:System.Object" /> to use as the value of the element to add.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> is null. </exception>
      <exception cref="T:System.ArgumentException">An element with the same key already exists in the <see cref="T:System.Collections.IDictionary" /> object. </exception>
      <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.IDictionary" /> is read-only.-or- The <see cref="T:System.Collections.IDictionary" /> has a fixed size. </exception>
    </member>
    <member name="M:Castle.Core.ReflectionBasedDictionaryAdapter.Clear">
      <summary>
              Removes all elements from the <see cref="T:System.Collections.IDictionary" /> object.
            </summary>
      <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.IDictionary" /> object is read-only. </exception>
    </member>
    <member name="M:Castle.Core.ReflectionBasedDictionaryAdapter.Contains(System.Object)">
      <summary>
              Determines whether the <see cref="T:System.Collections.IDictionary" /> object contains an element with the specified key.
            </summary>
      <param name="key">The key to locate in the <see cref="T:System.Collections.IDictionary" /> object.</param>
      <returns>
              true if the <see cref="T:System.Collections.IDictionary" /> contains an element with the key; otherwise, false.
            </returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> is null. </exception>
    </member>
    <member name="M:Castle.Core.ReflectionBasedDictionaryAdapter.Remove(System.Object)">
      <summary>
              Removes the element with the specified key from the <see cref="T:System.Collections.IDictionary" /> object.
            </summary>
      <param name="key">The key of the element to remove.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> is null. </exception>
      <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.IDictionary" /> object is read-only.-or- The <see cref="T:System.Collections.IDictionary" /> has a fixed size. </exception>
    </member>
    <member name="M:Castle.Core.ReflectionBasedDictionaryAdapter.GetEnumerator">
      <summary>
              Returns an enumerator that iterates through a collection.
            </summary>
      <returns>
              An <see cref="T:System.Collections.IEnumerator" /> object that can be used to iterate through the collection.
            </returns>
    </member>
    <member name="M:Castle.Core.ReflectionBasedDictionaryAdapter.Read(System.Collections.IDictionary,System.Object)">
      <summary>
              Reads values of properties from <paramref name="valuesAsAnonymousObject" /> and inserts them into <paramref name="targetDictionary" /> using property names as keys.
            </summary>
      <param name="targetDictionary">
      </param>
      <param name="valuesAsAnonymousObject">
      </param>
    </member>
    <member name="P:Castle.Core.ReflectionBasedDictionaryAdapter.Count">
      <summary>
              Gets the number of elements contained in the <see cref="T:System.Collections.ICollection" />.
            </summary>
      <value>
      </value>
      <returns>The number of elements contained in the <see cref="T:System.Collections.ICollection" />.</returns>
    </member>
    <member name="P:Castle.Core.ReflectionBasedDictionaryAdapter.IsSynchronized">
      <summary>
              Gets a value indicating whether access to the <see cref="T:System.Collections.ICollection" /> is synchronized (thread safe).
            </summary>
      <value>
      </value>
      <returns>true if access to the <see cref="T:System.Collections.ICollection" /> is synchronized (thread safe); otherwise, false.</returns>
    </member>
    <member name="P:Castle.Core.ReflectionBasedDictionaryAdapter.SyncRoot">
      <summary>
              Gets an object that can be used to synchronize access to the <see cref="T:System.Collections.ICollection" />.
            </summary>
      <value>
      </value>
      <returns>An object that can be used to synchronize access to the <see cref="T:System.Collections.ICollection" />.</returns>
    </member>
    <member name="P:Castle.Core.ReflectionBasedDictionaryAdapter.IsReadOnly">
      <summary>
              Gets a value indicating whether the <see cref="T:System.Collections.IDictionary" /> object is read-only.
            </summary>
      <value>
      </value>
      <returns>true if the <see cref="T:System.Collections.IDictionary" /> object is read-only; otherwise, false.</returns>
    </member>
    <member name="P:Castle.Core.ReflectionBasedDictionaryAdapter.Item(System.Object)">
      <summary>
              Gets or sets the <see cref="T:System.Object" /> with the specified key.
            </summary>
      <value>
      </value>
    </member>
    <member name="P:Castle.Core.ReflectionBasedDictionaryAdapter.Keys">
      <summary>
              Gets an <see cref="T:System.Collections.ICollection" /> object containing the keys of the <see cref="T:System.Collections.IDictionary" /> object.
            </summary>
      <value>
      </value>
      <returns>An <see cref="T:System.Collections.ICollection" /> object containing the keys of the <see cref="T:System.Collections.IDictionary" /> object.</returns>
    </member>
    <member name="P:Castle.Core.ReflectionBasedDictionaryAdapter.Values">
      <summary>
              Gets an <see cref="T:System.Collections.ICollection" /> object containing the values in the <see cref="T:System.Collections.IDictionary" /> object.
            </summary>
      <value>
      </value>
      <returns>An <see cref="T:System.Collections.ICollection" /> object containing the values in the <see cref="T:System.Collections.IDictionary" /> object.</returns>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.AbstractDictionaryAdapterVisitor">
      <summary>
            Abstract implementation of <see cref="T:Castle.Components.DictionaryAdapter.IDictionaryAdapterVisitor" />.
            </summary>
    </member>
    <member name="T:Castle.Core.ProxyServices">
      <summary>
            List of utility methods related to dynamic proxy operations
            </summary>
    </member>
    <member name="M:Castle.Core.ProxyServices.IsDynamicProxy(System.Type)">
      <summary>
            Determines whether the specified type is a proxy generated by
            DynamicProxy (1 or 2).
            </summary>
      <param name="type">The type.</param>
      <returns>
        <c>true</c> if it is a proxy; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="T:Castle.Core.Logging.StreamLogger">
      <summary>
            The Stream Logger class.  This class can stream log information
            to any stream, it is suitable for storing a log file to disk,
            or to a <c>MemoryStream</c> for testing your components.
            </summary>
      <remarks>
            This logger is not thread safe.
            </remarks>
    </member>
    <member name="M:Castle.Core.Logging.StreamLogger.#ctor(System.String,System.IO.Stream)">
      <summary>
              Creates a new <c>StreamLogger</c> with default encoding 
              and buffer size. Initial Level is set to Debug.
            </summary>
      <param name="name">
              The name of the log.
            </param>
      <param name="stream">
              The stream that will be used for logging,
              seeking while the logger is alive 
            </param>
    </member>
    <member name="M:Castle.Core.Logging.StreamLogger.#ctor(System.String,System.IO.Stream,System.Text.Encoding)">
      <summary>
              Creates a new <c>StreamLogger</c> with default buffer size.
              Initial Level is set to Debug.
            </summary>
      <param name="name">
              The name of the log.
            </param>
      <param name="stream">
              The stream that will be used for logging,
              seeking while the logger is alive 
            </param>
      <param name="encoding">
              The encoding that will be used for this stream.
              <see cref="T:System.IO.StreamWriter" /></param>
    </member>
    <member name="M:Castle.Core.Logging.StreamLogger.#ctor(System.String,System.IO.Stream,System.Text.Encoding,System.Int32)">
      <summary>
              Creates a new <c>StreamLogger</c>. 
              Initial Level is set to Debug.
            </summary>
      <param name="name">
              The name of the log.
            </param>
      <param name="stream">
              The stream that will be used for logging,
              seeking while the logger is alive 
            </param>
      <param name="encoding">
              The encoding that will be used for this stream.
              <see cref="T:System.IO.StreamWriter" /></param>
      <param name="bufferSize">
              The buffer size that will be used for this stream.
              <see cref="T:System.IO.StreamWriter" /></param>
    </member>
    <member name="M:Castle.Core.Logging.StreamLogger.#ctor(System.String,System.IO.StreamWriter)">
      <summary>
              Creates a new <c>StreamLogger</c> with 
              Debug as default Level.
            </summary>
      <param name="name">The name of the log.</param>
      <param name="writer">The <c>StreamWriter</c> the log will write to.</param>
    </member>
    <member name="T:Castle.DynamicProxy.ProxyGenerator">
      <summary>
              Provides proxy objects for classes and interfaces.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.#ctor(Castle.DynamicProxy.IProxyBuilder)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.DynamicProxy.ProxyGenerator" /> class.
            </summary>
      <param name="builder">Proxy types builder.</param>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.#ctor">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.DynamicProxy.ProxyGenerator" /> class.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.#ctor(System.Boolean)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.DynamicProxy.ProxyGenerator" /> class.
            </summary>
      <param name="disableSignedModule">If <c>true</c> forces all types to be generated into an unsigned module.</param>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTarget``1(``0,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to members of interface <typeparamref name="TInterface" /> on <paramref name="target" /> object with given <paramref name="interceptors" />.
            </summary>
      <typeparam name="TInterface">Type of the interface implemented by <paramref name="target" /> which will be proxied.</typeparam>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>Object proxying calls to members of <typeparamref name="TInterface" /> on <paramref name="target" /> object.</returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="target" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <typeparamref name="TInterface" />is not an interface type.</exception>
      <exception cref="T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref name="target" /> object.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref name="target" /> throws an exception.</exception>
      <remarks>
              This method generates new proxy type for each type of <paramref name="target" />, which affects performance. If you don't want to proxy types differently depending on the type of the target
              use <see cref="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface``1(``0,Castle.DynamicProxy.IInterceptor[])" /> method.
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTarget``1(``0,Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to members of interface <typeparamref name="TInterface" /> on <paramref name="target" /> object with given <paramref name="interceptors" />.
            </summary>
      <typeparam name="TInterface">Type of the interface implemented by <paramref name="target" /> which will be proxied.</typeparam>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              Object proxying calls to members of <typeparamref name="TInterface" /> on <paramref name="target" /> object.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="target" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <typeparamref name="TInterface" />is not an interface type.</exception>
      <exception cref="T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref name="target" /> object.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref name="target" /> throws an exception.</exception>
      <remarks>
              This method generates new proxy type for each type of <paramref name="target" />, which affects performance. If you don't want to proxy types differently depending on the type of the target
              use <see cref="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface``1(``0,Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])" /> method.
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTarget(System.Type,System.Object,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to members of interface <paramref name="interfaceToProxy" /> on <paramref name="target" /> object with given <paramref name="interceptors" />.
            </summary>
      <param name="interfaceToProxy">Type of the interface implemented by <paramref name="target" /> which will be proxied.</param>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              Object proxying calls to members of <paramref name="interfaceToProxy" /> type on <paramref name="target" /> object.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="target" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is not an interface type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="target" /> does not implement <paramref name="interfaceToProxy" /> interface.</exception>
      <exception cref="T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref name="target" /> object.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref name="target" /> throws an exception.</exception>
      <remarks>
              This method generates new proxy type for each type of <paramref name="target" />, which affects performance. If you don't want to proxy types differently depending on the type of the target
              use <see cref="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface(System.Type,System.Object,Castle.DynamicProxy.IInterceptor[])" /> method.
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTarget(System.Type,System.Object,Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to members of interface <paramref name="interfaceToProxy" /> on <paramref name="target" /> object with given <paramref name="interceptors" />.
            </summary>
      <param name="interfaceToProxy">Type of the interface implemented by <paramref name="target" /> which will be proxied.</param>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              Object proxying calls to members of <paramref name="interfaceToProxy" /> type on <paramref name="target" /> object.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="target" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is not an interface type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="target" /> does not implement <paramref name="interfaceToProxy" /> interface.</exception>
      <exception cref="T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref name="target" /> object.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref name="target" /> throws an exception.</exception>
      <remarks>
              This method generates new proxy type for each type of <paramref name="target" />, which affects performance. If you don't want to proxy types differently depending on the type of the target
              use <see cref="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface(System.Type,System.Object,Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])" /> method.
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTarget(System.Type,System.Type[],System.Object,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to members of interface <paramref name="interfaceToProxy" /> on <paramref name="target" /> object with given <paramref name="interceptors" />.
            </summary>
      <param name="interfaceToProxy">Type of the interface implemented by <paramref name="target" /> which will be proxied.</param>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              Object proxying calls to members of <paramref name="interfaceToProxy" /> and <paramref name="additionalInterfacesToProxy" /> types  on <paramref name="target" /> object.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="target" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is not an interface type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="target" /> does not implement <paramref name="interfaceToProxy" /> interface.</exception>
      <exception cref="T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref name="target" /> object.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref name="target" /> throws an exception.</exception>
      <remarks>
              This method generates new proxy type for each type of <paramref name="target" />, which affects performance. If you don't want to proxy types differently depending on the type of the target
              use <see cref="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface(System.Type,System.Type[],System.Object,Castle.DynamicProxy.IInterceptor[])" /> method.
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTarget(System.Type,System.Type[],System.Object,Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to members of interface <paramref name="interfaceToProxy" /> on <paramref name="target" /> object with given <paramref name="interceptors" />.
            </summary>
      <param name="interfaceToProxy">Type of the interface implemented by <paramref name="target" /> which will be proxied.</param>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              Object proxying calls to members of <paramref name="interfaceToProxy" /> and <paramref name="additionalInterfacesToProxy" /> types on <paramref name="target" /> object.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="target" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is not an interface type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="target" /> does not implement <paramref name="interfaceToProxy" /> interface.</exception>
      <exception cref="T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref name="target" /> object.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref name="target" /> throws an exception.</exception>
      <remarks>
              This method generates new proxy type for each type of <paramref name="target" />, which affects performance. If you don't want to proxy types differently depending on the type of the target
              use <see cref="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface(System.Type,System.Type[],System.Object,Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])" /> method.
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface(System.Type,System.Object,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to members of interface <paramref name="interfaceToProxy" /> on <paramref name="target" /> object with given <paramref name="interceptors" />.
              Interceptors can use <see cref="T:Castle.DynamicProxy.IChangeProxyTarget" /> interface to provide other target for method invocation than default <paramref name="target" />.
            </summary>
      <param name="interfaceToProxy">Type of the interface implemented by <paramref name="target" /> which will be proxied.</param>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              Object proxying calls to members of <paramref name="interfaceToProxy" /> type on <paramref name="target" /> object or alternative implementation swapped at runtime by an interceptor.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="target" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is not an interface type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="target" /> does not implement <paramref name="interfaceToProxy" /> interface.</exception>
      <exception cref="T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref name="target" /> object.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref name="target" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface``1(``0,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to members of interface <typeparamref name="TInterface" /> on <paramref name="target" /> object with given <paramref name="interceptors" />.
              Interceptors can use <see cref="T:Castle.DynamicProxy.IChangeProxyTarget" /> interface to provide other target for method invocation than default <paramref name="target" />.
            </summary>
      <typeparam name="TInterface">Type of the interface implemented by <paramref name="target" /> which will be proxied.</typeparam>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              Object proxying calls to members of <typeparamref name="TInterface" /> type on <paramref name="target" /> object or alternative implementation swapped at runtime by an interceptor.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="target" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <typeparamref name="TInterface" /> is not an interface type.</exception>
      <exception cref="T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref name="target" /> object.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref name="target" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface``1(``0,Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to members of interface <typeparamref name="TInterface" /> on <paramref name="target" /> object with given <paramref name="interceptors" />.
              Interceptors can use <see cref="T:Castle.DynamicProxy.IChangeProxyTarget" /> interface to provide other target for method invocation than default <paramref name="target" />.
            </summary>
      <typeparam name="TInterface">Type of the interface implemented by <paramref name="target" /> which will be proxied.</typeparam>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              Object proxying calls to members of <typeparamref name="TInterface" /> type on <paramref name="target" /> object or alternative implementation swapped at runtime by an interceptor.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="target" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <typeparamref name="TInterface" /> is not an interface type.</exception>
      <exception cref="T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref name="target" /> object.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref name="target" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface(System.Type,System.Type[],System.Object,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to members of interface <paramref name="interfaceToProxy" /> on <paramref name="target" /> object with given <paramref name="interceptors" />.
              Interceptors can use <see cref="T:Castle.DynamicProxy.IChangeProxyTarget" /> interface to provide other target for method invocation than default <paramref name="target" />.
            </summary>
      <param name="interfaceToProxy">Type of the interface implemented by <paramref name="target" /> which will be proxied.</param>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              Object proxying calls to members of <paramref name="interfaceToProxy" /> and <paramref name="additionalInterfacesToProxy" /> types on <paramref name="target" /> object or alternative implementation swapped at runtime by an interceptor.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="target" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is not an interface type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="target" /> does not implement <paramref name="interfaceToProxy" /> interface.</exception>
      <exception cref="T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref name="target" /> object.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref name="target" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface(System.Type,System.Object,Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to members of interface <paramref name="interfaceToProxy" /> on <paramref name="target" /> object with given <paramref name="interceptors" />.
              Interceptors can use <see cref="T:Castle.DynamicProxy.IChangeProxyTarget" /> interface to provide other target for method invocation than default <paramref name="target" />.
            </summary>
      <param name="interfaceToProxy">Type of the interface implemented by <paramref name="target" /> which will be proxied.</param>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              Object proxying calls to members of <paramref name="interfaceToProxy" /> type on <paramref name="target" /> object or alternative implementation swapped at runtime by an interceptor.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="target" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is not an interface type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="target" /> does not implement <paramref name="interfaceToProxy" /> interface.</exception>
      <exception cref="T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref name="target" /> object.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref name="target" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface(System.Type,System.Type[],System.Object,Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to members of interface <paramref name="interfaceToProxy" /> on <paramref name="target" /> object with given <paramref name="interceptors" />.
              Interceptors can use <see cref="T:Castle.DynamicProxy.IChangeProxyTarget" /> interface to provide other target for method invocation than default <paramref name="target" />.
            </summary>
      <param name="interfaceToProxy">Type of the interface implemented by <paramref name="target" /> which will be proxied.</param>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              Object proxying calls to members of <paramref name="interfaceToProxy" /> and <paramref name="additionalInterfacesToProxy" /> types on <paramref name="target" /> object or alternative implementation swapped at runtime by an interceptor.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="target" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is not an interface type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="target" /> does not implement <paramref name="interfaceToProxy" /> interface.</exception>
      <exception cref="T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref name="target" /> object.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref name="target" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithoutTarget``1(Castle.DynamicProxy.IInterceptor)">
      <summary>
              Creates proxy object intercepting calls to members of interface <typeparamref name="TInterface" /> on target object generated at runtime with given <paramref name="interceptor" />.
            </summary>
      <typeparam name="TInterface">Type of the interface which will be proxied.</typeparam>
      <param name="interceptor">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              Object proxying calls to members of <typeparamref name="TInterface" /> types on generated target object.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptor" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <typeparamref name="TInterface" /> is not an interface type.</exception>
      <remarks>
              Since this method uses an empty-shell implementation of interfaces to proxy generated at runtime, the actual implementation of proxied methods must be provided by given <see cref="T:Castle.DynamicProxy.IInterceptor" /> implementations.
              They are responsible for setting return value (and out parameters) on proxied methods. It is also illegal for an interceptor to call <see cref="M:Castle.DynamicProxy.IInvocation.Proceed" />, since there's no actual implementation to proceed with.
              As a result of that also at least one <see cref="T:Castle.DynamicProxy.IInterceptor" /> implementation must be provided.
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithoutTarget``1(Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to members of interface <typeparamref name="TInterface" /> on target object generated at runtime with given <paramref name="interceptors" />.
            </summary>
      <typeparam name="TInterface">Type of the interface which will be proxied.</typeparam>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              Object proxying calls to members of <typeparamref name="TInterface" /> types on generated target object.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <typeparamref name="TInterface" /> is not an interface type.</exception>
      <remarks>
              Since this method uses an empty-shell implementation of interfaces to proxy generated at runtime, the actual implementation of proxied methods must be provided by given <see cref="T:Castle.DynamicProxy.IInterceptor" /> implementations.
              They are responsible for setting return value (and out parameters) on proxied methods. It is also illegal for an interceptor to call <see cref="M:Castle.DynamicProxy.IInvocation.Proceed" />, since there's no actual implementation to proceed with.
              As a result of that also at least one <see cref="T:Castle.DynamicProxy.IInterceptor" /> implementation must be provided.
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithoutTarget``1(Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to members of interface <typeparamref name="TInterface" /> on target object generated at runtime with given <paramref name="interceptors" />.
            </summary>
      <typeparam name="TInterface">Type of the interface which will be proxied.</typeparam>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              Object proxying calls to members of <typeparamref name="TInterface" /> types on generated target object.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <typeparamref name="TInterface" /> is not an interface type.</exception>
      <remarks>
              Since this method uses an empty-shell implementation of interfaces to proxy generated at runtime, the actual implementation of proxied methods must be provided by given <see cref="T:Castle.DynamicProxy.IInterceptor" /> implementations.
              They are responsible for setting return value (and out parameters) on proxied methods. It is also illegal for an interceptor to call <see cref="M:Castle.DynamicProxy.IInvocation.Proceed" />, since there's no actual implementation to proceed with.
              As a result of that also at least one <see cref="T:Castle.DynamicProxy.IInterceptor" /> implementation must be provided.
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithoutTarget(System.Type,Castle.DynamicProxy.IInterceptor)">
      <summary>
              Creates proxy object intercepting calls to members of interface <paramref name="interfaceToProxy" /> on target object generated at runtime with given <paramref name="interceptor" />.
            </summary>
      <param name="interfaceToProxy">Type of the interface which will be proxied.</param>
      <param name="interceptor">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              Object proxying calls to members of <paramref name="interfaceToProxy" /> type on generated target object.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptor" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is not an interface type.</exception>
      <remarks>
              Since this method uses an empty-shell implementation of interfaces to proxy generated at runtime, the actual implementation of proxied methods must be provided by given <see cref="T:Castle.DynamicProxy.IInterceptor" /> implementations.
              They are responsible for setting return value (and out parameters) on proxied methods. It is also illegal for an interceptor to call <see cref="M:Castle.DynamicProxy.IInvocation.Proceed" />, since there's no actual implementation to proceed with.
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithoutTarget(System.Type,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to members of interface <paramref name="interfaceToProxy" /> on target object generated at runtime with given <paramref name="interceptors" />.
            </summary>
      <param name="interfaceToProxy">Type of the interface which will be proxied.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              Object proxying calls to members of <paramref name="interfaceToProxy" /> type on generated target object.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is not an interface type.</exception>
      <remarks>
              Since this method uses an empty-shell implementation of interfaces to proxy generated at runtime, the actual implementation of proxied methods must be provided by given <see cref="T:Castle.DynamicProxy.IInterceptor" /> implementations.
              They are responsible for setting return value (and out parameters) on proxied methods. It is also illegal for an interceptor to call <see cref="M:Castle.DynamicProxy.IInvocation.Proceed" />, since there's no actual implementation to proceed with.
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithoutTarget(System.Type,System.Type[],Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to members of interface <paramref name="interfaceToProxy" /> on target object generated at runtime with given <paramref name="interceptors" />.
            </summary>
      <param name="interfaceToProxy">Type of the interface which will be proxied.</param>
      <param name="additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              Object proxying calls to members of <paramref name="interfaceToProxy" /> and <paramref name="additionalInterfacesToProxy" /> types on generated target object.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is not an interface type.</exception>
      <remarks>
              Since this method uses an empty-shell implementation of interfaces to proxy generated at runtime, the actual implementation of proxied methods must be provided by given <see cref="T:Castle.DynamicProxy.IInterceptor" /> implementations.
              They are responsible for setting return value (and out parameters) on proxied methods. It is also illegal for an interceptor to call <see cref="M:Castle.DynamicProxy.IInvocation.Proceed" />, since there's no actual implementation to proceed with.
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithoutTarget(System.Type,Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to members of interface <paramref name="interfaceToProxy" /> on target object generated at runtime with given <paramref name="interceptors" />.
            </summary>
      <param name="interfaceToProxy">Type of the interface which will be proxied.</param>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              Object proxying calls to members of <paramref name="interfaceToProxy" /> on generated target object.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" />  is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is not an interface type.</exception>
      <remarks>
              They are responsible for setting return value (and out parameters) on proxied methods. It is also illegal for an interceptor to call <see cref="M:Castle.DynamicProxy.IInvocation.Proceed" />, since there's no actual implementation to proceed with.
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithoutTarget(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to members of interface <paramref name="interfaceToProxy" /> on target object generated at runtime with given <paramref name="interceptors" />.
            </summary>
      <param name="interfaceToProxy">Type of the interface which will be proxied.</param>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              Object proxying calls to members of <paramref name="interfaceToProxy" /> and <paramref name="additionalInterfacesToProxy" /> types on generated target object.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is not an interface type.</exception>
      <remarks>
              Since this method uses an empty-shell implementation of <paramref name="additionalInterfacesToProxy" /> to proxy generated at runtime, the actual implementation of proxied methods must be provided by given <see cref="T:Castle.DynamicProxy.IInterceptor" /> implementations.
              They are responsible for setting return value (and out parameters) on proxied methods. It is also illegal for an interceptor to call <see cref="M:Castle.DynamicProxy.IInvocation.Proceed" />, since there's no actual implementation to proceed with.
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxyWithTarget``1(``0,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to virtual members of type <typeparamref name="TClass" /> on newly created instance of that type with given <paramref name="interceptors" />.
            </summary>
      <typeparam name="TClass">Type of class which will be proxied.</typeparam>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              New object of type <typeparamref name="TClass" /> proxying calls to virtual members of <typeparamref name="TClass" /> type.
            </returns>
      <exception cref="T:System.ArgumentException">Thrown when given <typeparamref name="TClass" /> is not a class type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when no default constructor exists on type <typeparamref name="TClass" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of type <typeparamref name="TClass" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxyWithTarget``1(``0,Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to virtual members of type <typeparamref name="TClass" /> on newly created instance of that type with given <paramref name="interceptors" />.
            </summary>
      <typeparam name="TClass">Type of class which will be proxied.</typeparam>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              New object of type <typeparamref name="TClass" /> proxying calls to virtual members of <typeparamref name="TClass" /> type.
            </returns>
      <exception cref="T:System.ArgumentException">Thrown when given <typeparamref name="TClass" /> is not a class type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when no default constructor exists on type <typeparamref name="TClass" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of type <typeparamref name="TClass" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxyWithTarget(System.Type,System.Type[],System.Object,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to virtual members of type <paramref name="classToProxy" /> on newly created instance of that type with given <paramref name="interceptors" />.
            </summary>
      <param name="classToProxy">Type of class which will be proxied.</param>
      <param name="additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              New object of type <paramref name="classToProxy" /> proxying calls to virtual members of <paramref name="classToProxy" /> and <paramref name="additionalInterfacesToProxy" /> types.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is not a class type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when no default constructor exists on type <paramref name="classToProxy" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of type <paramref name="classToProxy" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxyWithTarget(System.Type,System.Object,Castle.DynamicProxy.ProxyGenerationOptions,System.Object[],Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to virtual members of type <paramref name="classToProxy" /> on newly created instance of that type with given <paramref name="interceptors" />.
            </summary>
      <param name="classToProxy">Type of class which will be proxied.</param>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="constructorArguments">Arguments of constructor of type <paramref name="classToProxy" /> which should be used to create a new instance of that type.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              New object of type <paramref name="classToProxy" /> proxying calls to virtual members of <paramref name="classToProxy" /> type.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is not a class type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when no constructor exists on type <paramref name="classToProxy" /> with parameters matching <paramref name="constructorArguments" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when constructor of type <paramref name="classToProxy" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxyWithTarget(System.Type,System.Object,System.Object[],Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to virtual members of type <paramref name="classToProxy" /> on newly created instance of that type with given <paramref name="interceptors" />.
            </summary>
      <param name="classToProxy">Type of class which will be proxied.</param>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="constructorArguments">Arguments of constructor of type <paramref name="classToProxy" /> which should be used to create a new instance of that type.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              New object of type <paramref name="classToProxy" /> proxying calls to virtual members of <paramref name="classToProxy" /> type.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is not a class type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when no constructor exists on type <paramref name="classToProxy" /> with parameters matching <paramref name="constructorArguments" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when constructor of type <paramref name="classToProxy" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxyWithTarget(System.Type,System.Object,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to virtual members of type <paramref name="classToProxy" /> on newly created instance of that type with given <paramref name="interceptors" />.
            </summary>
      <param name="classToProxy">Type of class which will be proxied.</param>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              New object of type <paramref name="classToProxy" /> proxying calls to virtual members of <paramref name="classToProxy" /> type.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is not a class type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when no parameterless constructor exists on type <paramref name="classToProxy" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when constructor of type <paramref name="classToProxy" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxyWithTarget(System.Type,System.Object,Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to virtual members of type <paramref name="classToProxy" /> on newly created instance of that type with given <paramref name="interceptors" />.
            </summary>
      <param name="classToProxy">Type of class which will be proxied.</param>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              New object of type <paramref name="classToProxy" /> proxying calls to virtual members of <paramref name="classToProxy" /> type.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="options" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is not a class type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when no default constructor exists on type <paramref name="classToProxy" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of type <paramref name="classToProxy" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxyWithTarget(System.Type,System.Type[],System.Object,Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to virtual members of type <paramref name="classToProxy" /> on newly created instance of that type with given <paramref name="interceptors" />.
            </summary>
      <param name="classToProxy">Type of class which will be proxied.</param>
      <param name="additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              New object of type <paramref name="classToProxy" /> proxying calls to virtual members of <paramref name="classToProxy" /> and <paramref name="additionalInterfacesToProxy" /> types.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="options" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is not a class type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when no default constructor exists on type <paramref name="classToProxy" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of type <paramref name="classToProxy" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxyWithTarget(System.Type,System.Type[],System.Object,Castle.DynamicProxy.ProxyGenerationOptions,System.Object[],Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to virtual members of type <paramref name="classToProxy" /> on newly created instance of that type with given <paramref name="interceptors" />.
            </summary>
      <param name="classToProxy">Type of class which will be proxied.</param>
      <param name="additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="constructorArguments">Arguments of constructor of type <paramref name="classToProxy" /> which should be used to create a new instance of that type.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              New object of type <paramref name="classToProxy" /> proxying calls to virtual members of <paramref name="classToProxy" /> and <paramref name="additionalInterfacesToProxy" /> types.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="options" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is not a class type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when no constructor exists on type <paramref name="classToProxy" /> with parameters matching <paramref name="constructorArguments" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when constructor of type <paramref name="classToProxy" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxy``1(Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to virtual members of type <typeparamref name="TClass" /> on newly created instance of that type with given <paramref name="interceptors" />.
            </summary>
      <typeparam name="TClass">Type of class which will be proxied.</typeparam>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              New object of type <typeparamref name="TClass" /> proxying calls to virtual members of <typeparamref name="TClass" /> type.
            </returns>
      <exception cref="T:System.ArgumentException">Thrown when given <typeparamref name="TClass" /> is not a class type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when no default constructor exists on type <typeparamref name="TClass" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of type <typeparamref name="TClass" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxy``1(Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to virtual members of type <typeparamref name="TClass" /> on newly created instance of that type with given <paramref name="interceptors" />.
            </summary>
      <typeparam name="TClass">Type of class which will be proxied.</typeparam>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              New object of type <typeparamref name="TClass" /> proxying calls to virtual members of <typeparamref name="TClass" /> type.
            </returns>
      <exception cref="T:System.ArgumentException">Thrown when given <typeparamref name="TClass" /> is not a class type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when no default constructor exists on type <typeparamref name="TClass" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of type <typeparamref name="TClass" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxy(System.Type,System.Type[],Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to virtual members of type <paramref name="classToProxy" /> on newly created instance of that type with given <paramref name="interceptors" />.
            </summary>
      <param name="classToProxy">Type of class which will be proxied.</param>
      <param name="additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              New object of type <paramref name="classToProxy" /> proxying calls to virtual members of <paramref name="classToProxy" /> and <paramref name="additionalInterfacesToProxy" /> types.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is not a class type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when no default constructor exists on type <paramref name="classToProxy" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of type <paramref name="classToProxy" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxy(System.Type,Castle.DynamicProxy.ProxyGenerationOptions,System.Object[],Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to virtual members of type <paramref name="classToProxy" /> on newly created instance of that type with given <paramref name="interceptors" />.
            </summary>
      <param name="classToProxy">Type of class which will be proxied.</param>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="constructorArguments">Arguments of constructor of type <paramref name="classToProxy" /> which should be used to create a new instance of that type.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              New object of type <paramref name="classToProxy" /> proxying calls to virtual members of <paramref name="classToProxy" /> type.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is not a class type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when no constructor exists on type <paramref name="classToProxy" /> with parameters matching <paramref name="constructorArguments" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when constructor of type <paramref name="classToProxy" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxy(System.Type,System.Object[],Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to virtual members of type <paramref name="classToProxy" /> on newly created instance of that type with given <paramref name="interceptors" />.
            </summary>
      <param name="classToProxy">Type of class which will be proxied.</param>
      <param name="constructorArguments">Arguments of constructor of type <paramref name="classToProxy" /> which should be used to create a new instance of that type.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              New object of type <paramref name="classToProxy" /> proxying calls to virtual members of <paramref name="classToProxy" /> type.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is not a class type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when no constructor exists on type <paramref name="classToProxy" /> with parameters matching <paramref name="constructorArguments" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when constructor of type <paramref name="classToProxy" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxy(System.Type,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to virtual members of type <paramref name="classToProxy" /> on newly created instance of that type with given <paramref name="interceptors" />.
            </summary>
      <param name="classToProxy">Type of class which will be proxied.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              New object of type <paramref name="classToProxy" /> proxying calls to virtual members of <paramref name="classToProxy" /> type.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is not a class type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when no parameterless constructor exists on type <paramref name="classToProxy" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when constructor of type <paramref name="classToProxy" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxy(System.Type,Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to virtual members of type <paramref name="classToProxy" /> on newly created instance of that type with given <paramref name="interceptors" />.
            </summary>
      <param name="classToProxy">Type of class which will be proxied.</param>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              New object of type <paramref name="classToProxy" /> proxying calls to virtual members of <paramref name="classToProxy" /> type.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="options" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is not a class type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when no default constructor exists on type <paramref name="classToProxy" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of type <paramref name="classToProxy" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxy(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to virtual members of type <paramref name="classToProxy" /> on newly created instance of that type with given <paramref name="interceptors" />.
            </summary>
      <param name="classToProxy">Type of class which will be proxied.</param>
      <param name="additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              New object of type <paramref name="classToProxy" /> proxying calls to virtual members of <paramref name="classToProxy" /> and <paramref name="additionalInterfacesToProxy" /> types.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="options" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is not a class type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when no default constructor exists on type <paramref name="classToProxy" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of type <paramref name="classToProxy" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxy(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions,System.Object[],Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to virtual members of type <paramref name="classToProxy" /> on newly created instance of that type with given <paramref name="interceptors" />.
            </summary>
      <param name="classToProxy">Type of class which will be proxied.</param>
      <param name="additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="constructorArguments">Arguments of constructor of type <paramref name="classToProxy" /> which should be used to create a new instance of that type.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              New object of type <paramref name="classToProxy" /> proxying calls to virtual members of <paramref name="classToProxy" /> and <paramref name="additionalInterfacesToProxy" /> types.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="options" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is not a class type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when no constructor exists on type <paramref name="classToProxy" /> with parameters matching <paramref name="constructorArguments" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when constructor of type <paramref name="classToProxy" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxyType(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)">
      <summary>
              Creates the proxy type for class proxy with given <paramref name="classToProxy" /> class, implementing given <paramref name="additionalInterfacesToProxy" /> and using provided <paramref name="options" />.
            </summary>
      <param name="classToProxy">The base class for proxy type.</param>
      <param name="additionalInterfacesToProxy">The interfaces that proxy type should implement.</param>
      <param name="options">The options for proxy generation process.</param>
      <returns>
        <see cref="T:System.Type" /> of proxy.</returns>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyTypeWithTarget(System.Type,System.Type[],System.Type,Castle.DynamicProxy.ProxyGenerationOptions)">
      <summary>
              Creates the proxy type for interface proxy with target for given <paramref name="interfaceToProxy" /> interface, implementing given <paramref name="additionalInterfacesToProxy" /> on given <paramref name="targetType" /> and using provided <paramref name="options" />.
            </summary>
      <param name="interfaceToProxy">The interface proxy type should implement.</param>
      <param name="additionalInterfacesToProxy">The additional interfaces proxy type should implement.</param>
      <param name="targetType">Actual type that the proxy type will encompass.</param>
      <param name="options">The options for proxy generation process.</param>
      <returns>
        <see cref="T:System.Type" /> of proxy.</returns>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyTypeWithTargetInterface(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)">
      <summary>
              Creates the proxy type for interface proxy with target interface for given <paramref name="interfaceToProxy" /> interface, implementing given <paramref name="additionalInterfacesToProxy" /> on given <paramref name="interfaceToProxy" /> and using provided <paramref name="options" />.
            </summary>
      <param name="interfaceToProxy">The interface proxy type should implement.</param>
      <param name="additionalInterfacesToProxy">The additional interfaces proxy type should implement.</param>
      <param name="options">The options for proxy generation process.</param>
      <returns>
        <see cref="T:System.Type" /> of proxy.</returns>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyTypeWithoutTarget(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)">
      <summary>
              Creates the proxy type for interface proxy without target for given <paramref name="interfaceToProxy" /> interface, implementing given <paramref name="additionalInterfacesToProxy" /> and using provided <paramref name="options" />.
            </summary>
      <param name="interfaceToProxy">The interface proxy type should implement.</param>
      <param name="additionalInterfacesToProxy">The additional interfaces proxy type should implement.</param>
      <param name="options">The options for proxy generation process.</param>
      <returns>
        <see cref="T:System.Type" /> of proxy.</returns>
    </member>
    <member name="P:Castle.DynamicProxy.ProxyGenerator.Logger">
      <summary>
              Gets or sets the <see cref="T:Castle.Core.Logging.ILogger" /> that this <see cref="T:Castle.DynamicProxy.ProxyGenerator" /> log to.
            </summary>
    </member>
    <member name="P:Castle.DynamicProxy.ProxyGenerator.ProxyBuilder">
      <summary>
              Gets the proxy builder instance used to generate proxy types.
            </summary>
      <value>The proxy builder.</value>
    </member>
    <member name="T:Castle.DynamicProxy.Generators.Emitters.LdcOpCodesDictionary">
      <summary>
              s
              Provides appropriate Ldc.X opcode for the type of primitive value to be loaded.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.TypeKeyPrefixAttribute">
      <summary>
            Assigns a prefix to the keyed properties using the interface name.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.ComponentAttribute">
      <summary>
            Identifies a property should be represented as a nested component.
            </summary>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.ComponentAttribute.NoPrefix">
      <summary>
            Applies no prefix.
            </summary>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.ComponentAttribute.Prefix">
      <summary>
            Gets or sets the prefix.
            </summary>
      <value>The prefix.</value>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.DictionaryAdapterFactory">
      <summary>
            Uses Reflection.Emit to expose the properties of a dictionary
            through a dynamic implementation of a typed interface.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.DictionaryAdapterFactory.GetAdapter``1(System.Collections.IDictionary)">
      <inheritdoc />
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.DictionaryAdapterFactory.GetAdapter(System.Type,System.Collections.IDictionary)">
      <inheritdoc />
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.DictionaryAdapterFactory.GetAdapter(System.Type,System.Collections.IDictionary,Castle.Components.DictionaryAdapter.PropertyDescriptor)">
      <inheritdoc />
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.DictionaryAdapterFactory.GetAdapter``2(System.Collections.Generic.IDictionary{System.String,``1})">
      <inheritdoc />
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.DictionaryAdapterFactory.GetAdapter``1(System.Type,System.Collections.Generic.IDictionary{System.String,``0})">
      <inheritdoc />
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.DictionaryAdapterFactory.GetAdapterMeta(System.Type)">
      <inheritdoc />
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.DictionaryAdapterFactory.GetAdapterMeta(System.Type,Castle.Components.DictionaryAdapter.PropertyDescriptor)">
      <inheritdoc />
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.DictionaryAdapterFactory.GetAdapterMeta(System.Type,Castle.Components.DictionaryAdapter.DictionaryAdapterMeta)">
      <inheritdoc />
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.NewGuidAttribute">
      <summary>
            Generates a new GUID on demand.
            </summary>
    </member>
  </members>
</doc>